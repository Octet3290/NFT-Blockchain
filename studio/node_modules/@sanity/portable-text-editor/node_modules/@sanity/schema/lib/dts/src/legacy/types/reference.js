var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import arrify from 'arrify';
import { pick } from 'lodash';
import { lazyGetter } from './utils';
import { DEFAULT_OVERRIDEABLE_FIELDS } from './constants';
import { createFieldsets } from './object';
export var REF_FIELD = {
    name: '_ref',
    title: 'Referenced document ID',
    type: 'string',
};
export var WEAK_FIELD = {
    name: '_weak',
    title: 'Weak reference',
    type: 'boolean',
};
var REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD];
var OVERRIDABLE_FIELDS = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var REFERENCE_CORE = {
    name: 'reference',
    title: 'Reference',
    type: null,
    jsonType: 'object',
};
function humanize(arr, conjunction) {
    var len = arr.length;
    if (len === 1) {
        return arr[0];
    }
    var first = arr.slice(0, len - 1);
    var last = arr[len - 1];
    return "".concat(first.join(', '), " ").concat(conjunction, " ").concat(last);
}
function buildTitle(type) {
    if (!type.to || type.to.length === 0) {
        return 'Reference';
    }
    return "Reference to ".concat(humanize(arrify(type.to).map(function (toType) { return toType.title; }), 'or').toLowerCase());
}
export var ReferenceType = {
    get: function () {
        return REFERENCE_CORE;
    },
    extend: function (subTypeDef, createMemberType) {
        if (!subTypeDef.to) {
            throw new Error("Missing \"to\" field in reference definition. Check the type ".concat(subTypeDef.name));
        }
        var parsed = Object.assign(pick(REFERENCE_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
            type: REFERENCE_CORE,
        });
        lazyGetter(parsed, 'fields', function () {
            return REFERENCE_FIELDS.map(function (fieldDef) {
                var name = fieldDef.name, type = __rest(fieldDef, ["name"]);
                return {
                    name: name,
                    type: createMemberType(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', function () {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'to', function () {
            return arrify(subTypeDef.to).map(function (toType) { return createMemberType(toType); });
        });
        lazyGetter(parsed, 'title', function () { return subTypeDef.title || buildTitle(parsed); });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` of subtypes of "reference"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};
//# sourceMappingURL=reference.js.map