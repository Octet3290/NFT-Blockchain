import { isIndexSegment, isKeySegment, isIndexTuple } from '@sanity/types';

const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const reKeySegment = /_key\s*==\s*['"](.*)['"]/;
const EMPTY_PATH = [];
const FOCUS_TERMINATOR = '$';
function get(obj, path, defaultVal) {
    const select = typeof path === 'string' ? fromString(path) : path;
    if (!Array.isArray(select)) {
        throw new Error('Path must be an array or a string');
    }
    let acc = obj;
    for (let i = 0; i < select.length; i++) {
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) {
                return defaultVal;
            }
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) {
                return defaultVal;
            }
            acc = acc.find((item) => item._key === segment._key);
        }
        if (typeof segment === 'string') {
            acc =
                typeof acc === 'object' && acc !== null
                    ? acc[segment]
                    : undefined;
        }
        if (typeof acc === 'undefined') {
            return defaultVal;
        }
    }
    return acc;
}
const pathsMemo = new Map();
function pathFor(path) {
    if (path.length === 0) {
        return EMPTY_PATH;
    }
    const asString = toString(path);
    if (pathsMemo.has(asString)) {
        return pathsMemo.get(asString);
    }
    pathsMemo.set(asString, path);
    Object.freeze(path);
    return path;
}
function isEqual(path, otherPath) {
    return (path.length === otherPath.length &&
        path.every((segment, i) => isSegmentEqual(segment, otherPath[i])));
}
function numEqualSegments(path, otherPath) {
    const length = Math.min(path.length, otherPath.length);
    for (let i = 0; i < length; i++) {
        if (!isSegmentEqual(path[i], otherPath[i])) {
            return i;
        }
    }
    return length;
}
function isSegmentEqual(segmentA, segmentB) {
    if (isKeySegment(segmentA) && isKeySegment(segmentB)) {
        return segmentA._key === segmentB._key;
    }
    if (isIndexSegment(segmentA)) {
        return Number(segmentA) === Number(segmentB);
    }
    if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {
        return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1];
    }
    return segmentA === segmentB;
}
function hasFocus(focusPath, path) {
    const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;
    return isEqual(withoutTerminator, path);
}
function hasItemFocus(focusPath, item) {
    return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}
function isExpanded(segment, focusPath) {
    const [head, ...tail] = focusPath;
    return tail.length > 0 && isSegmentEqual(segment, head);
}
function startsWith(prefix, path) {
    return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));
}
function trimLeft(prefix, path) {
    if (prefix.length === 0 || path.length === 0) {
        return path;
    }
    const [prefixHead, ...prefixTail] = prefix;
    const [pathHead, ...pathTail] = path;
    if (!isSegmentEqual(prefixHead, pathHead)) {
        return path;
    }
    return pathFor(trimLeft(prefixTail, pathTail));
}
function trimRight(suffix, path) {
    const sufLen = suffix.length;
    const pathLen = path.length;
    if (sufLen === 0 || pathLen === 0) {
        return path;
    }
    let i = 0;
    while (i < sufLen &&
        i < pathLen &&
        isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])) {
        i++;
    }
    return pathFor(path.slice(0, pathLen - i));
}
function trimChildPath(path, childPath) {
    return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;
}
function toString(path) {
    if (!Array.isArray(path)) {
        throw new Error('Path is not an array');
    }
    return path.reduce((target, segment, i) => {
        const segmentType = typeof segment;
        if (segmentType === 'number') {
            return `${target}[${segment}]`;
        }
        if (segmentType === 'string') {
            const separator = i === 0 ? '' : '.';
            return `${target}${separator}${segment}`;
        }
        if (isKeySegment(segment) && segment._key) {
            return `${target}[_key=="${segment._key}"]`;
        }
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, '');
}
function fromString(path) {
    if (typeof path !== 'string') {
        throw new Error('Path is not a string');
    }
    const segments = path.match(rePropName);
    if (!segments) {
        throw new Error('Invalid path string');
    }
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    if (isIndexSegment(segment)) {
        return normalizeIndexSegment(segment);
    }
    if (isKeySegment(segment)) {
        return normalizeKeySegment(segment);
    }
    if (isIndexTuple(segment)) {
        return normalizeIndexTupleSegment(segment);
    }
    return segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ''));
}
function normalizeKeySegment(segment) {
    const segments = segment.match(reKeySegment);
    return { _key: segments[1] };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)));
    return [from, to];
}

export { FOCUS_TERMINATOR, fromString, get, hasFocus, hasItemFocus, isEqual, isExpanded, isSegmentEqual, numEqualSegments, pathFor, startsWith, toString, trimChildPath, trimLeft, trimRight };
//# sourceMappingURL=paths.js.map
