import { _ as __spreadArray, a as __read, b as __assign, c as __rest } from '../_tslib.es6-21983367.js';
import { pick, omit, omitBy, isUndefined, capitalize, startCase, isPlainObject, toPath, uniqBy, keyBy, castArray, flatMap } from 'lodash';
import arrify from 'arrify';

var DEFAULT_OVERRIDEABLE_FIELDS = [
    'jsonType',
    'type',
    'name',
    'title',
    'description',
    'options',
    'fieldsets',
    'validation',
    'readOnly',
    'hidden',
    'components',
    'diffComponent',
    'initialValue',
];

var OVERRIDABLE_FIELDS$e = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var ANY_CORE = {
    name: 'any',
    type: null,
    jsonType: 'any',
};
var AnyType = {
    get: function () {
        return ANY_CORE;
    },
    extend: function (subTypeDef, extendMember) {
        var parsed = Object.assign(pick(ANY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
            type: ANY_CORE,
            of: subTypeDef.of.map(function (fieldDef) {
                return {
                    name: fieldDef.name,
                    type: extendMember(omit(fieldDef, 'name')),
                };
            }),
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` property of subtypes of "array"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$e), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var primitivePreview = {
    prepare: function (val) { return ({ title: String(val) }); },
};

var OVERRIDABLE_FIELDS$d = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var STRING_CORE = {
    name: 'string',
    title: 'String',
    type: null,
    jsonType: 'string',
};
var StringType = {
    get: function () {
        return STRING_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(STRING_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
            type: STRING_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$d), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$c = __spreadArray(__spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false), ['rows'], false);
var TEXT_CORE = {
    name: 'text',
    title: 'Text',
    type: null,
    jsonType: 'string',
};
var TextType = {
    get: function () {
        return TEXT_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(TEXT_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
            type: TEXT_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$c), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$b = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var DATETIME_CORE = {
    name: 'datetime',
    title: 'Datetime',
    type: null,
    jsonType: 'string',
};
var DateTimeType = {
    get: function () {
        return DATETIME_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(DATETIME_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
            type: DATETIME_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$b), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$a = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var DATE_CORE = {
    name: 'date',
    title: 'Datetime',
    type: null,
    jsonType: 'string',
};
var DateType = {
    get: function () {
        return DATE_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(DATE_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
            type: DATE_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$a), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$9 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var BOOLEAN_CORE = {
    name: 'boolean',
    title: 'Boolean',
    type: null,
    jsonType: 'boolean',
};
var BooleanType = {
    get: function () {
        return BOOLEAN_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(BOOLEAN_CORE, OVERRIDABLE_FIELDS$9), subTypeDef, {
            type: BOOLEAN_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$9), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$8 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var URL_CORE = {
    name: 'url',
    title: 'Url',
    type: null,
    jsonType: 'string',
};
var UrlType = {
    get: function () {
        return URL_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(URL_CORE, OVERRIDABLE_FIELDS$8), subTypeDef, {
            type: URL_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$8), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$7 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var EMAIL_CORE = {
    name: 'email',
    title: 'Email',
    type: null,
    jsonType: 'string',
};
var EmailType = {
    get: function () {
        return EMAIL_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(EMAIL_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
            type: EMAIL_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$7), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var OVERRIDABLE_FIELDS$6 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var NUMBER_CORE = {
    name: 'number',
    title: 'Number',
    type: null,
    jsonType: 'number',
};
var NumberType = {
    get: function () {
        return NUMBER_CORE;
    },
    extend: function (subTypeDef) {
        var parsed = Object.assign(pick(NUMBER_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
            type: NUMBER_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$6), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

function lazyGetter(target, key, getter, config) {
    if (config === void 0) { config = {}; }
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: config.enumerable !== false,
        get: function () {
            var val = getter();
            Object.defineProperty(target, key, {
                value: val,
                writable: Boolean(config.writable),
                configurable: false,
            });
            return val;
        },
    });
    return target;
}
//
// const o = lazyGetter({}, 'expensive', function() {
//   console.log('doing expensive calculations')
//   return 'RESULT OF EXPENSIVE'
// })
//
// console.log(o.expensive)
// console.log(o.expensive)
// console.log(o.expensive)

function isEmpty(object) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
function _stringify(value, options, depth) {
    if (depth > options.maxDepth) {
        return '...';
    }
    if (Array.isArray(value)) {
        if (value.length === 0) {
            return '[empty]';
        }
        var capLength = Math.max(value.length - options.maxBreadth);
        var asString_1 = value
            .slice(0, options.maxBreadth)
            .map(function (item, index) { return _stringify(item, options, depth + 1); })
            .concat(capLength > 0 ? "\u2026+".concat(capLength) : [])
            .join(', ');
        return depth === 0 ? asString_1 : "[".concat(asString_1, "]");
    }
    if (typeof value === 'object' && value !== null) {
        var keys = Object.keys(value).filter(function (key) { return !options.ignoreKeys.includes(key) && typeof value[key] !== 'undefined'; });
        if (isEmpty(pick(value, keys))) {
            return '{empty}';
        }
        var asString_2 = keys
            .slice(0, options.maxBreadth)
            .map(function (key) { return "".concat(key, ": ").concat(_stringify(value[key], options, depth + 1)); })
            .join(', ');
        return depth === 0 ? asString_2 : "{".concat(asString_2, "}");
    }
    var asString = String(value);
    return asString === '' ? '""' : asString;
}
function stringify(value, options) {
    if (options === void 0) { options = {}; }
    var opts = {
        maxDepth: 'maxDepth' in options ? options.maxDepth : 2,
        maxBreadth: 'maxBreadth' in options ? options.maxBreadth : 2,
        ignoreKeys: 'ignoreKeys' in options ? options.ignoreKeys : [],
    };
    return _stringify(value, opts, 0);
}

var OPTIONS = {
    maxEntries: 2,
    maxDepth: 2,
    maxBreadth: 2,
    ignoreKeys: ['_id', '_type', '_key', '_ref'],
};
function createFallbackPrepare(fieldNames) {
    return function (value) { return ({
        title: stringify(pick(value, fieldNames), OPTIONS),
    }); };
}

function isBlockField(field) {
    return field.type === 'array' && field.of && field.of.some(function (member) { return member.type === 'block'; });
}

var TITLE_CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption'];
var DESCRIPTION_CANDIDATES = __spreadArray(['description'], __read(TITLE_CANDIDATES), false);
function fieldHasReferenceTo(fieldDef, refType) {
    return arrify(fieldDef.to || []).some(function (memberTypeDef) { return memberTypeDef.type === refType; });
}
function isImageAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, 'sanity.imageAsset');
}
function resolveImageAssetPath(typeDef) {
    var fields = typeDef.fields || [];
    var imageAssetField = fields.find(isImageAssetField);
    if (imageAssetField) {
        return imageAssetField.name;
    }
    var fieldWithImageAsset = fields.find(function (fieldDef) {
        return (fieldDef.fields || []).some(isImageAssetField);
    });
    return fieldWithImageAsset ? "".concat(fieldWithImageAsset.name, ".asset") : undefined;
}
function isFileAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, 'sanity.fileAsset');
}
function resolveFileAssetPath(typeDef) {
    var fields = typeDef.fields || [];
    var assetField = fields.find(isFileAssetField);
    if (assetField) {
        return assetField.name;
    }
    var fieldWithFileAsset = fields.find(function (fieldDef) {
        return (fieldDef.fields || []).some(isFileAssetField);
    });
    return fieldWithFileAsset ? "".concat(fieldWithFileAsset.name, ".asset") : undefined;
}
function guessPreviewFields(rawObjectTypeDef) {
    var objectTypeDef = __assign({ fields: [] }, rawObjectTypeDef);
    var stringFieldNames = objectTypeDef.fields
        .filter(function (field) { return field.type === 'string'; })
        .map(function (field) { return field.name; });
    var blockFieldNames = objectTypeDef.fields.filter(isBlockField).map(function (field) { return field.name; });
    // Check if we have fields with names that is listed in candidate fields
    var titleField = TITLE_CANDIDATES.find(function (candidate) { return stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate); });
    var descField = DESCRIPTION_CANDIDATES.find(function (candidate) {
        return candidate !== titleField &&
            (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate));
    });
    if (!titleField) {
        // Pick first defined string field
        titleField = stringFieldNames[0] || blockFieldNames[0];
        // Pick next as desc
        descField = stringFieldNames[1] || blockFieldNames[1];
    }
    var mediaField = objectTypeDef.fields.find(function (field) { return field.type === 'image'; });
    var imageAssetPath = resolveImageAssetPath(objectTypeDef);
    if (!titleField) {
        var fileAssetPath = resolveFileAssetPath(objectTypeDef);
        if (fileAssetPath) {
            titleField = "".concat(fileAssetPath, ".originalFilename");
        }
        if (imageAssetPath) {
            titleField = "".concat(imageAssetPath, ".originalFilename");
        }
    }
    if (!titleField && !imageAssetPath) {
        // last resort, pick all fields and concat them
        var fieldNames = objectTypeDef.fields.map(function (field) { return field.name; });
        var fieldMapping = fieldNames.reduce(function (acc, fieldName) {
            acc[fieldName] = fieldName;
            return acc;
        }, {});
        return {
            select: fieldMapping,
            prepare: createFallbackPrepare(fieldNames),
        };
    }
    var select = omitBy({
        title: titleField,
        description: descField,
        imageUrl: !mediaField && imageAssetPath ? "".concat(imageAssetPath, ".url") : undefined,
        media: mediaField ? mediaField.name : undefined,
    }, isUndefined);
    return {
        select: select,
    };
}

function warnIfPreviewOnOptions(type) {
    if (type.options && type.options.preview) {
        // eslint-disable-next-line no-console
        console.warn("Heads up! The preview config is no longer defined on \"options\", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of \"".concat(type.name, "\".\n"));
    }
}
function warnIfPreviewHasFields(type) {
    var preview = type.preview || (type.options || {}).preview;
    if (preview && 'fields' in preview) {
        // eslint-disable-next-line no-console
        console.warn("Heads up! \"preview.fields\" should be renamed to \"preview.select\". Please update the preview config for \"".concat(type.name, "\".\n"));
    }
}

function parseSelection(selection) {
    return selection.reduce(function (acc, field) {
        acc[field] = field;
        return acc;
    }, {});
}
function parsePreview(preview) {
    if (!preview) {
        return preview;
    }
    var select = preview.select || preview.fields || {};
    if (Array.isArray(select)) {
        return __assign(__assign({}, pick(preview, ['prepare', 'component'])), { select: parseSelection(select) });
    }
    return __assign(__assign({}, pick(preview, ['prepare', 'component'])), { select: select });
}
function createPreviewGetter(objectTypeDef) {
    return function previewGetter() {
        warnIfPreviewOnOptions(objectTypeDef);
        warnIfPreviewHasFields(objectTypeDef);
        var preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview);
        return preview || guessPreviewFields(objectTypeDef);
    };
}

var CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption', 'description'];
var PRIMITIVES = ['string', 'boolean', 'number'];
var isPrimitive = function (field) { return PRIMITIVES.includes(field.type); };
function guessOrderingConfig(objectTypeDef) {
    var candidates = CANDIDATES.filter(function (candidate) {
        return objectTypeDef.fields.some(function (field) { return isPrimitive(field) && field.name === candidate; });
    });
    // None of the candidates were found, fallback to all fields
    if (candidates.length === 0) {
        candidates = objectTypeDef.fields.filter(isPrimitive).map(function (field) { return field.name; });
    }
    return candidates.map(function (name) { return ({
        name: name,
        title: capitalize(startCase(name)),
        by: [{ field: name, direction: 'asc' }],
    }); });
}

function normalizeSearchConfigs(configs) {
    if (!Array.isArray(configs)) {
        throw new Error('The search config of a document type must be an array of search config objects');
    }
    return configs.map(function (conf) {
        if (conf === 'defaults') {
            return conf;
        }
        if (!isPlainObject(conf)) {
            throw new Error('Search config must be an object of {path: string, weight: number}');
        }
        return {
            weight: 'weight' in conf ? conf.weight : 1,
            path: toPath(conf.path),
            mapWith: typeof conf.mapWith === 'string' ? conf.mapWith : undefined,
        };
    });
}

var stringFieldsSymbol = Symbol('__cachedStringFields');
var isReference = function (type) { return type.type && type.type.name === 'reference'; };
var portableTextFields = ['style', 'list'];
var isPortableTextBlock = function (type) {
    return type.name === 'block' || (type.type && isPortableTextBlock(type.type));
};
var isPortableTextArray = function (type) {
    return type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
};
function reduceType(type, reducer, acc, path, maxDepth) {
    if (path === void 0) { path = []; }
    if (maxDepth < 0) {
        return acc;
    }
    var accumulator = reducer(acc, type, path);
    if (type.jsonType === 'array' && Array.isArray(type.of)) {
        return reduceArray(type, reducer, accumulator, path, maxDepth);
    }
    if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {
        return reduceObject(type, reducer, accumulator, path, maxDepth);
    }
    return accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
    return arrayType.of.reduce(function (acc, ofType) { return reduceType(ofType, reducer, acc, path, maxDepth - 1); }, accumulator);
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
    var isPtBlock = isPortableTextBlock(objectType);
    return objectType.fields.reduce(function (acc, field) {
        // Don't include styles and list types as searchable paths for portable text blocks
        if (isPtBlock && portableTextFields.includes(field.name)) {
            return acc;
        }
        var segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : []);
        return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
    }, accumulator);
}
var BASE_WEIGHTS = [
    { weight: 1, path: ['_id'] },
    { weight: 1, path: ['_type'] },
];
var PREVIEW_FIELD_WEIGHT_MAP = {
    title: 10,
    subtitle: 5,
    description: 1.5,
};
function deriveFromPreview(type) {
    var select = type.preview.select;
    return Object.keys(select)
        .filter(function (fieldName) { return fieldName in PREVIEW_FIELD_WEIGHT_MAP; })
        .map(function (fieldName) { return ({
        weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
        path: select[fieldName].split('.'),
    }); });
}
function getCachedStringFieldPaths(type, maxDepth) {
    if (!type[stringFieldsSymbol]) {
        type[stringFieldsSymbol] = uniqBy(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(BASE_WEIGHTS), false), __read(deriveFromPreview(type)), false), __read(getStringFieldPaths(type, maxDepth).map(function (path) { return ({ weight: 1, path: path }); })), false), __read(getPortableTextFieldPaths(type, maxDepth).map(function (path) { return ({
            weight: 1,
            path: path,
            mapWith: 'pt::text',
        }); })), false), function (spec) { return spec.path.join('.'); });
    }
    return type[stringFieldsSymbol];
}
function getStringFieldPaths(type, maxDepth) {
    var reducer = function (accumulator, childType, path) {
        return childType.jsonType === 'string' ? __spreadArray(__spreadArray([], __read(accumulator), false), [path], false) : accumulator;
    };
    return reduceType(type, reducer, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
    var reducer = function (accumulator, childType, path) {
        return isPortableTextArray(childType) ? __spreadArray(__spreadArray([], __read(accumulator), false), [path], false) : accumulator;
    };
    return reduceType(type, reducer, [], [], maxDepth);
}
function resolveSearchConfig(type) {
    return getCachedStringFieldPaths(type, 4);
}

var OVERRIDABLE_FIELDS$5 = __spreadArray(__spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false), [
    'orderings',
    '__experimental_search',
    'blockEditor',
    'icon',
], false);
var ObjectType = {
    get: function () {
        return {
            name: 'object',
            title: 'Object',
            type: null,
            jsonType: 'object',
        };
    },
    extend: function (rawSubTypeDef, createMemberType) {
        var subTypeDef = __assign({ fields: [] }, rawSubTypeDef);
        var options = __assign({}, (subTypeDef.options || {}));
        var parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
            type: this.get(),
            title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ''),
            options: options,
            orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
            fields: subTypeDef.fields.map(function (fieldDef) {
                var name = fieldDef.name, fieldset = fieldDef.fieldset, group = fieldDef.group, rest = __rest(fieldDef, ["name", "fieldset", "group"]);
                var compiledField = {
                    name: name,
                    group: group,
                    fieldset: fieldset,
                };
                return lazyGetter(compiledField, 'type', function () {
                    return createMemberType(__assign(__assign({}, rest), { title: fieldDef.title || startCase(name) }));
                });
            }),
        });
        lazyGetter(parsed, 'fieldsets', function () {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'groups', function () {
            return createFieldsGroups(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        lazyGetter(parsed, '__experimental_search', function () {
            var userProvidedSearchConfig = subTypeDef.__experimental_search
                ? normalizeSearchConfigs(subTypeDef.__experimental_search)
                : null;
            if (userProvidedSearchConfig) {
                return userProvidedSearchConfig.map(function (entry) {
                    return entry === 'defaults' ? normalizeSearchConfigs(subTypeDef) : entry;
                });
            }
            return resolveSearchConfig(parsed);
        }, {
            enumerable: false,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "object"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$5), {
                        title: extensionDef.title ||
                            subTypeDef.title ||
                            (subTypeDef.name ? startCase(subTypeDef.name) : ''),
                        type: parent,
                    });
                    lazyGetter(current, '__experimental_search', function () { return parent.__experimental_search; });
                    return subtype(current);
                },
            };
        }
    },
};
function createFieldsets(typeDef, fields) {
    var fieldsetsDef = typeDef.fieldsets || [];
    var fieldsets = fieldsetsDef.map(function (fieldset) {
        var name = fieldset.name, title = fieldset.title, description = fieldset.description, options = fieldset.options, group = fieldset.group, hidden = fieldset.hidden, readOnly = fieldset.readOnly;
        return {
            name: name,
            title: title,
            description: description,
            options: options,
            group: group,
            fields: [],
            hidden: hidden,
            readOnly: readOnly,
        };
    });
    var fieldsetsByName = keyBy(fieldsets, 'name');
    return fields
        .map(function (field) {
        if (field.fieldset) {
            var fieldset = fieldsetsByName[field.fieldset];
            if (!fieldset) {
                throw new Error("Fieldset '".concat(field.fieldset, "' is not defined in schema for type '").concat(typeDef.name, "'"));
            }
            fieldset.fields.push(field);
            // Return the fieldset if its the first time we encounter a field in this fieldset
            return fieldset.fields.length === 1 ? fieldset : null;
        }
        return { single: true, field: field };
    })
        .filter(Boolean);
}
function createFieldsGroups(typeDef, fields) {
    var _a;
    var groupsDef = typeDef.groups || [];
    var groups = groupsDef.map(function (group) {
        var name = group.name, title = group.title, description = group.description, icon = group.icon, readOnly = group.readOnly, hidden = group.hidden;
        return {
            name: name,
            title: title,
            description: description,
            icon: icon,
            readOnly: readOnly,
            default: group.default,
            hidden: hidden,
            fields: [],
        };
    });
    var defaultGroups = groups.filter(function (group) { return group.default; });
    if (defaultGroups.length > 1) {
        // Throw if you have multiple default field groups defined
        throw new Error("You currently have ".concat(defaultGroups.length, " default field groups defined for type '").concat(typeDef.name ? startCase(typeDef.name) : (_a = typeDef.title) !== null && _a !== void 0 ? _a : "", "', but only 1 is supported"));
    }
    var groupsByName = keyBy(groups, 'name');
    fields.forEach(function (field) {
        if (field.group) {
            var fieldGroupNames = castArray(field.group);
            if (fieldGroupNames.length > 0) {
                fieldGroupNames.forEach(function (fieldGroupName) {
                    var _a, _b;
                    var currentGroup = groupsByName[fieldGroupName];
                    if (!currentGroup) {
                        throw new Error("Field group '".concat(fieldGroupName, "' is not defined in schema for type '").concat((_b = (_a = typeDef.name) !== null && _a !== void 0 ? _a : typeDef.title) !== null && _b !== void 0 ? _b : "", "'"));
                    }
                    currentGroup.fields.push(field);
                });
            }
        }
    });
    return flatMap(groupsByName).filter(function (group) { return group.fields.length > 0; });
}

var REF_FIELD$1 = {
    name: '_ref',
    title: 'Referenced document ID',
    type: 'string',
};
var WEAK_FIELD$1 = {
    name: '_weak',
    title: 'Weak reference',
    type: 'boolean',
};
var REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1];
var OVERRIDABLE_FIELDS$4 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var REFERENCE_CORE = {
    name: 'reference',
    title: 'Reference',
    type: null,
    jsonType: 'object',
};
function humanize$1(arr, conjunction) {
    var len = arr.length;
    if (len === 1) {
        return arr[0];
    }
    var first = arr.slice(0, len - 1);
    var last = arr[len - 1];
    return "".concat(first.join(', '), " ").concat(conjunction, " ").concat(last);
}
function buildTitle$1(type) {
    if (!type.to || type.to.length === 0) {
        return 'Reference';
    }
    return "Reference to ".concat(humanize$1(arrify(type.to).map(function (toType) { return toType.title; }), 'or').toLowerCase());
}
var ReferenceType = {
    get: function () {
        return REFERENCE_CORE;
    },
    extend: function (subTypeDef, createMemberType) {
        if (!subTypeDef.to) {
            throw new Error("Missing \"to\" field in reference definition. Check the type ".concat(subTypeDef.name));
        }
        var parsed = Object.assign(pick(REFERENCE_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
            type: REFERENCE_CORE,
        });
        lazyGetter(parsed, 'fields', function () {
            return REFERENCE_FIELDS$1.map(function (fieldDef) {
                var name = fieldDef.name, type = __rest(fieldDef, ["name"]);
                return {
                    name: name,
                    type: createMemberType(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', function () {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'to', function () {
            return arrify(subTypeDef.to).map(function (toType) { return createMemberType(toType); });
        });
        lazyGetter(parsed, 'title', function () { return subTypeDef.title || buildTitle$1(parsed); });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` of subtypes of "reference"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$4), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var REF_FIELD = {
    name: '_ref',
    title: 'Referenced document ID',
    type: 'string',
};
var WEAK_FIELD = {
    name: '_weak',
    title: 'Weak reference marker',
    type: 'boolean',
};
var REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD];
var OVERRIDABLE_FIELDS$3 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var CROSS_DATASET_REFERENCE_CORE = {
    name: 'crossDatasetReference',
    type: null,
    jsonType: 'object',
};
function humanize(arr, conjunction) {
    var len = arr.length;
    if (len === 1) {
        return arr[0];
    }
    var first = arr.slice(0, len - 1);
    var last = arr[len - 1];
    return "".concat(first.join(', '), " ").concat(conjunction, " ").concat(last);
}
function buildTitle(type) {
    if (!type.to || type.to.length === 0) {
        return 'Cross dataset Reference';
    }
    return "Cross dataset reference to ".concat(humanize(arrify(type.to).map(function (toType) { return toType.title || capitalize(toType.type); }), 'or').toLowerCase());
}
var CrossDatasetReferenceType = {
    get: function () {
        return CROSS_DATASET_REFERENCE_CORE;
    },
    extend: function (subTypeDef, createMemberType) {
        if (!subTypeDef.to) {
            throw new Error("Missing \"to\" field in cross dataset reference definition. Check the type ".concat(subTypeDef.name));
        }
        var parsed = Object.assign(pick(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
            type: CROSS_DATASET_REFERENCE_CORE,
        });
        lazyGetter(parsed, 'fields', function () {
            return REFERENCE_FIELDS.map(function (fieldDef) {
                var name = fieldDef.name, type = __rest(fieldDef, ["name"]);
                return {
                    name: name,
                    type: createMemberType(type),
                };
            });
        });
        lazyGetter(parsed, 'to', function () {
            return arrify(subTypeDef.to).map(function (toType) {
                return __assign(__assign({}, toType), { 
                    // eslint-disable-next-line camelcase
                    __experimental_search: normalizeSearchConfigs(toType.__experimental_search) });
            });
        });
        lazyGetter(parsed, 'title', function () { return subTypeDef.title || buildTitle(parsed); });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` of subtypes of "reference"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$3), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var ASSET_FIELD$1 = {
    name: 'asset',
    type: 'reference',
    to: [{ type: 'sanity.imageAsset' }],
};
var HOTSPOT_FIELD = {
    name: 'hotspot',
    type: 'sanity.imageHotspot',
};
var CROP_FIELD = {
    name: 'crop',
    type: 'sanity.imageCrop',
};

var OVERRIDABLE_FIELDS$2 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var IMAGE_CORE = {
    name: 'image',
    title: 'Image',
    type: null,
    jsonType: 'object',
};
var DEFAULT_OPTIONS$3 = {};
var ImageType = {
    get: function () {
        return IMAGE_CORE;
    },
    extend: function (subTypeDef, extendMember) {
        var options = __assign({}, (subTypeDef.options || DEFAULT_OPTIONS$3));
        var hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];
        if (!options.hotspot) {
            hotspotFields = hotspotFields.map(function (field) { return (__assign(__assign({}, field), { hidden: true })); });
        }
        var fields = __spreadArray(__spreadArray([ASSET_FIELD$1], __read(hotspotFields), false), __read((subTypeDef.fields || [])), false);
        var parsed = Object.assign(pick(IMAGE_CORE, OVERRIDABLE_FIELDS$2), subTypeDef, {
            type: IMAGE_CORE,
            title: subTypeDef.title || startCase(subTypeDef.name || subTypeDef.type || ''),
            options: options,
            isCustomized: Boolean(subTypeDef.fields),
        });
        lazyGetter(parsed, 'fields', function () {
            return fields.map(function (fieldDef) {
                var name = fieldDef.name, fieldset = fieldDef.fieldset, type = __rest(fieldDef, ["name", "fieldset"]);
                return {
                    name: name,
                    fieldset: fieldset,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', function () {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, { fields: fields })));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "image"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$2), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var ASSET_FIELD = {
    name: 'asset',
    type: 'reference',
    to: { type: 'sanity.fileAsset' },
};
var OVERRIDABLE_FIELDS$1 = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var FILE_CORE = {
    name: 'file',
    title: 'File',
    type: null,
    jsonType: 'object',
};
var DEFAULT_OPTIONS$2 = {
    accept: '',
};
var FileType = {
    get: function () {
        return FILE_CORE;
    },
    extend: function (subTypeDef, extendMember) {
        var options = __assign({}, (subTypeDef.options || DEFAULT_OPTIONS$2));
        var fields = __spreadArray([ASSET_FIELD], __read((subTypeDef.fields || [])), false);
        var parsed = Object.assign(pick(FILE_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
            type: FILE_CORE,
            options: options,
            isCustomized: Boolean(subTypeDef.fields),
        });
        lazyGetter(parsed, 'fields', function () {
            return fields.map(function (fieldDef) {
                var name = fieldDef.name, fieldset = fieldDef.fieldset, type = __rest(fieldDef, ["name", "fieldset"]);
                return {
                    name: name,
                    fieldset: fieldset,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', function () {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, { fields: fields })));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "file"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$1), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var DOCUMENT_CORE = {
    name: 'document',
    title: 'Document',
    type: null,
    jsonType: 'object',
};
var DocumentType = {
    get: function () {
        return DOCUMENT_CORE;
    },
    extend: ObjectType.extend,
};

var OVERRIDABLE_FIELDS = __spreadArray([], __read(DEFAULT_OVERRIDEABLE_FIELDS), false);
var ARRAY_CORE = {
    name: 'array',
    type: null,
    jsonType: 'array',
    of: [],
};
var ArrayType = {
    get: function () {
        return ARRAY_CORE;
    },
    extend: function (subTypeDef, createMemberType) {
        var parsed = Object.assign(pick(ARRAY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
            type: ARRAY_CORE,
        });
        lazyGetter(parsed, 'of', function () {
            return subTypeDef.of.map(function (ofTypeDef) {
                return createMemberType(ofTypeDef);
            });
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` property of subtypes of "array"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var DEFAULT_LINK_ANNOTATION = {
    type: 'object',
    name: 'link',
    options: {
        modal: { type: 'popover' },
    },
    fields: [
        {
            name: 'href',
            type: 'url',
            title: 'Url',
            validation: function (Rule) {
                return Rule.uri({
                    scheme: ['http', 'https', 'tel', 'mailto'],
                    allowRelative: true,
                });
            },
        },
    ],
};
var DEFAULT_TEXT_FIELD = {
    type: 'text',
    name: 'text',
    title: 'Text',
};
var DEFAULT_MARKS_FIELD = {
    name: 'marks',
    type: 'array',
    of: [{ type: 'string' }],
    title: 'Marks',
};
var LIST_TYPES = {
    bullet: { title: 'Bullet', value: 'bullet' },
    numbered: { title: 'Numbered', value: 'number' },
};
var DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered];
var BLOCK_STYLES = {
    normal: { title: 'Normal', value: 'normal' },
    h1: { title: 'Heading 1', value: 'h1' },
    h2: { title: 'Heading 2', value: 'h2' },
    h3: { title: 'Heading 3', value: 'h3' },
    h4: { title: 'Heading 4', value: 'h4' },
    h5: { title: 'Heading 5', value: 'h5' },
    h6: { title: 'Heading 6', value: 'h6' },
    blockquote: { title: 'Quote', value: 'blockquote' },
};
var DEFAULT_BLOCK_STYLES = [
    BLOCK_STYLES.normal,
    BLOCK_STYLES.h1,
    BLOCK_STYLES.h2,
    BLOCK_STYLES.h3,
    BLOCK_STYLES.h4,
    BLOCK_STYLES.h5,
    BLOCK_STYLES.h6,
    BLOCK_STYLES.blockquote,
];
var DECORATOR_STRONG = { title: 'Strong', value: 'strong' };
var DECORATOR_EMPHASIS = { title: 'Emphasis', value: 'em' };
var DECORATOR_CODE = { title: 'Code', value: 'code' };
var DECORATOR_UNDERLINE = { title: 'Underline', value: 'underline' };
var DECORATOR_STRIKE = { title: 'Strike', value: 'strike-through' };
var DECORATORS = {
    strong: DECORATOR_STRONG,
    em: DECORATOR_EMPHASIS,
    code: DECORATOR_CODE,
    underline: DECORATOR_UNDERLINE,
    strikeThrough: DECORATOR_STRIKE,
};
var DEFAULT_DECORATORS = [
    DECORATORS.strong,
    DECORATORS.em,
    DECORATORS.code,
    DECORATORS.underline,
    DECORATORS.strikeThrough,
];

var INHERITED_FIELDS$1 = [
    'type',
    'name',
    'title',
    'jsonType',
    'description',
    'options',
    'fieldsets',
    'icon',
];
var BLOCK_CORE = {
    name: 'block',
    title: 'Block',
    type: null,
    jsonType: 'object',
};
var DEFAULT_OPTIONS$1 = {};
var BlockType = {
    get: function () {
        return BLOCK_CORE;
    },
    extend: function (subTypeDef, extendMember) {
        var options = __assign({}, (subTypeDef.options || DEFAULT_OPTIONS$1));
        var marks = subTypeDef.marks, styles = subTypeDef.styles, lists = subTypeDef.lists, of = subTypeDef.of, rest = __rest(subTypeDef, ["marks", "styles", "lists", "of"]);
        var childrenField = createChildrenField(marks, of);
        var styleField = createStyleField(styles);
        var listField = createListField(lists);
        var markDefsField = {
            name: 'markDefs',
            title: 'Mark definitions',
            type: 'array',
            of: (marks === null || marks === void 0 ? void 0 : marks.annotations) || DEFAULT_ANNOTATIONS,
        };
        // NOTE: if you update this (EVEN THE ORDER OF FIELDS) you _NEED TO_ also
        // update `BlockSchemaType`, `isBlockSchemaType` and similar in `@sanity/types`
        var fields = [childrenField, styleField, listField, markDefsField].concat(subTypeDef.fields || []);
        var parsed = Object.assign(pick(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
            type: BLOCK_CORE,
            options: options,
        });
        lazyGetter(parsed, 'fields', function () {
            return fields.map(function (fieldDef) {
                var name = fieldDef.name, type = __rest(fieldDef, ["name"]);
                return {
                    name: name,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "block"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS$1), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};
function ensureNormalStyle(styles) {
    return styles.some(function (style) { return style.value === 'normal'; })
        ? styles
        : __spreadArray([BLOCK_STYLES.normal], __read(styles), false);
}
function createStyleField(styles) {
    return {
        name: 'style',
        title: 'Style',
        type: 'string',
        options: {
            list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES),
        },
    };
}
function createListField(lists) {
    return {
        name: 'list',
        title: 'List type',
        type: 'string',
        options: {
            list: lists || DEFAULT_LIST_TYPES,
        },
    };
}
var DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];
function createChildrenField(marks, of) {
    if (of === void 0) { of = []; }
    return {
        name: 'children',
        title: 'Content',
        type: 'array',
        of: __spreadArray([
            {
                type: 'span',
                fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],
                annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
                decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS,
            }
        ], __read(of.filter(function (memberType) { return memberType.type !== 'span'; })), false),
    };
}

var INHERITED_FIELDS = [
    'type',
    'name',
    'title',
    'jsonType',
    'description',
    'options',
    'fieldsets',
    'icon',
];
var SPAN_CORE = {
    name: 'span',
    title: 'Span',
    type: null,
    jsonType: 'object',
};
var MARKS_FIELD = {
    name: 'marks',
    title: 'Marks',
    type: 'array',
    of: [{ type: 'string' }],
};
var TEXT_FIELD = {
    name: 'text',
    title: 'Text',
    type: 'string',
};
var DEFAULT_OPTIONS = {};
var SpanType = {
    get: function () {
        return SPAN_CORE;
    },
    extend: function (subTypeDef, extendMember) {
        var options = __assign({}, (subTypeDef.options || DEFAULT_OPTIONS));
        var _a = subTypeDef.annotations, annotations = _a === void 0 ? [] : _a, _b = subTypeDef.marks, marks = _b === void 0 ? [] : _b;
        // NOTE: if you update this please also update `SpanSchemaType` in`@sanity/types`
        var fields = [MARKS_FIELD, TEXT_FIELD];
        var parsed = Object.assign(pick(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
            type: SPAN_CORE,
            options: options,
        });
        lazyGetter(parsed, 'fields', function () {
            return fields.map(function (fieldDef) {
                var name = fieldDef.name, type = __rest(fieldDef, ["name"]);
                return {
                    name: name,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'annotations', function () { return annotations.map(extendMember); });
        lazyGetter(parsed, 'marks', function () { return marks.map(extendMember); });
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get: function () {
                    return parent;
                },
                extend: function (extensionDef) {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "span"');
                    }
                    var current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var types = {
  __proto__: null,
  any: AnyType,
  string: StringType,
  text: TextType,
  datetime: DateTimeType,
  date: DateType,
  boolean: BooleanType,
  url: UrlType,
  email: EmailType,
  number: NumberType,
  reference: ReferenceType,
  crossDatasetReference: CrossDatasetReferenceType,
  image: ImageType,
  file: FileType,
  object: ObjectType,
  document: DocumentType,
  array: ArrayType,
  block: BlockType,
  span: SpanType
};

function compileRegistry(schemaDef) {
    var registry = Object.assign(Object.create(null), types);
    var defsByName = schemaDef.types.reduce(function (acc, def) {
        if (acc[def.name]) {
            throw new Error("Duplicate type name added to schema: ".concat(def.name));
        }
        acc[def.name] = def;
        return acc;
    }, {});
    schemaDef.types.forEach(add);
    return registry;
    function ensure(typeName) {
        if (!registry[typeName]) {
            if (!defsByName[typeName]) {
                throw new Error("Unknown type: ".concat(typeName));
            }
            add(defsByName[typeName]);
        }
    }
    function extendMember(memberDef) {
        ensure(memberDef.type);
        return registry[memberDef.type].extend(memberDef, extendMember).get();
    }
    function add(typeDef) {
        ensure(typeDef.type);
        if (registry[typeDef.name]) {
            return;
        }
        registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
    }
}
/**
 * @beta
 */
var Schema = /** @class */ (function () {
    function Schema(schemaDef) {
        this._original = schemaDef;
        this._registry = compileRegistry(schemaDef);
    }
    Schema.compile = function (schemaDef) {
        return new Schema(schemaDef);
    };
    Object.defineProperty(Schema.prototype, "name", {
        get: function () {
            return this._original.name;
        },
        enumerable: false,
        configurable: true
    });
    Schema.prototype.get = function (name) {
        return this._registry[name] && this._registry[name].get();
    };
    Schema.prototype.has = function (name) {
        return name in this._registry;
    };
    Schema.prototype.getTypeNames = function () {
        return Object.keys(this._registry);
    };
    return Schema;
}());

export { Schema as default };
//# sourceMappingURL=index.js.map
