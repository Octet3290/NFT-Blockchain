import type { ArraySchemaType, MarkDefinition } from '@sanity/types';
import type { DeserializerRule, HtmlDeserializerOptions, PlaceholderAnnotation, PlaceholderDecorator, TypedObject } from '../types';
/**
 * HTML Deserializer
 *
 */
export default class HtmlDeserializer {
    blockContentType: ArraySchemaType;
    rules: DeserializerRule[];
    parseHtml: (html: string) => HTMLElement;
    _markDefs: MarkDefinition[];
    /**
     * Create a new serializer respecting a Sanity block content type's schema
     *
     * @param blockContentType - Schema type for array containing _at least_ a block child type
     * @param options - Options for the deserialization process
     */
    constructor(blockContentType: ArraySchemaType, options?: HtmlDeserializerOptions);
    /**
     * Deserialize HTML.
     *
     * @param html - The HTML to deserialize, as a string
     * @returns Array of blocks - either portable text blocks or other allowed blocks
     */
    deserialize: (html: string) => TypedObject[];
    /**
     * Deserialize an array of DOM elements.
     *
     * @param elements - Array of DOM elements to deserialize
     * @returns
     */
    deserializeElements: (elements?: Node[]) => TypedObject[];
    /**
     * Deserialize a DOM element
     *
     * @param element - Deserialize a DOM element
     * @returns
     */
    deserializeElement: (element: Node) => TypedObject | TypedObject[];
    /**
     * Deserialize a `__decorator` type
     * (an internal made up type to process decorators exclusively)
     *
     * @param decorator -
     * @returns array of ...
     */
    deserializeDecorator: (decorator: PlaceholderDecorator) => TypedObject[];
    /**
     * Deserialize a `__annotation` object.
     * (an internal made up type to process annotations exclusively)
     *
     * @param annotation -
     * @returns Array of...
     */
    deserializeAnnotation: (annotation: PlaceholderAnnotation) => TypedObject[];
}
//# sourceMappingURL=index.d.ts.map