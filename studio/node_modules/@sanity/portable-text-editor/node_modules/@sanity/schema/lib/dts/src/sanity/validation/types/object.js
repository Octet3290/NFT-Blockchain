var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { isPlainObject } from 'lodash';
import { error, HELP_IDS, warning } from '../createValidationResult';
import inspect from '../../inspect';
import { validateInputComponent } from '../utils/validateInputComponent';
var VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
var CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
    if (typeof name !== 'string') {
        return [
            error("Field names must be strings. Saw \"".concat(inspect(name), "\""), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (name.startsWith('_')) {
        return [
            error("Invalid field name \"".concat(name, "\". Field names cannot start with underscores \"_\" as it's reserved for system fields."), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!VALID_FIELD_RE.test(name)) {
        return [
            error("Invalid field name: \"".concat(name, "\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ").concat(String(VALID_FIELD_RE), ")."), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!CONVENTIONAL_FIELD_RE.test(name)) {
        return [
            warning('Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +
                ' It may be wise to keep special characters out of field names for easier access later on.'),
            HELP_IDS.OBJECT_FIELD_NAME_INVALID,
        ];
    }
    return [];
}
export function validateField(field, _visitorContext) {
    if (!isPlainObject(field)) {
        return [
            error("Incorrect type for field definition - should be an object, saw ".concat(inspect(field)), HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE),
        ];
    }
    var problems = [];
    problems.push.apply(problems, __spreadArray([], __read(('name' in field
        ? validateFieldName(field.name)
        : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)])), false));
    problems.push.apply(problems, __spreadArray([], __read(validateInputComponent(field)), false));
    return problems;
}
function getDuplicateFields(array) {
    var dupes = {};
    array.forEach(function (field) {
        if (!dupes[field.name]) {
            dupes[field.name] = [];
        }
        dupes[field.name].push(field);
    });
    return Object.keys(dupes)
        .map(function (fieldName) { return (dupes[fieldName].length > 1 ? dupes[fieldName] : null); })
        .filter(Boolean);
}
export function validateFields(fields, options) {
    if (options === void 0) { options = { allowEmpty: false }; }
    var problems = [];
    var fieldsIsArray = Array.isArray(fields);
    if (!fieldsIsArray) {
        return [
            error("The \"fields\" property must be an array of fields. Instead saw \"".concat(typeof fields, "\""), HELP_IDS.OBJECT_FIELDS_INVALID),
        ];
    }
    var fieldsWithNames = fields.filter(function (field) { return typeof field.name === 'string'; });
    getDuplicateFields(fieldsWithNames).forEach(function (dupes) {
        problems.push(error("Found ".concat(dupes.length, " fields with name \"").concat(dupes[0].name, "\" in object"), HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
    });
    if (fields.length === 0 && !options.allowEmpty) {
        problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID));
    }
    return problems;
}
export function validatePreview(preview) {
    if (!isPlainObject(preview)) {
        return [error("The \"preview\" property must be an object, instead saw \"".concat(typeof preview, "\""))];
    }
    if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {
        return [
            error("The \"preview.prepare\" property must be a function, instead saw \"".concat(typeof preview.prepare, "\"")),
        ];
    }
    if (!preview.select) {
        return [];
    }
    if (!isPlainObject(preview.select)) {
        return [
            error("The \"preview.select\" property must be an object, instead saw \"".concat(typeof preview.prepare, "\"")),
        ];
    }
    return Object.keys(preview.select).reduce(function (errs, key) {
        return typeof preview.select[key] === 'string'
            ? errs
            : errs.concat(error("The key \"".concat(key, "\" of \"preview.select\" must be a string, instead saw \"").concat(typeof preview
                .select[key], "\"")));
    }, []);
}
export default (function (typeDef, visitorContext) {
    var problems = validateFields(typeDef.fields);
    var preview = typeDef.preview;
    if (preview) {
        var previewErrors = validatePreview(typeDef.preview);
        problems = problems.concat(previewErrors);
        preview = previewErrors.some(function (err) { return err.severity === 'error'; }) ? {} : preview;
    }
    if (typeDef.type !== 'document' &&
        typeDef.type !== 'object' &&
        typeof typeDef.initialValue !== 'undefined') {
        problems.push(error("The \"initialValue\" property is currently only supported for document & object types."));
    }
    return __assign(__assign({}, typeDef), { preview: preview, fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map(function (field, index) {
            var name = field.name, fieldTypeDef = __rest(field, ["name"]);
            var _a = visitorContext.visit(fieldTypeDef, index), _problems = _a._problems, fieldType = __rest(_a, ["_problems"]);
            return __assign(__assign({ name: name }, fieldType), { _problems: validateField(field, visitorContext).concat(_problems || []) });
        }), _problems: problems });
});
//# sourceMappingURL=object.js.map