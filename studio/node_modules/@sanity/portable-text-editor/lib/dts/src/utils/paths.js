var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { isEqual } from 'lodash';
import { Editor, Element } from 'slate';
import { isKeySegment } from '@sanity/types';
export function createKeyedPath(point, value, portableTextFeatures) {
    var blockPath = [point.path[0]];
    if (!value) {
        return null;
    }
    var block = value[blockPath[0]];
    if (!block) {
        return null;
    }
    var keyedBlockPath = [{ _key: block._key }];
    if (block._type !== portableTextFeatures.types.block.name) {
        return keyedBlockPath;
    }
    var keyedChildPath;
    var childPath = point.path.slice(0, 2);
    var child = block.children[childPath[1]];
    if (child) {
        keyedChildPath = ['children', { _key: child._key }];
    }
    return (keyedChildPath ? __spreadArray(__spreadArray([], __read(keyedBlockPath), false), __read(keyedChildPath), false) : keyedBlockPath);
}
export function createArrayedPath(point, editor) {
    if (!editor) {
        return [];
    }
    var _a = __read(Array.from(Editor.nodes(editor, {
        at: [],
        match: function (n) { return isKeySegment(point.path[0]) && n._key === point.path[0]._key; },
    }))[0] || [undefined, undefined], 2), block = _a[0], blockPath = _a[1];
    if (!block || !Element.isElement(block)) {
        return [];
    }
    if (editor.isVoid(block)) {
        return blockPath;
    }
    var childPath = [point.path[2]];
    var childIndex = block.children.findIndex(function (child) { return isEqual([{ _key: child._key }], childPath); });
    if (childIndex >= 0 && block.children[childIndex]) {
        var child = block.children[childIndex];
        if (Element.isElement(child) && editor.isVoid(child)) {
            return blockPath.concat(childIndex).concat(0);
        }
        return blockPath.concat(childIndex);
    }
    return blockPath;
}
//# sourceMappingURL=paths.js.map