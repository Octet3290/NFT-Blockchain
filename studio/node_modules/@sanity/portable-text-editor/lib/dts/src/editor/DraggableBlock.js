var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import React, { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import { Transforms, Path, Editor } from 'slate';
import { ReactEditor, useSlateStatic } from '@sanity/slate-react';
import { debugWithName } from '../utils/debug';
import { IS_DRAGGING_ELEMENT_TARGET, IS_DRAGGING_BLOCK_ELEMENT, IS_DRAGGING, IS_DRAGGING_BLOCK_TARGET_POSITION, } from '../utils/weakMaps';
var debug = debugWithName('components:DraggableBlock');
var debugRenders = false;
export var DraggableBlock = function (_a) {
    var children = _a.children, element = _a.element, readOnly = _a.readOnly, blockRef = _a.blockRef;
    var editor = useSlateStatic();
    var dragGhostRef = useRef();
    var _b = __read(useState(false), 2), isDragOver = _b[0], setIsDragOver = _b[1];
    var isVoid = useMemo(function () { return Editor.isVoid(editor, element); }, [editor, element]);
    var isInline = useMemo(function () { return Editor.isInline(editor, element); }, [editor, element]);
    var _c = __read(useState(null), 2), blockElement = _c[0], setBlockElement = _c[1];
    useEffect(function () { return setBlockElement(blockRef ? blockRef.current : ReactEditor.toDOMNode(editor, element)); }, [editor, element, blockRef]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragOver = useCallback(function (event) {
        var isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
        // debug('Drag over', blockElement)
        if (!isMyDragOver || !blockElement) {
            return;
        }
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
        var elementRect = blockElement.getBoundingClientRect();
        var offset = elementRect.top;
        var height = elementRect.height;
        var Y = event.pageY;
        var loc = Math.abs(offset - Y);
        var position = 'bottom';
        if (element === editor.children[0]) {
            position = 'top';
        }
        else if (loc < height / 2) {
            position = 'top';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        else {
            position = 'bottom';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        if (isMyDragOver === element) {
            event.dataTransfer.dropEffect = 'none';
            return;
        }
        setIsDragOver(true);
    }, [blockElement, editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragLeave = useCallback(function () {
        setIsDragOver(false);
    }, []);
    // Note: this is called for the dragging block
    var handleDragEnd = useCallback(function (event) {
        var targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
        if (targetBlock) {
            IS_DRAGGING.set(editor, false);
            event.preventDefault();
            event.stopPropagation();
            IS_DRAGGING_ELEMENT_TARGET.delete(editor);
            if (dragGhostRef.current) {
                debug('Removing drag ghost');
                document.body.removeChild(dragGhostRef.current);
            }
            var dragPosition_1 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
            IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
            var targetPath = ReactEditor.findPath(editor, targetBlock);
            var myPath = ReactEditor.findPath(editor, element);
            var isBefore = Path.isBefore(myPath, targetPath);
            if (dragPosition_1 === 'bottom' && !isBefore) {
                // If it is already at the bottom, don't do anything.
                if (targetPath[0] >= editor.children.length - 1) {
                    debug('target is already at the bottom, not moving');
                    return;
                }
                var originalPath = targetPath;
                targetPath = Path.next(targetPath);
                debug("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
            }
            if (dragPosition_1 === 'top' && isBefore && targetPath[0] !== editor.children.length - 1) {
                var originalPath = targetPath;
                targetPath = Path.previous(targetPath);
                debug("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
            }
            if (Path.equals(targetPath, myPath)) {
                event.preventDefault();
                debug('targetPath and myPath is the same, not moving');
                return;
            }
            debug("Moving element ".concat(element._key, " from path ").concat(JSON.stringify(myPath), " to ").concat(JSON.stringify(targetPath), " (").concat(dragPosition_1, ")"));
            Transforms.moveNodes(editor, { at: myPath, to: targetPath });
            editor.onChange();
            return;
        }
        debug('No target element, not doing anything');
    }, [editor, element]);
    // Note: this is called not for the dragging block, but for the drop target
    var handleDrop = useCallback(function (event) {
        if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
            debug('On drop (prevented)', element);
            event.preventDefault();
            event.stopPropagation();
            setIsDragOver(false);
        }
    }, [editor, element]);
    // Note: this is called for the dragging block
    var handleDrag = useCallback(function (event) {
        if (!isVoid) {
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            return;
        }
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
        event.stopPropagation(); // Stop propagation so that leafs don't get this and take focus/selection!
        var target = event.target;
        if (target instanceof HTMLElement) {
            target.style.opacity = '1';
        }
    }, [editor, element, isVoid]);
    // Note: this is called for the dragging block
    var handleDragStart = useCallback(function (event) {
        if (!isVoid || isInline) {
            debug('Not dragging block');
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            IS_DRAGGING.set(editor, false);
            return;
        }
        debug('Drag start');
        IS_DRAGGING.set(editor, true);
        if (event.dataTransfer) {
            event.dataTransfer.setData('application/portable-text', 'something');
            event.dataTransfer.effectAllowed = 'move';
        }
        // Clone blockElement so that it will not be visually clipped by scroll-containers etc.
        // The application that uses the portable-text-editor may indicate the element used as
        // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.
        if (blockElement && blockElement instanceof HTMLElement) {
            var dragGhost = blockElement.cloneNode(true);
            var customGhost = dragGhost.querySelector('[data-pt-drag-ghost-element]');
            if (customGhost) {
                dragGhost = customGhost;
            }
            // Set the `data-dragged` attribute so the consumer can style the element while itâ€™s dragged
            dragGhost.setAttribute('data-dragged', '');
            if (document.body) {
                dragGhostRef.current = dragGhost;
                dragGhost.style.position = 'absolute';
                dragGhost.style.left = '-99999px';
                dragGhost.style.boxSizing = 'border-box';
                document.body.appendChild(dragGhost);
                var rect = blockElement.getBoundingClientRect();
                var x = event.clientX - rect.left;
                var y = event.clientY - rect.top;
                dragGhost.style.width = "".concat(rect.width, "px");
                dragGhost.style.height = "".concat(rect.height, "px");
                event.dataTransfer.setDragImage(dragGhost, x, y);
            }
        }
        handleDrag(event);
    }, [blockElement, editor, handleDrag, isInline, isVoid]);
    var isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    var isDraggingOverLastBlock = isDragOver &&
        editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    var dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
    var isDraggingOverTop = isDraggingOverFirstBlock ||
        (isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === 'top');
    var isDraggingOverBottom = isDraggingOverLastBlock ||
        (isDragOver &&
            !isDraggingOverFirstBlock &&
            !isDraggingOverLastBlock &&
            dragPosition === 'bottom');
    var dropIndicator = useMemo(function () { return (React.createElement("div", { className: "pt-drop-indicator", style: {
            position: 'absolute',
            width: '100%',
            height: 1,
            borderBottom: '1px solid currentColor',
            zIndex: 5,
        } })); }, []);
    if (readOnly) {
        return React.createElement(React.Fragment, null, children);
    }
    if (debugRenders) {
        debug('render');
    }
    return (React.createElement("div", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop },
        isDraggingOverTop && dropIndicator,
        children,
        isDraggingOverBottom && dropIndicator));
};
//# sourceMappingURL=DraggableBlock.js.map