var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/* eslint-disable max-statements */
import { Transforms, Element, Text } from 'slate';
import * as DMP from 'diff-match-patch';
import { isEqual } from 'lodash';
import { applyAll } from '../patch/applyPatch';
import { toSlateValue } from './values';
import { debugWithName } from './debug';
import { KEY_TO_SLATE_ELEMENT } from './weakMaps';
var debug = debugWithName('operationToPatches');
// eslint-disable-next-line new-cap
var dmp = new DMP.diff_match_patch();
export function createPatchToOperations(portableTextFeatures, keyGenerator) {
    function diffMatchPatch(editor, patch) {
        var blockKey = findLastKey([patch.path[0]]);
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return blockKey ? node._key === blockKey : indx === patch.path[0];
        });
        var block = editor.children[blockIndex];
        var parsed = dmp.patch_fromText(patch.value)[0];
        if (parsed && editor.isTextBlock(block)) {
            var childKey_1 = findLastKey([patch.path[2]]);
            var childIndex = block.children.findIndex(function (node, indx) {
                return childKey_1 ? node._key === childKey_1 : indx === patch.path[0];
            });
            var slatePath = [blockIndex, childIndex];
            var distance = parsed.length2 - parsed.length1;
            var point = {
                path: slatePath,
                offset: distance >= 0
                    ? (parsed.start1 || 0) + parsed.diffs[0][1].length
                    : (parsed.start2 || 0) + parsed.length2 - distance,
            };
            debug("DiffMatchPatch (".concat(distance < 0 ? 'remove' : 'insert', ") at ").concat(JSON.stringify(slatePath), "}: "), JSON.stringify(point, null, 2), JSON.stringify(parsed, null, 2));
            debugState(editor, 'before');
            var text = void 0;
            if (parsed.diffs[1]) {
                text = parsed.diffs[1][1];
            }
            else {
                text = parsed.diffs[0][1];
            }
            debug("Text: '".concat(text, "'"));
            if (distance >= 0) {
                editor.apply({
                    type: 'insert_text',
                    path: point.path,
                    offset: point.offset,
                    text: text,
                });
            }
            else {
                editor.apply({
                    type: 'remove_text',
                    path: point.path,
                    offset: point.offset - text.length,
                    text: text,
                });
            }
            debugState(editor, 'after');
            return true;
        }
        return false;
    }
    function insertPatch(editor, patch) {
        // Insert blocks
        if (patch.path.length === 1) {
            var items_1 = patch.items, position_1 = patch.position;
            var blocksToInsert = toSlateValue(items_1, { portableTextFeatures: portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
            var posKey_1 = findLastKey(patch.path);
            var index = editor.children.findIndex(function (node, indx) {
                return posKey_1 ? node._key === posKey_1 : indx === patch.path[0];
            });
            var normalizedIdx_1 = position_1 === 'after' ? index + 1 : index;
            debug("Inserting blocks at path [".concat(normalizedIdx_1, "]"));
            debugState(editor, 'before');
            Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx_1] });
            debugState(editor, 'after');
            return true;
        }
        var items = patch.items, position = patch.position;
        var posKey = findLastKey(patch.path);
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return posKey ? node._key === posKey : indx === patch.path[0];
        });
        // Insert children
        var block = editor.children && blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var childIndex = block &&
            block.children.findIndex(function (node, indx) {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        var childrenToInsert = block &&
            toSlateValue([__assign(__assign({}, block), { children: items })], { portableTextFeatures: portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
        var normalizedIdx = position === 'after' ? childIndex + 1 : childIndex;
        var targetPath = [blockIndex, normalizedIdx];
        debug("Inserting children at path ".concat(targetPath));
        debugState(editor, 'before');
        if (childrenToInsert && Element.isElement(childrenToInsert[0])) {
            Transforms.insertNodes(editor, childrenToInsert[0].children, { at: targetPath });
        }
        debugState(editor, 'after');
        return true;
    }
    function setPatch(editor, patch) {
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        debug('blockIndex', blockIndex);
        var block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var childIndex = block &&
            block.children.findIndex(function (node, indx) {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        var value = patch.value;
        var targetPath = childIndex > -1 ? [blockIndex, childIndex] : [blockIndex];
        if (typeof patch.path[3] === 'string') {
            value = {};
            value[patch.path[3]] = patch.value;
        }
        var isTextBlock = portableTextFeatures.types.block.name === (block === null || block === void 0 ? void 0 : block._type);
        if (isTextBlock) {
            debug("Setting nodes at ".concat(JSON.stringify(patch.path), " - ").concat(JSON.stringify(targetPath)));
            debug('Value to set', JSON.stringify(value, null, 2));
            debugState(editor, 'before');
            if (targetPath.length === 1) {
                debug('Setting block property');
                var _a = value, children = _a.children, nextRest = __rest(_a, ["children"]);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var _b = block || { children: undefined }, prevChildren = _b.children, prevRest = __rest(_b, ["children"]);
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: __assign({}, prevRest),
                    newProperties: nextRest,
                });
                if (block && Element.isElement(block)) {
                    block.children.forEach(function (c, cIndex) {
                        editor.apply({
                            type: 'remove_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
                if (Array.isArray(children)) {
                    children.forEach(function (c, cIndex) {
                        editor.apply({
                            type: 'insert_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
            }
            else if (Text.isText(value)) {
                debug('Setting text property');
                var prevSel = editor.selection && __assign({}, editor.selection);
                editor.apply({
                    type: 'remove_text',
                    path: targetPath,
                    offset: 0,
                    text: block === null || block === void 0 ? void 0 : block.children[childIndex].text,
                });
                editor.apply({
                    type: 'insert_text',
                    path: targetPath,
                    offset: 0,
                    text: value.text,
                });
                var onSamePath = prevSel && isEqual(prevSel.focus.path, targetPath);
                // const onSameText =
                //   editor.selection &&
                //   editor.selection.focus.path[0] === blockIndex &&
                //   patch.path[3] === 'text'
                if (onSamePath) {
                    debug('On same path, restoring previous selection');
                    Transforms.select(editor, prevSel);
                }
                //  else if (onSameText) {
                //   debug('Adjusting for inserted text')
                //   const newOffset = typeof patch.value === 'string' ? patch.value.length : 0
                //   const point = {path: targetPath, offset: newOffset}
                //   Transforms.select(editor, {focus: point, anchor: point})
                // }
            }
            else {
                debug('Setting non-text property');
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: {},
                    newProperties: value,
                });
            }
            debugState(editor, 'after');
            return true;
        }
        // If this is a object block, just set the whole block
        else if (!isTextBlock && block) {
            var newVal = applyAll([block.value], [patch])[0];
            Transforms.setNodes(editor, __assign(__assign({}, block), { value: newVal }), { at: [blockIndex] });
            return true;
        }
        return false;
    }
    function unsetPatch(editor, patch, previousPatch) {
        var _a;
        // Value
        if (patch.path.length === 0) {
            debug("Removing everything");
            debugState(editor, 'before');
            Transforms.deselect(editor);
            editor.children.forEach(function (c, i) {
                Transforms.removeNodes(editor, { at: [i] });
            });
            debugState(editor, 'after');
            return true;
        }
        // Single blocks
        if (patch.path.length === 1) {
            var lastKey_1 = findLastKey(patch.path);
            var index = editor.children.findIndex(function (node, indx) {
                return lastKey_1 ? node._key === lastKey_1 : indx === patch.path[0];
            });
            debug("Removing block at path [".concat(index, "]"));
            debugState(editor, 'before');
            if (editor.selection &&
                editor.selection.focus.path[0] === index &&
                editor.children[index - 1]) {
                var point = { path: [Math.max(editor.selection.focus.path[0] - 1, 0)], offset: 0 };
                Transforms.select(editor, { focus: point, anchor: point });
                Transforms.move(editor, { unit: 'line' });
            }
            Transforms.removeNodes(editor, { at: [index] });
            debugState(editor, 'after');
            return true;
        }
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        var block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var isTextBlock = portableTextFeatures.types.block.name === (block === null || block === void 0 ? void 0 : block._type);
        // Unset on text block children
        if (isTextBlock && patch.path[1] === 'children' && patch.path.length === 3) {
            var childIndex = block &&
                block.children.findIndex(function (node, indx) {
                    return isKeyedSegment(patch.path[2])
                        ? node._key === patch.path[2]._key
                        : indx === patch.path[2];
                });
            var targetPath = [blockIndex, childIndex];
            var prevSel = editor.selection && __assign({}, editor.selection);
            var onSamePath = isEqual((_a = editor.selection) === null || _a === void 0 ? void 0 : _a.focus.path, targetPath);
            debug("Removing child at path ".concat(JSON.stringify(targetPath)));
            debugState(editor, 'before');
            if (prevSel && onSamePath && editor.isTextBlock(block)) {
                var needToAdjust = childIndex >= prevSel.focus.path[1];
                if (needToAdjust) {
                    var isMergeUnset = (previousPatch === null || previousPatch === void 0 ? void 0 : previousPatch.type) === 'set' &&
                        previousPatch.path[3] === 'text' &&
                        typeof previousPatch.value === 'string' &&
                        isEqual(previousPatch.value.slice(-block.children[childIndex].text.length), block.children[childIndex].text);
                    if (isMergeUnset) {
                        debug('Adjusting selection for merging of nodes');
                        prevSel.focus = __assign({}, prevSel.focus);
                        prevSel.focus.path = [targetPath[0], Math.max(targetPath[1] - 1, 0)];
                        prevSel.focus.offset =
                            block.children[Math.max(childIndex - 1, 0)].text.length -
                                block.children[childIndex].text.length +
                                prevSel.focus.offset;
                        prevSel.anchor = prevSel.focus;
                        Transforms.select(editor, prevSel);
                        Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
                        debugState(editor, 'after');
                        return true;
                    }
                }
            }
            Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
            debugState(editor, 'after');
            return true;
        }
        // Inside block objects - patch block and set it again
        if (!isTextBlock && block) {
            var newBlock = applyAll([block], [patch])[0];
            Transforms.setNodes(editor, newBlock, { at: [blockIndex] });
            return true;
        }
        return false;
    }
    var previousPatch;
    return function (editor, patch) {
        var changed = false;
        debug('\n\nNEW PATCH =============================================================');
        debug(JSON.stringify(patch, null, 2));
        try {
            switch (patch.type) {
                case 'insert':
                    changed = insertPatch(editor, patch);
                    break;
                case 'unset':
                    changed = unsetPatch(editor, patch, previousPatch);
                    break;
                case 'set':
                    changed = setPatch(editor, patch);
                    break;
                case 'diffMatchPatch':
                    changed = diffMatchPatch(editor, patch);
                    break;
                default:
                    debug('Unhandled patch', patch.type);
            }
        }
        catch (err) {
            console.error(err);
        }
        previousPatch = patch;
        return changed;
    };
}
function isKeyedSegment(segment) {
    return typeof segment === 'object' && '_key' in segment;
}
// Helper function to find the last part of a patch path that has a known key
function findLastKey(path) {
    var key = null;
    path
        .concat('')
        .reverse()
        .forEach(function (part) {
        if (isKeyedSegment(part)) {
            key = part._key;
        }
    });
    return key;
}
function debugState(editor, stateName) {
    debug("Children ".concat(stateName, ":"), JSON.stringify(editor.children, null, 2));
    debug("Selection ".concat(stateName, ": "), JSON.stringify(editor.selection, null, 2));
}
//# sourceMappingURL=patchToOperations.js.map