var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { Editor, } from 'slate';
import { debounce } from 'lodash';
import { insert, setIfMissing, unset } from '../../patch/PatchEvent';
import { fromSlateValue, isEqualToEmptyEditor } from '../../utils/values';
import { debugWithName } from '../../utils/debug';
import { PATCHING, isPatching, withoutPatching } from '../../utils/withoutPatching';
import { KEY_TO_VALUE_ELEMENT } from '../../utils/weakMaps';
import { createPatchToOperations } from '../../utils/patchToOperations';
import { keyGenerator } from '../..';
import { withPreserveKeys } from '../../utils/withPreserveKeys';
import { withoutSaving } from './createWithUndoRedo';
var debug = debugWithName('plugin:withPatches');
export function createWithPatches(_a) {
    var patchFunctions = _a.patchFunctions, change$ = _a.change$, portableTextFeatures = _a.portableTextFeatures, syncValue = _a.syncValue, incomingPatches$ = _a.incomingPatches$;
    // The previous editor children are needed to figure out the _key of deleted nodes
    // The editor.children would no longer contain that information if the node is already deleted.
    var previousChildren;
    var patchToOperations = createPatchToOperations(portableTextFeatures, keyGenerator);
    var patchSubscription;
    var cleanupFn = function () {
        if (patchSubscription) {
            debug('Unsubscribing to patches');
            patchSubscription.unsubscribe();
        }
    };
    return [
        function withPatches(editor) {
            PATCHING.set(editor, true);
            previousChildren = __spreadArray([], __read(editor.children), false);
            // Sync the with props.value in PortableTextEditor after we have processed batches of incoming patches.
            // This is only for consistency checking against the props.value, so it can be debounced without problems.
            var syncValueAfterIncomingPatches = debounce(function () { return syncValue(); }, 100, {
                trailing: true,
                leading: false,
            });
            // Subscribe and deal with incoming patches
            if (incomingPatches$) {
                debug('Subscribing to patches');
                patchSubscription = incomingPatches$.subscribe(function (_a) {
                    var patches = _a.patches, snapshot = _a.snapshot;
                    debug('Incoming patches', patches);
                    var remotePatches = patches.filter(function (p) { return p.origin !== 'local'; });
                    if (remotePatches.length !== 0) {
                        Editor.withoutNormalizing(editor, function () {
                            remotePatches.forEach(function (patch) {
                                debug("Handling remote patch ".concat(JSON.stringify(patch)));
                                withoutPatching(editor, function () {
                                    withoutSaving(editor, function () {
                                        withPreserveKeys(editor, function () {
                                            try {
                                                patchToOperations(editor, patch, patches, snapshot);
                                            }
                                            catch (err) {
                                                debug('Got error trying to create operations from patch');
                                                console.error(err);
                                            }
                                        });
                                    });
                                });
                            });
                        });
                    }
                    if (patches.length > 0) {
                        syncValueAfterIncomingPatches();
                    }
                });
            }
            var apply = editor.apply;
            editor.apply = function (operation) {
                if (editor.readOnly) {
                    apply(operation);
                    return editor;
                }
                var patches = [];
                // Update previous children here before we apply
                previousChildren = editor.children;
                var editorWasEmpty = isEqualToEmptyEditor(previousChildren, portableTextFeatures);
                // Apply the operation
                apply(operation);
                var editorIsEmpty = isEqualToEmptyEditor(editor.children, portableTextFeatures);
                if (!isPatching(editor)) {
                    debug("Editor is not producing patch for operation ".concat(operation.type), operation);
                    return editor;
                }
                // Make sure the actual value is an array, and then insert the placeholder block into it
                // before we produce any other patches that will target that block.
                if (editorWasEmpty && operation.type !== 'set_selection') {
                    patches.push(setIfMissing([], []));
                    previousChildren.forEach(function (c, index) {
                        patches.push(insert(fromSlateValue([c], portableTextFeatures.types.block.name), 'before', [index]));
                    });
                }
                switch (operation.type) {
                    case 'insert_text':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.insertTextPatch(editor, operation, previousChildren)), false);
                        break;
                    case 'remove_text':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.removeTextPatch(editor, operation, previousChildren)), false);
                        break;
                    case 'remove_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.removeNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'split_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.splitNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'insert_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.insertNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'set_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.setNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'merge_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.mergeNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'move_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.moveNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'set_selection':
                    default:
                    // Do nothing
                }
                // Unset the value if the operation made the editor empty
                if (editorIsEmpty && ['remove_text', 'remove_node'].includes(operation.type)) {
                    patches = __spreadArray(__spreadArray([], __read(patches), false), [unset([])], false);
                    change$.next({
                        type: 'unset',
                        previousValue: fromSlateValue(previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
                    });
                }
                // Emit all patches
                if (patches.length > 0) {
                    patches.forEach(function (patch) {
                        change$.next({
                            type: 'patch',
                            patch: __assign(__assign({}, patch), { origin: 'local' }),
                        });
                    });
                }
                return editor;
            };
            return editor;
        },
        cleanupFn,
    ];
}
//# sourceMappingURL=createWithPatches.js.map