"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferencedDocHeading = ReferencedDocHeading;

var _react = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _icons = require("@sanity/icons");

var _PaneHeader = require("../pane/PaneHeader.styles");

var _settings = require("../../settings");

var _ReferencedDocTooltip = require("./ReferencedDocTooltip");

var _excluded = ["callback", "children"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ReferencedDocHeading(props) {
  var title = props.title,
      totalReferenceCount = props.totalReferenceCount;
  var documentTitleRef = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(0),
      _useState2 = _slicedToArray(_useState, 2),
      titleBoxSize = _useState2[0],
      setTitleBoxSize = _useState2[1];

  var _useDeskToolSetting = (0, _settings.useDeskToolSetting)('desk-tool', 'referenced-doc-has-confirmed-dialog', false),
      _useDeskToolSetting2 = _slicedToArray(_useDeskToolSetting, 2),
      hidePopover = _useDeskToolSetting2[0],
      setHidePopover = _useDeskToolSetting2[1];

  var handleHidePopover = (0, _react.useCallback)(() => setHidePopover(true), [setHidePopover]); // When the title container changes size (a sibling pane is opened/resized, sidebar opens),
  // a resize observer fires this event. In order to force the info popover to reposition,
  // we set the size of the title box to a state variable and use it as a key on the popover.
  // Ideally, this would automatically be handled by `@sanity/ui`.

  var handleResize = (0, _react.useCallback)(e => {
    var _e$, _e$$borderBoxSize, _e$$borderBoxSize$;

    if (!hidePopover && e !== null && e !== void 0 && (_e$ = e[0]) !== null && _e$ !== void 0 && (_e$$borderBoxSize = _e$.borderBoxSize) !== null && _e$$borderBoxSize !== void 0 && (_e$$borderBoxSize$ = _e$$borderBoxSize[0]) !== null && _e$$borderBoxSize$ !== void 0 && _e$$borderBoxSize$.inlineSize) {
      setTitleBoxSize(Math.floor(e[0].borderBoxSize[0].inlineSize));
    }
  }, [hidePopover, setTitleBoxSize]);

  if (hidePopover) {
    return /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
      paddingBottom: 3
    }, /*#__PURE__*/_react.default.createElement(_PaneHeader.TitleText, {
      tabIndex: 0,
      textOverflow: "ellipsis",
      weight: "semibold"
    }, title)), /*#__PURE__*/_react.default.createElement(_ReferencedDocTooltip.ReferencedDocTooltip, {
      totalReferenceCount: totalReferenceCount
    }));
  }

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_ui.Popover, {
    key: "popover-".concat(titleBoxSize),
    content: /*#__PURE__*/_react.default.createElement(InnerPopover, {
      onClose: handleHidePopover,
      totalReferenceCount: totalReferenceCount
    }),
    placement: "bottom-start",
    referenceElement: documentTitleRef.current,
    tone: "default",
    portal: true,
    open: true
  }), /*#__PURE__*/_react.default.createElement(ObserveElementResize, {
    callback: handleResize
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement("div", {
    ref: documentTitleRef
  }, ''), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginBottom: 3
  }, /*#__PURE__*/_react.default.createElement(_PaneHeader.TitleText, {
    tabIndex: 0,
    textOverflow: "ellipsis",
    weight: "semibold"
  }, title)), /*#__PURE__*/_react.default.createElement(_ReferencedDocTooltip.ReferencedDocTooltip, {
    totalReferenceCount: totalReferenceCount
  }))));
}

function InnerPopover(props) {
  var onClose = props.onClose,
      totalReferenceCount = props.totalReferenceCount;
  return /*#__PURE__*/_react.default.createElement(_PaneHeader.StyledBox, {
    as: "div"
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    margin: 4
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    marginBottom: 4,
    align: "center"
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 2
  }, /*#__PURE__*/_react.default.createElement(_PaneHeader.LinkCircle, null, /*#__PURE__*/_react.default.createElement(_icons.LinkIcon, {
    fontSize: "24"
  }))), /*#__PURE__*/_react.default.createElement(_ui.Heading, {
    size: 1
  }, "This is a referenced document")), /*#__PURE__*/_react.default.createElement(_ui.Text, null, "This document is referenced by ", totalReferenceCount, " other", totalReferenceCount === 1 ? ' document' : ' documents', ". Changes made here will be reflected anywhere content from this document is used.")), /*#__PURE__*/_react.default.createElement(_PaneHeader.HorizontalLine, null), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginX: 1,
    padding: 3
  }, /*#__PURE__*/_react.default.createElement(_ui.Grid, {
    columns: 2,
    gap: 3
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    as: "a",
    target: "_blank",
    mode: "ghost",
    href: "https://www.sanity.io/docs/connected-content",
    text: "Learn more"
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    onClick: onClose,
    tone: "primary",
    text: "Got it",
    autoFocus: true
  }))));
}

function ObserveElementResize(props) {
  var callback = props.callback,
      children = props.children,
      rest = _objectWithoutProperties(props, _excluded);

  var _useState3 = (0, _react.useState)(null),
      _useState4 = _slicedToArray(_useState3, 2),
      el = _useState4[0],
      setEl = _useState4[1];

  (0, _react.useEffect)(() => {
    if (!el || typeof ResizeObserver !== 'function') return undefined;
    var io = new ResizeObserver(callback);
    io.observe(el);
    return () => {
      io.unobserve(el);
      io.disconnect();
    };
  }, [el, callback]);
  return /*#__PURE__*/_react.default.createElement("div", _extends({
    ref: setEl
  }, rest), children);
}