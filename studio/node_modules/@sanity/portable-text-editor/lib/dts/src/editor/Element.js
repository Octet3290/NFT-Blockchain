var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import React, { useRef } from 'react';
import { Element as SlateElement, Editor, Range } from 'slate';
import { useSelected, useSlateStatic, ReactEditor } from '@sanity/slate-react';
import { fromSlateValue } from '../utils/values';
import { debugWithName } from '../utils/debug';
import { KEY_TO_VALUE_ELEMENT } from '../utils/weakMaps';
import TextBlock from './nodes/TextBlock';
import ObjectNode from './nodes/DefaultObject';
import { DefaultBlockObject } from './nodes/index';
import { DraggableBlock } from './DraggableBlock';
import { DraggableChild } from './DraggableChild';
var debug = debugWithName('components:Element');
var debugRenders = false;
var inlineBlockStyle = { display: 'inline-block' };
var defaultRender = function (value) {
    return React.createElement(ObjectNode, { value: value });
};
// eslint-disable-next-line max-statements
export var Element = function (_a) {
    var attributes = _a.attributes, children = _a.children, element = _a.element, portableTextFeatures = _a.portableTextFeatures, readOnly = _a.readOnly, renderBlock = _a.renderBlock, renderChild = _a.renderChild, spellCheck = _a.spellCheck;
    var editor = useSlateStatic();
    var selected = useSelected();
    var blockRef = useRef(null);
    var inlineBlockObjectRef = useRef(null);
    var focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    var className;
    if (typeof element._type !== 'string') {
        throw new Error("Expected element to have a _type property");
    }
    if (typeof element._key !== 'string') {
        throw new Error("Expected element to have a _key property");
    }
    // Test for inline objects first
    if (editor.isInline(element)) {
        var path = ReactEditor.findPath(editor, element);
        var _b = __read(Editor.node(editor, path, { depth: 1 }), 1), block_1 = _b[0];
        var type_1 = portableTextFeatures.types.inlineObjects.find(function (_type) { return _type.name === element._type; });
        if (!type_1) {
            throw new Error('Could not find type for inline block element');
        }
        if (SlateElement.isElement(block_1)) {
            var elmPath = [{ _key: block_1._key }, 'children', { _key: element._key }];
            if (debugRenders) {
                debug("Render ".concat(element._key, " (inline object)"));
            }
            return (React.createElement("span", __assign({}, attributes),
                children,
                React.createElement(DraggableChild, { element: element, readOnly: readOnly },
                    React.createElement("span", { className: "pt-inline-object", ref: inlineBlockObjectRef, key: element._key, style: inlineBlockStyle, contentEditable: false },
                        renderChild &&
                            renderChild(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], type_1, { focused: focused, selected: selected, path: elmPath }, defaultRender, inlineBlockObjectRef),
                        !renderChild &&
                            defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0])))));
        }
        throw new Error('Block not found!');
    }
    var renderAttribs = { focused: focused, selected: selected, path: [{ _key: element._key }] };
    // If not inline, it's either a block (text) or a block object (non-text)
    // NOTE: text blocks aren't draggable with DraggableBlock (yet?)
    if (element._type === portableTextFeatures.types.block.name) {
        className = "pt-block pt-text-block";
        var isListItem = 'listItem' in element;
        var hasStyle = 'style' in element;
        if (debugRenders) {
            debug("Render ".concat(element._key, " (text block)"));
        }
        if (hasStyle) {
            renderAttribs.style = element.style || 'normal';
            className = "pt-block pt-text-block pt-text-block-style-".concat(element.style);
        }
        if (isListItem) {
            renderAttribs.listItem = element.listItem;
            if (Number.isInteger(element.level)) {
                renderAttribs.level = element.level;
            }
            else {
                renderAttribs.level = 1;
            }
            className += " pt-list-item pt-list-item-".concat(renderAttribs.listItem, " pt-list-item-level-").concat(renderAttribs.level);
        }
        var textBlock_1 = (React.createElement(TextBlock, { block: element, portableTextFeatures: portableTextFeatures }, children));
        var propsOrDefaultRendered = renderBlock
            ? renderBlock(fromSlateValue([element], element._type, KEY_TO_VALUE_ELEMENT.get(editor))[0], portableTextFeatures.types.block, renderAttribs, function () { return textBlock_1; }, blockRef)
            : textBlock_1;
        return (React.createElement("div", __assign({ key: element._key }, attributes, { className: className, spellCheck: spellCheck }),
            React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
                React.createElement("div", { ref: blockRef }, propsOrDefaultRendered))));
    }
    var type = portableTextFeatures.types.blockObjects.find(function (_type) { return _type.name === element._type; });
    if (!type) {
        throw new Error("Could not find schema type for block element of _type ".concat(element._type));
    }
    if (debugRenders) {
        debug("Render ".concat(element._key, " (object block)"));
    }
    className = 'pt-block pt-object-block';
    var block = fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
    var renderedBlockFromProps = renderBlock && renderBlock(block, type, renderAttribs, defaultRender, blockRef);
    return (React.createElement("div", __assign({ key: element._key }, attributes, { className: className }),
        children,
        React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
            renderedBlockFromProps && (React.createElement("div", { ref: blockRef, contentEditable: false }, renderedBlockFromProps)),
            !renderedBlockFromProps && (React.createElement(DefaultBlockObject, { selected: selected }, defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0]))))));
};
//# sourceMappingURL=Element.js.map