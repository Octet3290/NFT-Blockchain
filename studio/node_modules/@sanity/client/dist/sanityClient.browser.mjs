var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/util/observable.js
var require_observable = __commonJS({
  "src/util/observable.js"(exports, module) {
    var { Observable } = __require("rxjs/internal/Observable");
    var { filter } = __require("rxjs/internal/operators/filter");
    var { map } = __require("rxjs/internal/operators/map");
    module.exports = {
      Observable,
      filter,
      map
    };
  }
});

// src/util/getSelection.js
var require_getSelection = __commonJS({
  "src/util/getSelection.js"(exports, module) {
    module.exports = function getSelection(sel) {
      if (typeof sel === "string" || Array.isArray(sel)) {
        return { id: sel };
      }
      if (sel && sel.query) {
        return "params" in sel ? { query: sel.query, params: sel.params } : { query: sel.query };
      }
      const selectionOpts = [
        "* Document ID (<docId>)",
        "* Array of document IDs",
        "* Object containing `query`"
      ].join("\n");
      throw new Error(`Unknown selection - must be one of:

${selectionOpts}`);
    };
  }
});

// src/validators.js
var require_validators = __commonJS({
  "src/validators.js"(exports) {
    var VALID_ASSET_TYPES = ["image", "file"];
    var VALID_INSERT_LOCATIONS = ["before", "after", "replace"];
    exports.dataset = (name) => {
      if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(name)) {
        throw new Error(
          "Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters"
        );
      }
    };
    exports.projectId = (id) => {
      if (!/^[-a-z0-9]+$/i.test(id)) {
        throw new Error("`projectId` can only contain only a-z, 0-9 and dashes");
      }
    };
    exports.validateAssetType = (type) => {
      if (VALID_ASSET_TYPES.indexOf(type) === -1) {
        throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(", ")}`);
      }
    };
    exports.validateObject = (op, val) => {
      if (val === null || typeof val !== "object" || Array.isArray(val)) {
        throw new Error(`${op}() takes an object of properties`);
      }
    };
    exports.requireDocumentId = (op, doc) => {
      if (!doc._id) {
        throw new Error(`${op}() requires that the document contains an ID ("_id" property)`);
      }
      exports.validateDocumentId(op, doc._id);
    };
    exports.validateDocumentId = (op, id) => {
      if (typeof id !== "string" || !/^[a-z0-9_.-]+$/i.test(id)) {
        throw new Error(`${op}(): "${id}" is not a valid document ID`);
      }
    };
    exports.validateInsert = (at, selector, items) => {
      const signature = "insert(at, selector, items)";
      if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
        const valid = VALID_INSERT_LOCATIONS.map((loc) => `"${loc}"`).join(", ");
        throw new Error(`${signature} takes an "at"-argument which is one of: ${valid}`);
      }
      if (typeof selector !== "string") {
        throw new Error(`${signature} takes a "selector"-argument which must be a string`);
      }
      if (!Array.isArray(items)) {
        throw new Error(`${signature} takes an "items"-argument which must be an array`);
      }
    };
    exports.hasDataset = (config) => {
      if (!config.dataset) {
        throw new Error("`dataset` must be provided to perform queries");
      }
      return config.dataset || "";
    };
    exports.requestTag = (tag) => {
      if (typeof tag !== "string" || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {
        throw new Error(
          `Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.`
        );
      }
      return tag;
    };
  }
});

// src/data/patch.js
var require_patch = __commonJS({
  "src/data/patch.js"(exports, module) {
    var assign = __require("object-assign");
    var getSelection = require_getSelection();
    var validate = require_validators();
    var validateObject = validate.validateObject;
    var validateInsert = validate.validateInsert;
    function Patch(selection, operations = {}, client = null) {
      this.selection = selection;
      this.operations = assign({}, operations);
      this.client = client;
    }
    assign(Patch.prototype, {
      clone() {
        return new Patch(this.selection, assign({}, this.operations), this.client);
      },
      set(props) {
        return this._assign("set", props);
      },
      diffMatchPatch(props) {
        validateObject("diffMatchPatch", props);
        return this._assign("diffMatchPatch", props);
      },
      unset(attrs) {
        if (!Array.isArray(attrs)) {
          throw new Error("unset(attrs) takes an array of attributes to unset, non-array given");
        }
        this.operations = assign({}, this.operations, { unset: attrs });
        return this;
      },
      setIfMissing(props) {
        return this._assign("setIfMissing", props);
      },
      replace(props) {
        validateObject("replace", props);
        return this._set("set", { $: props });
      },
      inc(props) {
        return this._assign("inc", props);
      },
      dec(props) {
        return this._assign("dec", props);
      },
      insert(at, selector, items) {
        validateInsert(at, selector, items);
        return this._assign("insert", { [at]: selector, items });
      },
      append(selector, items) {
        return this.insert("after", `${selector}[-1]`, items);
      },
      prepend(selector, items) {
        return this.insert("before", `${selector}[0]`, items);
      },
      splice(selector, start, deleteCount, items) {
        const delAll = typeof deleteCount === "undefined" || deleteCount === -1;
        const startIndex = start < 0 ? start - 1 : start;
        const delCount = delAll ? -1 : Math.max(0, start + deleteCount);
        const delRange = startIndex < 0 && delCount >= 0 ? "" : delCount;
        const rangeSelector = `${selector}[${startIndex}:${delRange}]`;
        return this.insert("replace", rangeSelector, items || []);
      },
      ifRevisionId(rev) {
        this.operations.ifRevisionID = rev;
        return this;
      },
      serialize() {
        return assign(getSelection(this.selection), this.operations);
      },
      toJSON() {
        return this.serialize();
      },
      commit(options = {}) {
        if (!this.client) {
          throw new Error(
            "No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"
          );
        }
        const returnFirst = typeof this.selection === "string";
        const opts = assign({ returnFirst, returnDocuments: true }, options);
        return this.client.mutate({ patch: this.serialize() }, opts);
      },
      reset() {
        this.operations = {};
        return this;
      },
      _set(op, props) {
        return this._assign(op, props, false);
      },
      _assign(op, props, merge = true) {
        validateObject(op, props);
        this.operations = assign({}, this.operations, {
          [op]: assign({}, merge && this.operations[op] || {}, props)
        });
        return this;
      }
    });
    module.exports = Patch;
  }
});

// src/data/transaction.js
var require_transaction = __commonJS({
  "src/data/transaction.js"(exports, module) {
    var assign = __require("object-assign");
    var validators = require_validators();
    var Patch = require_patch();
    var defaultMutateOptions = { returnDocuments: false };
    function Transaction(operations = [], client, transactionId) {
      this.trxId = transactionId;
      this.operations = operations;
      this.client = client;
    }
    assign(Transaction.prototype, {
      clone() {
        return new Transaction(this.operations.slice(0), this.client, this.trxId);
      },
      create(doc) {
        validators.validateObject("create", doc);
        return this._add({ create: doc });
      },
      createIfNotExists(doc) {
        const op = "createIfNotExists";
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add({ [op]: doc });
      },
      createOrReplace(doc) {
        const op = "createOrReplace";
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add({ [op]: doc });
      },
      delete(documentId) {
        validators.validateDocumentId("delete", documentId);
        return this._add({ delete: { id: documentId } });
      },
      patch(documentId, patchOps) {
        const isBuilder = typeof patchOps === "function";
        const isPatch = documentId instanceof Patch;
        if (isPatch) {
          return this._add({ patch: documentId.serialize() });
        }
        if (isBuilder) {
          const patch = patchOps(new Patch(documentId, {}, this.client));
          if (!(patch instanceof Patch)) {
            throw new Error("function passed to `patch()` must return the patch");
          }
          return this._add({ patch: patch.serialize() });
        }
        return this._add({ patch: assign({ id: documentId }, patchOps) });
      },
      transactionId(id) {
        if (!id) {
          return this.trxId;
        }
        this.trxId = id;
        return this;
      },
      serialize() {
        return this.operations.slice();
      },
      toJSON() {
        return this.serialize();
      },
      commit(options) {
        if (!this.client) {
          throw new Error(
            "No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"
          );
        }
        return this.client.mutate(
          this.serialize(),
          assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})
        );
      },
      reset() {
        this.operations = [];
        return this;
      },
      _add(mut) {
        this.operations.push(mut);
        return this;
      }
    });
    module.exports = Transaction;
  }
});

// src/data/encodeQueryString.js
var require_encodeQueryString = __commonJS({
  "src/data/encodeQueryString.js"(exports, module) {
    var enc = encodeURIComponent;
    module.exports = ({ query, params = {}, options = {} }) => {
      const { tag, ...opts } = options;
      const q = `query=${enc(query)}`;
      const base = tag ? `?tag=${enc(tag)}&${q}` : `?${q}`;
      const qString = Object.keys(params).reduce(
        (qs, param) => `${qs}&${enc(`$${param}`)}=${enc(JSON.stringify(params[param]))}`,
        base
      );
      return Object.keys(opts).reduce((qs, option) => {
        return options[option] ? `${qs}&${enc(option)}=${enc(options[option])}` : qs;
      }, qString);
    };
  }
});

// src/util/pick.js
var require_pick = __commonJS({
  "src/util/pick.js"(exports, module) {
    module.exports = (obj, props) => props.reduce((selection, prop) => {
      if (typeof obj[prop] === "undefined") {
        return selection;
      }
      selection[prop] = obj[prop];
      return selection;
    }, {});
  }
});

// src/util/defaults.js
var require_defaults = __commonJS({
  "src/util/defaults.js"(exports, module) {
    module.exports = (obj, defaults) => Object.keys(defaults).concat(Object.keys(obj)).reduce((target, prop) => {
      target[prop] = typeof obj[prop] === "undefined" ? defaults[prop] : obj[prop];
      return target;
    }, {});
  }
});

// src/data/listen.js
var require_listen = __commonJS({
  "src/data/listen.js"(exports, module) {
    var assign = __require("object-assign");
    var { Observable } = require_observable();
    var polyfilledEventSource = __require("@sanity/eventsource");
    var pick = require_pick();
    var defaults = require_defaults();
    var encodeQueryString = require_encodeQueryString();
    var MAX_URL_LENGTH = 16e3 - 1200;
    var EventSource = polyfilledEventSource;
    var possibleOptions = [
      "includePreviousRevision",
      "includeResult",
      "visibility",
      "effectFormat",
      "tag"
    ];
    var defaultOptions = {
      includeResult: true
    };
    module.exports = function listen(query, params, opts = {}) {
      const { url, token, withCredentials, requestTagPrefix } = this.clientConfig;
      const tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(".") : opts.tag;
      const options = { ...defaults(opts, defaultOptions), tag };
      const listenOpts = pick(options, possibleOptions);
      const qs = encodeQueryString({ query, params, options: listenOpts, tag });
      const uri = `${url}${this.getDataUrl("listen", qs)}`;
      if (uri.length > MAX_URL_LENGTH) {
        return new Observable((observer) => observer.error(new Error("Query too large for listener")));
      }
      const listenFor = options.events ? options.events : ["mutation"];
      const shouldEmitReconnect = listenFor.indexOf("reconnect") !== -1;
      const esOptions = {};
      if (token || withCredentials) {
        esOptions.withCredentials = true;
      }
      if (token) {
        esOptions.headers = {
          Authorization: `Bearer ${token}`
        };
      }
      return new Observable((observer) => {
        let es = getEventSource();
        let reconnectTimer;
        let stopped = false;
        function onError() {
          if (stopped) {
            return;
          }
          emitReconnect();
          if (stopped) {
            return;
          }
          if (es.readyState === EventSource.CLOSED) {
            unsubscribe();
            clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(open, 100);
          }
        }
        function onChannelError(err) {
          observer.error(cooerceError(err));
        }
        function onMessage(evt) {
          const event = parseEvent(evt);
          return event instanceof Error ? observer.error(event) : observer.next(event);
        }
        function onDisconnect(evt) {
          stopped = true;
          unsubscribe();
          observer.complete();
        }
        function unsubscribe() {
          es.removeEventListener("error", onError, false);
          es.removeEventListener("channelError", onChannelError, false);
          es.removeEventListener("disconnect", onDisconnect, false);
          listenFor.forEach((type) => es.removeEventListener(type, onMessage, false));
          es.close();
        }
        function emitReconnect() {
          if (shouldEmitReconnect) {
            observer.next({ type: "reconnect" });
          }
        }
        function getEventSource() {
          const evs = new EventSource(uri, esOptions);
          evs.addEventListener("error", onError, false);
          evs.addEventListener("channelError", onChannelError, false);
          evs.addEventListener("disconnect", onDisconnect, false);
          listenFor.forEach((type) => evs.addEventListener(type, onMessage, false));
          return evs;
        }
        function open() {
          es = getEventSource();
        }
        function stop() {
          stopped = true;
          unsubscribe();
        }
        return stop;
      });
    };
    function parseEvent(event) {
      try {
        const data = event.data && JSON.parse(event.data) || {};
        return assign({ type: event.type }, data);
      } catch (err) {
        return err;
      }
    }
    function cooerceError(err) {
      if (err instanceof Error) {
        return err;
      }
      const evt = parseEvent(err);
      return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
    }
    function extractErrorMessage(err) {
      if (!err.error) {
        return err.message || "Unknown listener error";
      }
      if (err.error.description) {
        return err.error.description;
      }
      return typeof err.error === "string" ? err.error : JSON.stringify(err.error, null, 2);
    }
  }
});

// src/data/dataMethods.js
var require_dataMethods = __commonJS({
  "src/data/dataMethods.js"(exports, module) {
    var assign = __require("object-assign");
    var { map, filter } = require_observable();
    var validators = require_validators();
    var getSelection = require_getSelection();
    var encodeQueryString = require_encodeQueryString();
    var Transaction = require_transaction();
    var Patch = require_patch();
    var listen = require_listen();
    var excludeFalsey = (param, defValue) => {
      const value = typeof param === "undefined" ? defValue : param;
      return param === false ? void 0 : value;
    };
    var getMutationQuery = (options = {}) => {
      return {
        dryRun: options.dryRun,
        returnIds: true,
        returnDocuments: excludeFalsey(options.returnDocuments, true),
        visibility: options.visibility || "sync",
        autoGenerateArrayKeys: options.autoGenerateArrayKeys,
        skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation
      };
    };
    var isResponse = (event) => event.type === "response";
    var getBody = (event) => event.body;
    var indexBy = (docs, attr) => docs.reduce((indexed, doc) => {
      indexed[attr(doc)] = doc;
      return indexed;
    }, /* @__PURE__ */ Object.create(null));
    var toPromise = (observable) => observable.toPromise();
    var getQuerySizeLimit = 11264;
    module.exports = {
      listen,
      getDataUrl(operation, path) {
        const config = this.clientConfig;
        const catalog = validators.hasDataset(config);
        const baseUri = `/${operation}/${catalog}`;
        const uri = path ? `${baseUri}/${path}` : baseUri;
        return `/data${uri}`.replace(/\/($|\?)/, "$1");
      },
      fetch(query, params, options = {}) {
        const mapResponse = options.filterResponse === false ? (res) => res : (res) => res.result;
        const observable = this._dataRequest("query", { query, params }, options).pipe(map(mapResponse));
        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      getDocument(id, opts = {}) {
        const options = { uri: this.getDataUrl("doc", id), json: true, tag: opts.tag };
        const observable = this._requestObservable(options).pipe(
          filter(isResponse),
          map((event) => event.body.documents && event.body.documents[0])
        );
        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      getDocuments(ids, opts = {}) {
        const options = { uri: this.getDataUrl("doc", ids.join(",")), json: true, tag: opts.tag };
        const observable = this._requestObservable(options).pipe(
          filter(isResponse),
          map((event) => {
            const indexed = indexBy(event.body.documents || [], (doc) => doc._id);
            return ids.map((id) => indexed[id] || null);
          })
        );
        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      create(doc, options) {
        return this._create(doc, "create", options);
      },
      createIfNotExists(doc, options) {
        validators.requireDocumentId("createIfNotExists", doc);
        return this._create(doc, "createIfNotExists", options);
      },
      createOrReplace(doc, options) {
        validators.requireDocumentId("createOrReplace", doc);
        return this._create(doc, "createOrReplace", options);
      },
      patch(selector, operations) {
        return new Patch(selector, operations, this);
      },
      delete(selection, options) {
        return this.dataRequest("mutate", { mutations: [{ delete: getSelection(selection) }] }, options);
      },
      mutate(mutations, options) {
        const mut = mutations instanceof Patch || mutations instanceof Transaction ? mutations.serialize() : mutations;
        const muts = Array.isArray(mut) ? mut : [mut];
        const transactionId = options && options.transactionId;
        return this.dataRequest("mutate", { mutations: muts, transactionId }, options);
      },
      transaction(operations) {
        return new Transaction(operations, this);
      },
      dataRequest(endpoint, body, options = {}) {
        const request = this._dataRequest(endpoint, body, options);
        return this.isPromiseAPI() ? toPromise(request) : request;
      },
      _dataRequest(endpoint, body, options = {}) {
        const isMutation = endpoint === "mutate";
        const isQuery = endpoint === "query";
        const strQuery = !isMutation && encodeQueryString(body);
        const useGet = !isMutation && strQuery.length < getQuerySizeLimit;
        const stringQuery = useGet ? strQuery : "";
        const returnFirst = options.returnFirst;
        const { timeout, token, tag, headers } = options;
        const uri = this.getDataUrl(endpoint, stringQuery);
        const reqOptions = {
          method: useGet ? "GET" : "POST",
          uri,
          json: true,
          body: useGet ? void 0 : body,
          query: isMutation && getMutationQuery(options),
          timeout,
          headers,
          token,
          tag,
          canUseCdn: isQuery
        };
        return this._requestObservable(reqOptions).pipe(
          filter(isResponse),
          map(getBody),
          map((res) => {
            if (!isMutation) {
              return res;
            }
            const results = res.results || [];
            if (options.returnDocuments) {
              return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);
            }
            const key = returnFirst ? "documentId" : "documentIds";
            const ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);
            return {
              transactionId: res.transactionId,
              results,
              [key]: ids
            };
          })
        );
      },
      _create(doc, op, options = {}) {
        const mutation = { [op]: doc };
        const opts = assign({ returnFirst: true, returnDocuments: true }, options);
        return this.dataRequest("mutate", { mutations: [mutation] }, opts);
      }
    };
  }
});

// src/datasets/datasetsClient.js
var require_datasetsClient = __commonJS({
  "src/datasets/datasetsClient.js"(exports, module) {
    var assign = __require("object-assign");
    var validate = require_validators();
    function DatasetsClient(client) {
      this.request = client.request.bind(client);
    }
    assign(DatasetsClient.prototype, {
      create(name, options) {
        return this._modify("PUT", name, options);
      },
      edit(name, options) {
        return this._modify("PATCH", name, options);
      },
      delete(name) {
        return this._modify("DELETE", name);
      },
      list() {
        return this.request({ uri: "/datasets" });
      },
      _modify(method, name, body) {
        validate.dataset(name);
        return this.request({ method, uri: `/datasets/${name}`, body });
      }
    });
    module.exports = DatasetsClient;
  }
});

// src/projects/projectsClient.js
var require_projectsClient = __commonJS({
  "src/projects/projectsClient.js"(exports, module) {
    var assign = __require("object-assign");
    function ProjectsClient(client) {
      this.client = client;
    }
    assign(ProjectsClient.prototype, {
      list() {
        return this.client.request({ uri: "/projects" });
      },
      getById(id) {
        return this.client.request({ uri: `/projects/${id}` });
      }
    });
    module.exports = ProjectsClient;
  }
});

// src/http/queryString.js
var require_queryString = __commonJS({
  "src/http/queryString.js"(exports, module) {
    module.exports = (params) => {
      const qs = [];
      for (const key in params) {
        if (params.hasOwnProperty(key)) {
          qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`);
        }
      }
      return qs.length > 0 ? `?${qs.join("&")}` : "";
    };
  }
});

// src/assets/assetsClient.js
var require_assetsClient = __commonJS({
  "src/assets/assetsClient.js"(exports, module) {
    var assign = __require("object-assign");
    var { map, filter } = require_observable();
    var queryString = require_queryString();
    var validators = require_validators();
    function AssetsClient(client) {
      this.client = client;
    }
    function optionsFromFile(opts, file) {
      if (typeof window === "undefined" || !(file instanceof window.File)) {
        return opts;
      }
      return assign(
        {
          filename: opts.preserveFilename === false ? void 0 : file.name,
          contentType: file.type
        },
        opts
      );
    }
    assign(AssetsClient.prototype, {
      upload(assetType, body, opts = {}) {
        validators.validateAssetType(assetType);
        let meta = opts.extract || void 0;
        if (meta && !meta.length) {
          meta = ["none"];
        }
        const dataset = validators.hasDataset(this.client.clientConfig);
        const assetEndpoint = assetType === "image" ? "images" : "files";
        const options = optionsFromFile(opts, body);
        const { tag, label, title, description, creditLine, filename, source } = options;
        const query = {
          label,
          title,
          description,
          filename,
          meta,
          creditLine
        };
        if (source) {
          query.sourceId = source.id;
          query.sourceName = source.name;
          query.sourceUrl = source.url;
        }
        const observable = this.client._requestObservable({
          tag,
          method: "POST",
          timeout: options.timeout || 0,
          uri: `/assets/${assetEndpoint}/${dataset}`,
          headers: options.contentType ? { "Content-Type": options.contentType } : {},
          query,
          body
        });
        return this.client.isPromiseAPI() ? observable.pipe(
          filter((event) => event.type === "response"),
          map((event) => event.body.document)
        ).toPromise() : observable;
      },
      delete(type, id) {
        console.warn("client.assets.delete() is deprecated, please use client.delete(<document-id>)");
        let docId = id || "";
        if (!/^(image|file)-/.test(docId)) {
          docId = `${type}-${docId}`;
        } else if (type._id) {
          docId = type._id;
        }
        validators.hasDataset(this.client.clientConfig);
        return this.client.delete(docId);
      },
      getImageUrl(ref, query) {
        const id = ref._ref || ref;
        if (typeof id !== "string") {
          throw new Error(
            "getImageUrl() needs either an object with a _ref, or a string with an asset document ID"
          );
        }
        if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
          throw new Error(
            `Unsupported asset ID "${id}". URL generation only works for auto-generated IDs.`
          );
        }
        const [, assetId, size, format] = id.split("-");
        validators.hasDataset(this.client.clientConfig);
        const { projectId, dataset } = this.client.clientConfig;
        const qs = query ? queryString(query) : "";
        return `https://cdn.sanity.io/images/${projectId}/${dataset}/${assetId}-${size}.${format}${qs}`;
      }
    });
    module.exports = AssetsClient;
  }
});

// src/users/usersClient.js
var require_usersClient = __commonJS({
  "src/users/usersClient.js"(exports, module) {
    var assign = __require("object-assign");
    function UsersClient(client) {
      this.client = client;
    }
    assign(UsersClient.prototype, {
      getById(id) {
        return this.client.request({ uri: `/users/${id}` });
      }
    });
    module.exports = UsersClient;
  }
});

// src/auth/authClient.js
var require_authClient = __commonJS({
  "src/auth/authClient.js"(exports, module) {
    var assign = __require("object-assign");
    function AuthClient(client) {
      this.client = client;
    }
    assign(AuthClient.prototype, {
      getLoginProviders() {
        return this.client.request({ uri: "/auth/providers" });
      },
      logout() {
        return this.client.request({ uri: "/auth/logout", method: "POST" });
      }
    });
    module.exports = AuthClient;
  }
});

// src/http/errors.js
var require_errors = __commonJS({
  "src/http/errors.js"(exports) {
    var makeError = __require("make-error");
    var assign = __require("object-assign");
    function ClientError(res) {
      const props = extractErrorProps(res);
      ClientError.super.call(this, props.message);
      assign(this, props);
    }
    function ServerError(res) {
      const props = extractErrorProps(res);
      ServerError.super.call(this, props.message);
      assign(this, props);
    }
    function extractErrorProps(res) {
      const body = res.body;
      const props = {
        response: res,
        statusCode: res.statusCode,
        responseBody: stringifyBody(body, res)
      };
      if (body.error && body.message) {
        props.message = `${body.error} - ${body.message}`;
        return props;
      }
      if (body.error && body.error.description) {
        props.message = body.error.description;
        props.details = body.error;
        return props;
      }
      props.message = body.error || body.message || httpErrorMessage(res);
      return props;
    }
    function httpErrorMessage(res) {
      const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : "";
      return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;
    }
    function stringifyBody(body, res) {
      const contentType = (res.headers["content-type"] || "").toLowerCase();
      const isJson = contentType.indexOf("application/json") !== -1;
      return isJson ? JSON.stringify(body, null, 2) : body;
    }
    makeError(ClientError);
    makeError(ServerError);
    exports.ClientError = ClientError;
    exports.ServerError = ServerError;
  }
});

// src/http/browserMiddleware.js
var require_browserMiddleware = __commonJS({
  "src/http/browserMiddleware.js"(exports, module) {
    module.exports = [];
  }
});

// src/http/request.js
var require_request = __commonJS({
  "src/http/request.js"(exports, module) {
    var getIt = __require("get-it");
    var assign = __require("object-assign");
    var observable = __require("get-it/lib/middleware/observable");
    var jsonRequest = __require("get-it/lib/middleware/jsonRequest");
    var jsonResponse = __require("get-it/lib/middleware/jsonResponse");
    var progress = __require("get-it/lib/middleware/progress");
    var { Observable } = require_observable();
    var { ClientError, ServerError } = require_errors();
    var httpError = {
      onResponse: (res) => {
        if (res.statusCode >= 500) {
          throw new ServerError(res);
        } else if (res.statusCode >= 400) {
          throw new ClientError(res);
        }
        return res;
      }
    };
    var printWarnings = {
      onResponse: (res) => {
        const warn = res.headers["x-sanity-warning"];
        const warnings = Array.isArray(warn) ? warn : [warn];
        warnings.filter(Boolean).forEach((msg) => console.warn(msg));
        return res;
      }
    };
    var envSpecific = require_browserMiddleware();
    var middleware = envSpecific.concat([
      printWarnings,
      jsonRequest(),
      jsonResponse(),
      progress(),
      httpError,
      observable({ implementation: Observable })
    ]);
    var request = getIt(middleware);
    function httpRequest(options, requester = request) {
      return requester(assign({ maxRedirects: 0 }, options));
    }
    httpRequest.defaultRequester = request;
    httpRequest.ClientError = ClientError;
    httpRequest.ServerError = ServerError;
    module.exports = httpRequest;
  }
});

// src/http/requestOptions.js
var require_requestOptions = __commonJS({
  "src/http/requestOptions.js"(exports, module) {
    var assign = __require("object-assign");
    var projectHeader = "X-Sanity-Project-ID";
    module.exports = (config, overrides = {}) => {
      const headers = {};
      const token = overrides.token || config.token;
      if (token) {
        headers.Authorization = `Bearer ${token}`;
      }
      if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
        headers[projectHeader] = config.projectId;
      }
      const withCredentials = Boolean(
        typeof overrides.withCredentials === "undefined" ? config.token || config.withCredentials : overrides.withCredentials
      );
      const timeout = typeof overrides.timeout === "undefined" ? config.timeout : overrides.timeout;
      return assign({}, overrides, {
        headers: assign({}, headers, overrides.headers || {}),
        timeout: typeof timeout === "undefined" ? 5 * 60 * 1e3 : timeout,
        proxy: overrides.proxy || config.proxy,
        json: true,
        withCredentials
      });
    };
  }
});

// src/generateHelpUrl.js
var require_generateHelpUrl = __commonJS({
  "src/generateHelpUrl.js"(exports, module) {
    var BASE_URL = "https://docs.sanity.io/help/";
    module.exports = function generateHelpUrl(slug) {
      return BASE_URL + slug;
    };
  }
});

// src/util/once.js
var require_once = __commonJS({
  "src/util/once.js"(exports, module) {
    module.exports = (fn) => {
      let didCall = false;
      let returnValue;
      return (...args) => {
        if (didCall) {
          return returnValue;
        }
        returnValue = fn(...args);
        didCall = true;
        return returnValue;
      };
    };
  }
});

// src/warnings.js
var require_warnings = __commonJS({
  "src/warnings.js"(exports) {
    var generateHelpUrl = require_generateHelpUrl();
    var once = require_once();
    var createWarningPrinter = (message) => once((...args) => console.warn(message.join(" "), ...args));
    exports.printCdnWarning = createWarningPrinter([
      "You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and",
      `cheaper. Think about it! For more info, see ${generateHelpUrl("js-client-cdn-configuration")}.`,
      "To hide this warning, please set the `useCdn` option to either `true` or `false` when creating",
      "the client."
    ]);
    exports.printBrowserTokenWarning = createWarningPrinter([
      "You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.",
      `See ${generateHelpUrl(
        "js-client-browser-token"
      )} for more information and how to hide this warning.`
    ]);
    exports.printNoApiVersionSpecifiedWarning = createWarningPrinter([
      "Using the Sanity client without specifying an API version is deprecated.",
      `See ${generateHelpUrl("js-client-api-version")}`
    ]);
  }
});

// src/config.js
var require_config = __commonJS({
  "src/config.js"(exports) {
    var assign = __require("object-assign");
    var generateHelpUrl = require_generateHelpUrl();
    var validate = require_validators();
    var warnings = require_warnings();
    var defaultCdnHost = "apicdn.sanity.io";
    var defaultConfig = {
      apiHost: "https://api.sanity.io",
      apiVersion: "1",
      useProjectHostname: true,
      isPromiseAPI: true
    };
    var LOCALHOSTS = ["localhost", "127.0.0.1", "0.0.0.0"];
    var isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;
    exports.defaultConfig = defaultConfig;
    exports.initConfig = (config, prevConfig) => {
      const specifiedConfig = assign({}, prevConfig, config);
      if (!specifiedConfig.apiVersion) {
        warnings.printNoApiVersionSpecifiedWarning();
      }
      const newConfig = assign({}, defaultConfig, specifiedConfig);
      const projectBased = newConfig.useProjectHostname;
      if (typeof Promise === "undefined") {
        const helpUrl = generateHelpUrl("js-client-promise-polyfill");
        throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);
      }
      if (projectBased && !newConfig.projectId) {
        throw new Error("Configuration must contain `projectId`");
      }
      const isBrowser = typeof window !== "undefined" && window.location && window.location.hostname;
      const isLocalhost = isBrowser && isLocal(window.location.hostname);
      if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
        warnings.printBrowserTokenWarning();
      } else if (typeof newConfig.useCdn === "undefined") {
        warnings.printCdnWarning();
      }
      if (projectBased) {
        validate.projectId(newConfig.projectId);
      }
      if (newConfig.dataset) {
        validate.dataset(newConfig.dataset);
      }
      if ("requestTagPrefix" in newConfig) {
        newConfig.requestTagPrefix = newConfig.requestTagPrefix ? validate.requestTag(newConfig.requestTagPrefix).replace(/\.+$/, "") : void 0;
      }
      newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, "");
      newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
      newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.withCredentials;
      exports.validateApiVersion(newConfig.apiVersion);
      const hostParts = newConfig.apiHost.split("://", 2);
      const protocol = hostParts[0];
      const host = hostParts[1];
      const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;
      if (newConfig.useProjectHostname) {
        newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`;
        newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`;
      } else {
        newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`;
        newConfig.cdnUrl = newConfig.url;
      }
      return newConfig;
    };
    exports.validateApiVersion = function validateApiVersion(apiVersion) {
      if (apiVersion === "1" || apiVersion === "X") {
        return;
      }
      const apiDate = new Date(apiVersion);
      const apiVersionValid = /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;
      if (!apiVersionValid) {
        throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`");
      }
    };
  }
});

// src/sanityClient.js
var require_sanityClient = __commonJS({
  "src/sanityClient.js"(exports, module) {
    var assign = __require("object-assign");
    var { Observable, map, filter } = require_observable();
    var Patch = require_patch();
    var Transaction = require_transaction();
    var dataMethods = require_dataMethods();
    var DatasetsClient = require_datasetsClient();
    var ProjectsClient = require_projectsClient();
    var AssetsClient = require_assetsClient();
    var UsersClient = require_usersClient();
    var AuthClient = require_authClient();
    var httpRequest = require_request();
    var getRequestOptions = require_requestOptions();
    var { defaultConfig, initConfig } = require_config();
    var validate = require_validators();
    var toPromise = (observable) => observable.toPromise();
    function SanityClient(config = defaultConfig) {
      if (!(this instanceof SanityClient)) {
        return new SanityClient(config);
      }
      this.config(config);
      this.assets = new AssetsClient(this);
      this.datasets = new DatasetsClient(this);
      this.projects = new ProjectsClient(this);
      this.users = new UsersClient(this);
      this.auth = new AuthClient(this);
      if (this.clientConfig.isPromiseAPI) {
        const observableConfig = assign({}, this.clientConfig, { isPromiseAPI: false });
        this.observable = new SanityClient(observableConfig);
      }
    }
    assign(SanityClient.prototype, dataMethods);
    assign(SanityClient.prototype, {
      clone() {
        return new SanityClient(this.config());
      },
      config(newConfig) {
        if (typeof newConfig === "undefined") {
          return assign({}, this.clientConfig);
        }
        if (this.clientConfig && this.clientConfig.allowReconfigure === false) {
          throw new Error(
            "Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client"
          );
        }
        if (this.observable) {
          const observableConfig = assign({}, newConfig, { isPromiseAPI: false });
          this.observable.config(observableConfig);
        }
        this.clientConfig = initConfig(newConfig, this.clientConfig || {});
        return this;
      },
      withConfig(newConfig) {
        return new SanityClient({ ...this.config(), ...newConfig });
      },
      getUrl(uri, useCdn = false) {
        const base = useCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
        return `${base}/${uri.replace(/^\//, "")}`;
      },
      isPromiseAPI() {
        return this.clientConfig.isPromiseAPI;
      },
      _requestObservable(options) {
        const uri = options.url || options.uri;
        const canUseCdn = typeof options.canUseCdn === "undefined" ? ["GET", "HEAD"].indexOf(options.method || "GET") >= 0 && uri.indexOf("/data/") === 0 : options.canUseCdn;
        const useCdn = this.clientConfig.useCdn && canUseCdn;
        const tag = options.tag && this.clientConfig.requestTagPrefix ? [this.clientConfig.requestTagPrefix, options.tag].join(".") : options.tag || this.clientConfig.requestTagPrefix;
        if (tag) {
          options.query = { tag: validate.requestTag(tag), ...options.query };
        }
        const reqOptions = getRequestOptions(
          this.clientConfig,
          assign({}, options, {
            url: this.getUrl(uri, useCdn)
          })
        );
        return new Observable(
          (subscriber) => httpRequest(reqOptions, this.clientConfig.requester).subscribe(subscriber)
        );
      },
      request(options) {
        const observable = this._requestObservable(options).pipe(
          filter((event) => event.type === "response"),
          map((event) => event.body)
        );
        return this.isPromiseAPI() ? toPromise(observable) : observable;
      }
    });
    SanityClient.Patch = Patch;
    SanityClient.Transaction = Transaction;
    SanityClient.ClientError = httpRequest.ClientError;
    SanityClient.ServerError = httpRequest.ServerError;
    SanityClient.requester = httpRequest.defaultRequester;
    module.exports = SanityClient;
  }
});
export default require_sanityClient();
//# sourceMappingURL=sanityClient.browser.mjs.map
