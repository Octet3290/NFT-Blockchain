var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { uniqBy } from 'lodash';
var stringFieldsSymbol = Symbol('__cachedStringFields');
var isReference = function (type) { return type.type && type.type.name === 'reference'; };
var portableTextFields = ['style', 'list'];
var isPortableTextBlock = function (type) {
    return type.name === 'block' || (type.type && isPortableTextBlock(type.type));
};
var isPortableTextArray = function (type) {
    return type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
};
function reduceType(type, reducer, acc, path, maxDepth) {
    if (path === void 0) { path = []; }
    if (maxDepth < 0) {
        return acc;
    }
    var accumulator = reducer(acc, type, path);
    if (type.jsonType === 'array' && Array.isArray(type.of)) {
        return reduceArray(type, reducer, accumulator, path, maxDepth);
    }
    if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {
        return reduceObject(type, reducer, accumulator, path, maxDepth);
    }
    return accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
    return arrayType.of.reduce(function (acc, ofType) { return reduceType(ofType, reducer, acc, path, maxDepth - 1); }, accumulator);
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
    var isPtBlock = isPortableTextBlock(objectType);
    return objectType.fields.reduce(function (acc, field) {
        // Don't include styles and list types as searchable paths for portable text blocks
        if (isPtBlock && portableTextFields.includes(field.name)) {
            return acc;
        }
        var segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : []);
        return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
    }, accumulator);
}
var BASE_WEIGHTS = [
    { weight: 1, path: ['_id'] },
    { weight: 1, path: ['_type'] },
];
var PREVIEW_FIELD_WEIGHT_MAP = {
    title: 10,
    subtitle: 5,
    description: 1.5,
};
function deriveFromPreview(type) {
    var select = type.preview.select;
    return Object.keys(select)
        .filter(function (fieldName) { return fieldName in PREVIEW_FIELD_WEIGHT_MAP; })
        .map(function (fieldName) { return ({
        weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
        path: select[fieldName].split('.'),
    }); });
}
function getCachedStringFieldPaths(type, maxDepth) {
    if (!type[stringFieldsSymbol]) {
        type[stringFieldsSymbol] = uniqBy(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(BASE_WEIGHTS), false), __read(deriveFromPreview(type)), false), __read(getStringFieldPaths(type, maxDepth).map(function (path) { return ({ weight: 1, path: path }); })), false), __read(getPortableTextFieldPaths(type, maxDepth).map(function (path) { return ({
            weight: 1,
            path: path,
            mapWith: 'pt::text',
        }); })), false), function (spec) { return spec.path.join('.'); });
    }
    return type[stringFieldsSymbol];
}
function getStringFieldPaths(type, maxDepth) {
    var reducer = function (accumulator, childType, path) {
        return childType.jsonType === 'string' ? __spreadArray(__spreadArray([], __read(accumulator), false), [path], false) : accumulator;
    };
    return reduceType(type, reducer, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
    var reducer = function (accumulator, childType, path) {
        return isPortableTextArray(childType) ? __spreadArray(__spreadArray([], __read(accumulator), false), [path], false) : accumulator;
    };
    return reduceType(type, reducer, [], [], maxDepth);
}
export default function resolveSearchConfig(type) {
    return getCachedStringFieldPaths(type, 4);
}
//# sourceMappingURL=resolve.js.map