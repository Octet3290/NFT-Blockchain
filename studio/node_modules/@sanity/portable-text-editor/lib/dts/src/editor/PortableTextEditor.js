var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import React from 'react';
import { Subject, defer, of, EMPTY } from 'rxjs';
import { concatMap, share, switchMap, tap } from 'rxjs/operators';
import { randomKey } from '@sanity/util/content';
import { createEditor, Transforms } from 'slate';
import { debounce, isEqual, throttle } from 'lodash';
import { Slate, withReact } from '@sanity/slate-react';
import { compileType } from '../utils/schema';
import { getPortableTextFeatures } from '../utils/getPortableTextFeatures';
import { validateValue } from '../utils/validateValue';
import { debugWithName } from '../utils/debug';
import { getValueOrInitialValue, isEqualToEmptyEditor, toSlateValue } from '../utils/values';
import { KEY_TO_SLATE_ELEMENT, KEY_TO_VALUE_ELEMENT } from '../utils/weakMaps';
import { PortableTextEditorContext } from './hooks/usePortableTextEditor';
import { PortableTextEditorSelectionContext } from './hooks/usePortableTextEditorSelection';
import { PortableTextEditorReadOnlyContext } from './hooks/usePortableTextReadOnly';
import { PortableTextEditorValueContext } from './hooks/usePortableTextEditorValue';
import { withPlugins } from './plugins';
// Debounce time for flushing local patches (ms since user haven't produced a patch)
// (lower time for tests to speed them up)
export var FLUSH_PATCHES_DEBOUNCE_MS = process.env.NODE_ENV === 'test' ? 50 : 1000;
export var defaultKeyGenerator = function () { return randomKey(12); };
var debug = debugWithName('component:PortableTextEditor');
var PortableTextEditor = /** @class */ (function (_super) {
    __extends(PortableTextEditor, _super);
    function PortableTextEditor(props) {
        var _this = _super.call(this, props) || this;
        _this.change$ = new Subject();
        _this.pendingPatches = [];
        _this.returnedPatches = [];
        _this.setEditable = function (editable) {
            _this.editable = __assign(__assign({}, _this.editable), editable);
            _this.change$.next({ type: 'value', value: _this.props.value || undefined });
            _this.change$.next({ type: 'ready' });
        };
        _this.syncValue = function (userCallbackFn) {
            var val = _this.props.value;
            var callbackFn = function () {
                debug('Updating slate instance');
                _this.slateInstance.onChange();
                _this.change$.next({ type: 'value', value: val });
                if (userCallbackFn) {
                    userCallbackFn();
                }
            };
            if (_this.hasPendingLocalPatches.current && !_this.readOnly) {
                debug('Not syncing value (has pending local patches)');
                retrySync(function () { return _this.syncValue(); }, callbackFn);
                return;
            }
            // If the  editor is empty and there is a new value, just set that value directly.
            if (isEqualToEmptyEditor(_this.slateInstance.children, _this.portableTextFeatures) &&
                _this.props.value) {
                var oldSel = _this.slateInstance.selection;
                Transforms.deselect(_this.slateInstance);
                _this.slateInstance.children = toSlateValue(val, {
                    portableTextFeatures: _this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance));
                if (oldSel) {
                    Transforms.select(_this.slateInstance, oldSel);
                }
                debug('Setting props.value directly to empty editor');
                callbackFn();
                return;
            }
            // Test for diffs between our state value and the incoming value.
            var isEqualToValue = !(val || []).some(function (blk, index) {
                var compareBlock = toSlateValue([blk], { portableTextFeatures: _this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance))[0];
                if (!isEqual(compareBlock, _this.slateInstance.children[index])) {
                    return true;
                }
                return false;
            });
            if (isEqualToValue) {
                debug('Not syncing value (value is equal)');
                return;
            }
            // Value is different - validate it.
            debug('Validating');
            var validation = validateValue(val, _this.portableTextFeatures, _this.keyGenerator);
            if (val && !validation.valid) {
                _this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: val,
                });
                _this.setState({ invalidValueResolution: validation.resolution });
            }
            // Set the new value
            debug('Replacing changed nodes');
            if (val && val.length > 0) {
                var oldSel = _this.slateInstance.selection;
                Transforms.deselect(_this.slateInstance);
                var slateValueFromProps = toSlateValue(val, {
                    portableTextFeatures: _this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance));
                _this.slateInstance.children = slateValueFromProps;
                if (oldSel) {
                    Transforms.select(_this.slateInstance, oldSel);
                }
            }
            callbackFn();
        };
        _this.flush = function () {
            var onChange = _this.props.onChange;
            var finalPatches = __spreadArray([], __read(_this.pendingPatches), false);
            if (finalPatches.length > 0) {
                debug('Flushing', finalPatches);
                finalPatches.forEach(function (p) {
                    _this.returnedPatches.push(p);
                });
                onChange({ type: 'mutation', patches: finalPatches });
                _this.pendingPatches = [];
            }
        };
        _this.flushDebounced = debounce(_this.flush, FLUSH_PATCHES_DEBOUNCE_MS, {
            leading: false,
            trailing: true,
        });
        if (!props.type) {
            throw new Error('PortableTextEditor: missing "type" property');
        }
        _this.hasPendingLocalPatches = React.createRef();
        _this.hasPendingLocalPatches.current = false;
        _this.state = {
            invalidValueResolution: null,
            selection: null,
            initialValue: [], // Created in the constructor
        };
        // Test if we have a compiled schema type, if not, conveniently compile it
        _this.type = props.type.hasOwnProperty('jsonType') ? props.type : compileType(props.type);
        // Indicate that we are loading
        _this.change$.next({ type: 'loading', isLoading: true });
        // Get the block types feature set (lookup table)
        _this.portableTextFeatures = getPortableTextFeatures(_this.type);
        // Setup keyGenerator (either from props, or default)
        _this.keyGenerator = props.keyGenerator || defaultKeyGenerator;
        // Setup processed incoming patches stream
        if (props.incomingPatches$) {
            // Buffer patches until we are no longer producing local patches
            _this.incomingPatches$ = props.incomingPatches$
                .pipe(tap(function (_a) {
                var patches = _a.patches;
                // Reset hasPendingLocalPatches when local patches are returned
                if (patches.some(function (p) { return p.origin === 'local'; })) {
                    _this.hasPendingLocalPatches.current = false;
                }
            }))
                .pipe(bufferUntil(function () { return !_this.hasPendingLocalPatches.current; }), concatMap(function (incoming) {
                return incoming;
            }), share());
        }
        // Subscribe to editor events and set state for selection and pending patches
        _this.changeSubscription = _this.change$.subscribe(function (next) {
            var onChange = _this.props.onChange;
            switch (next.type) {
                case 'patch':
                    _this.pendingPatches.push(next.patch);
                    if (_this.props.incomingPatches$) {
                        _this.hasPendingLocalPatches.current = true;
                    }
                    _this.flushDebounced();
                    onChange(next);
                    break;
                case 'selection':
                    onChange(next);
                    _this.setState({ selection: next.selection });
                    break;
                default:
                    onChange(next);
            }
        });
        // Set maxBlocks and readOnly
        _this.maxBlocks =
            typeof props.maxBlocks === 'undefined'
                ? undefined
                : parseInt(props.maxBlocks.toString(), 10) || undefined;
        _this.readOnly = Boolean(props.readOnly) || false;
        // Validate the incoming value
        if (props.value) {
            var validation = validateValue(props.value, _this.portableTextFeatures, _this.keyGenerator);
            if (props.value && !validation.valid) {
                _this.change$.next({ type: 'loading', isLoading: false });
                _this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: props.value,
                });
                _this.state = __assign(__assign({}, _this.state), { invalidValueResolution: validation.resolution });
            }
        }
        // Create the slate instance
        _this.slateInstance = withPlugins(withReact(createEditor()), {
            portableTextEditor: _this,
        });
        _this.state = __assign(__assign({}, _this.state), { initialValue: toSlateValue(getValueOrInitialValue(props.value, [_this.slateInstance.createPlaceholderBlock()]), { portableTextFeatures: _this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance)) });
        KEY_TO_VALUE_ELEMENT.set(_this.slateInstance, {});
        KEY_TO_SLATE_ELEMENT.set(_this.slateInstance, {});
        return _this;
    }
    PortableTextEditor.prototype.componentWillUnmount = function () {
        this.flush();
        this.changeSubscription.unsubscribe();
        this.slateInstance.destroy();
    };
    PortableTextEditor.prototype.componentDidUpdate = function (prevProps) {
        // Whenever readOnly toggles, recreate the editor's plugin chain
        if (this.props.readOnly !== prevProps.readOnly) {
            this.readOnly = Boolean(this.props.readOnly);
            this.slateInstance = withPlugins(this.slateInstance, {
                portableTextEditor: this,
            });
        }
        // Update the maxBlocks prop
        if (this.props.maxBlocks !== prevProps.maxBlocks) {
            this.maxBlocks =
                typeof this.props.maxBlocks === 'undefined'
                    ? undefined
                    : parseInt(this.props.maxBlocks.toString(), 10) || undefined;
            this.slateInstance.maxBlocks = this.maxBlocks;
        }
        // Sync value from props, but not when we are responding to incoming patches
        // (if this is the case, we sync the value after the incoming patches has been processed - see createWithPatches plugin)
        if (this.props.value !== prevProps.value &&
            (!prevProps.value || this.readOnly || !this.props.incomingPatches$)) {
            this.syncValue();
        }
    };
    PortableTextEditor.prototype.render = function () {
        if (this.state.invalidValueResolution) {
            return this.state.invalidValueResolution.description;
        }
        return (React.createElement(PortableTextEditorContext.Provider, { value: this },
            React.createElement(PortableTextEditorValueContext.Provider, { value: this.props.value },
                React.createElement(PortableTextEditorReadOnlyContext.Provider, { value: Boolean(this.props.readOnly) },
                    React.createElement(PortableTextEditorSelectionContext.Provider, { value: this.state.selection },
                        React.createElement(Slate, { onChange: NOOP, editor: this.slateInstance, value: this.state.initialValue }, this.props.children))))));
    };
    // Static API methods
    PortableTextEditor.activeAnnotations = function (editor) {
        return editor && editor.editable ? editor.editable.activeAnnotations() : [];
    };
    PortableTextEditor.addAnnotation = function (editor, type, value) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.addAnnotation(type, value); };
    PortableTextEditor.blur = function (editor) {
        var _a;
        debug('Host blurred');
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.blur();
    };
    PortableTextEditor.delete = function (editor, selection, options) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.delete(selection, options); };
    PortableTextEditor.findDOMNode = function (editor, element) {
        var _a;
        // eslint-disable-next-line react/no-find-dom-node
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findDOMNode(element);
    };
    PortableTextEditor.findByPath = function (editor, path) {
        var _a;
        return ((_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findByPath(path)) || [];
    };
    PortableTextEditor.focus = function (editor) {
        var _a;
        debug('Host requesting focus');
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focus();
    };
    PortableTextEditor.focusBlock = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusBlock();
    };
    PortableTextEditor.focusChild = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusChild();
    };
    PortableTextEditor.getPortableTextFeatures = function (editor) {
        return editor.portableTextFeatures;
    };
    PortableTextEditor.getSelection = function (editor) {
        return editor.editable ? editor.editable.getSelection() : null;
    };
    PortableTextEditor.getValue = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.getValue();
    };
    PortableTextEditor.hasBlockStyle = function (editor, blockStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasBlockStyle(blockStyle);
    };
    PortableTextEditor.hasListStyle = function (editor, listStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasListStyle(listStyle);
    };
    PortableTextEditor.isCollapsedSelection = function (editor) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isCollapsedSelection(); };
    PortableTextEditor.isExpandedSelection = function (editor) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isExpandedSelection(); };
    PortableTextEditor.isMarkActive = function (editor, mark) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isMarkActive(mark); };
    PortableTextEditor.insertChild = function (editor, type, value) {
        var _a;
        debug("Host inserting child");
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertChild(type, value);
    };
    PortableTextEditor.insertBlock = function (editor, type, value) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertBlock(type, value);
    };
    PortableTextEditor.isVoid = function (editor, element) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isVoid(element);
    };
    PortableTextEditor.isObjectPath = function (editor, path) {
        if (!path || !Array.isArray(path))
            return false;
        var isChildObjectEditPath = path.length > 3 && path[1] === 'children';
        var isBlockObjectEditPath = path.length > 1 && path[1] !== 'children';
        return isBlockObjectEditPath || isChildObjectEditPath;
    };
    PortableTextEditor.marks = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.marks();
    };
    PortableTextEditor.select = function (editor, selection) {
        var _a;
        debug("Host setting selection", selection);
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.select(selection);
    };
    PortableTextEditor.removeAnnotation = function (editor, type) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.removeAnnotation(type); };
    PortableTextEditor.toggleBlockStyle = function (editor, blockStyle) {
        var _a;
        debug("Host is toggling block style");
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleBlockStyle(blockStyle);
    };
    PortableTextEditor.toggleList = function (editor, listStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleList(listStyle);
    };
    PortableTextEditor.toggleMark = function (editor, mark) {
        var _a;
        debug("Host toggling mark", mark);
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleMark(mark);
    };
    return PortableTextEditor;
}(React.Component));
export { PortableTextEditor };
var retrySync = throttle(function (syncFn, callbackFn) { return syncFn(callbackFn); }, 100);
function bufferUntil(emitWhen) {
    return function (source) {
        return defer(function () {
            var buffer = []; // custom buffer
            return source.pipe(tap(function (v) { return buffer.push(v); }), // add values to buffer
            switchMap(function () { return (emitWhen(buffer) ? of(buffer) : EMPTY); }), // emit the buffer when the condition is met
            tap(function () { return (buffer = []); }) // clear the buffer
            );
        });
    };
}
var NOOP = function () { return undefined; };
//# sourceMappingURL=PortableTextEditor.js.map