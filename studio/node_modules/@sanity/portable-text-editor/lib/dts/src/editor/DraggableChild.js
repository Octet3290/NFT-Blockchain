import React, { useRef, useMemo, useCallback } from 'react';
import { Transforms, Editor } from 'slate';
import { ReactEditor, useSlateStatic } from '@sanity/slate-react';
import { debugWithName } from '../utils/debug';
import { IS_DRAGGING, IS_DRAGGING_ELEMENT_RANGE, IS_DRAGGING_CHILD_ELEMENT } from '../utils/weakMaps';
var debug = debugWithName('components:DraggableChild');
export var DraggableChild = function (_a) {
    var children = _a.children, element = _a.element, readOnly = _a.readOnly;
    var editor = useSlateStatic();
    var dragGhostRef = useRef();
    var isVoid = useMemo(function () { return Editor.isVoid(editor, element); }, [editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragOver = useCallback(function (event) {
        var isMyDragOver = IS_DRAGGING_CHILD_ELEMENT.get(editor);
        if (!isMyDragOver) {
            return;
        }
        debug('handle drag over');
        event.preventDefault(); // Needed to get the dropEffect showing
        event.dataTransfer.dropEffect = 'move';
        // Find the range where the drop happened
        var range = ReactEditor.findEventRange(editor, event);
        if (range) {
            IS_DRAGGING_ELEMENT_RANGE.set(editor, range);
            Transforms.select(editor, range);
        }
    }, [editor]);
    // Note: this is called for the dragging child
    var handleDragStart = useCallback(function (event) {
        debug('Drag start');
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_CHILD_ELEMENT.set(editor, element);
        if (isVoid) {
            event.dataTransfer.effectAllowed = 'move';
            // Specify dragImage so that single elements in the preview will not be the drag image,
            // but always the whole block preview itself.
            // Also clone it so that it will not be visually clipped by scroll-containers etc.
            var elm = event.currentTarget;
            if (elm instanceof HTMLElement) {
                var dragGhost = elm.cloneNode(true);
                dragGhostRef.current = dragGhost;
                dragGhost.style.width = "".concat(elm.clientWidth, "px");
                dragGhost.style.height = "".concat(elm.clientHeight, "px");
                dragGhost.style.position = 'absolute';
                dragGhost.style.top = '-99999px';
                dragGhost.style.left = '-99999px';
                if (document.body) {
                    document.body.appendChild(dragGhost);
                    var rect = elm.getBoundingClientRect();
                    var x = event.clientX - rect.left;
                    var y = event.clientY - rect.top;
                    dragGhost.style.width = "".concat(rect.width, "px");
                    dragGhost.style.height = "".concat(rect.height, "px");
                    event.dataTransfer.setDragImage(dragGhost, x, y);
                }
            }
        }
    }, [editor, element, isVoid]);
    if (readOnly) {
        return children;
    }
    return (React.createElement("span", { draggable: isVoid, onDragStart: handleDragStart, onDragOver: handleDragOver }, children));
};
//# sourceMappingURL=DraggableChild.js.map