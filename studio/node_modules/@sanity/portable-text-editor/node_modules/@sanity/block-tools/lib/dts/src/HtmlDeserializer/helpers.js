var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { isBlock } from '@sanity/types';
import { isEqual } from 'lodash';
import { DEFAULT_BLOCK } from '../constants';
import { resolveJsType } from '../util/resolveJsType';
import blockContentTypeFeatures from '../util/blockContentTypeFeatures';
import preprocessors from './preprocessors';
/**
 * A utility function to create the options needed for the various rule sets,
 * based on the structure of the blockContentType
 *
 * @param blockContentType - Schema type for array containing _at least_ a block child type
 * @returns
 */
export function createRuleOptions(blockContentType) {
    var features = blockContentTypeFeatures(blockContentType);
    var enabledBlockStyles = features.styles.map(function (item) { return item.value || item.title; });
    var enabledSpanDecorators = features.decorators.map(function (item) { return item.value || item.title; });
    var enabledBlockAnnotations = features.annotations.map(function (item) { return item.value || item.title || ''; });
    return {
        enabledBlockStyles: enabledBlockStyles,
        enabledSpanDecorators: enabledSpanDecorators,
        enabledBlockAnnotations: enabledBlockAnnotations,
    };
}
/**
 * Utility function that always return a lowerCase version of the element.tagName
 *
 * @param el - Element to get tag name for
 * @returns Lowercase tagName for that element, or undefined if not an element
 */
export function tagName(el) {
    if (el && 'tagName' in el) {
        return el.tagName.toLowerCase();
    }
    return undefined;
}
// TODO: make this plugin-style
export function preprocess(html, parseHtml) {
    var compactHtml = html
        .trim() // Trim whitespace
        .replace(/\s\s+/g, ' ') // Remove multiple whitespace
        .replace(/[\r\n]/g, ' '); // Remove newlines / carriage returns
    var doc = parseHtml(compactHtml);
    preprocessors.forEach(function (processor) {
        processor(html, doc);
    });
    return doc;
}
/**
 * A default `parseHtml` function that returns the html using `DOMParser`.
 *
 * @returns HTML Parser based on `DOMParser`
 */
export function defaultParseHtml() {
    if (resolveJsType(DOMParser) === 'undefined') {
        throw new Error('The native `DOMParser` global which the `Html` deserializer uses by ' +
            'default is not present in this environment. ' +
            'You must supply the `options.parseHtml` function instead.');
    }
    return function (html) {
        return new DOMParser().parseFromString(html, 'text/html');
    };
}
export function flattenNestedBlocks(blocks) {
    var depth = 0;
    var flattened = [];
    var traverse = function (nodes) {
        var toRemove = [];
        nodes.forEach(function (node) {
            if (depth === 0) {
                flattened.push(node);
            }
            if (isBlock(node)) {
                if (depth > 0) {
                    toRemove.push(node);
                    flattened.push(node);
                }
                depth++;
                traverse(node.children);
            }
            if (node._type === '__block') {
                toRemove.push(node);
                flattened.push(node.block);
            }
        });
        toRemove.forEach(function (node) {
            nodes.splice(nodes.indexOf(node), 1);
        });
        depth--;
    };
    traverse(blocks);
    return flattened;
}
function nextSpan(block, index) {
    var next = block.children[index + 1];
    return next && next._type === 'span' ? next : null;
}
function prevSpan(block, index) {
    var prev = block.children[index - 1];
    return prev && prev._type === 'span' ? prev : null;
}
function isWhiteSpaceChar(text) {
    return ['\xa0', ' '].includes(text);
}
/**
 * NOTE: _mutates_ passed blocks!
 *
 * @param blocks - Array of blocks to trim whitespace for
 * @returns
 */
export function trimWhitespace(blocks) {
    blocks.forEach(function (block) {
        if (!isBlock(block)) {
            return;
        }
        // eslint-disable-next-line complexity
        block.children.forEach(function (child, index) {
            if (child._type !== 'span') {
                return;
            }
            var nextChild = nextSpan(block, index);
            var prevChild = prevSpan(block, index);
            if (index === 0) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (index === block.children.length - 1) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(child.text.length - 1)) &&
                nextChild &&
                /\s/.test(nextChild.text.substring(0, 1))) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(0, 1)) &&
                prevChild &&
                /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (!child.text) {
                block.children.splice(index, 1);
            }
            if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
                prevChild.text += ' ';
                block.children.splice(index, 1);
            }
            else if (nextChild &&
                isEqual(nextChild.marks, child.marks) &&
                isWhiteSpaceChar(child.text)) {
                nextChild.text = " ".concat(nextChild.text);
                block.children.splice(index, 1);
            }
        });
    });
    return blocks;
}
export function ensureRootIsBlocks(blocks) {
    return blocks.reduce(function (memo, node, i, original) {
        if (node._type === 'block') {
            memo.push(node);
            return memo;
        }
        if (node._type === '__block') {
            memo.push(node.block);
            return memo;
        }
        var lastBlock = memo[memo.length - 1];
        if (i > 0 && !isBlock(original[i - 1]) && isBlock(lastBlock)) {
            lastBlock.children.push(node);
            return memo;
        }
        var block = __assign(__assign({}, DEFAULT_BLOCK), { children: [node] });
        memo.push(block);
        return memo;
    }, []);
}
export function isNodeList(node) {
    return Object.prototype.toString.call(node) == '[object NodeList]';
}
export function isMinimalSpan(node) {
    return node._type === 'span';
}
export function isMinimalBlock(node) {
    return node._type === 'block';
}
export function isPlaceholderDecorator(node) {
    return node._type === '__decorator';
}
export function isPlaceholderAnnotation(node) {
    return node._type === '__annotation';
}
export function isElement(node) {
    return node.nodeType === 1;
}
//# sourceMappingURL=helpers.js.map