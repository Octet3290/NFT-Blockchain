'use strict';

var tslib_es6 = require('../_tslib.es6-95082e83.cjs');
var lodash = require('lodash');
var inspect = require('object-inspect');
var humanizeList = require('humanize-list');
var leven = require('leven');
require('@sanity/generate-help-url');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var inspect__default = /*#__PURE__*/_interopDefaultLegacy(inspect);
var humanizeList__default = /*#__PURE__*/_interopDefaultLegacy(humanizeList);
var leven__default = /*#__PURE__*/_interopDefaultLegacy(leven);

// Temporary solution to ensure we have a central registry over used helpIds
var HELP_IDS = {
    TYPE_INVALID: 'schema-type-invalid',
    TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',
    TYPE_NAME_RESERVED: 'schema-type-name-reserved',
    TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',
    TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',
    TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',
    TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',
    OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',
    OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',
    OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',
    OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',
    ARRAY_OF_ARRAY: 'schema-array-of-array',
    ARRAY_OF_INVALID: 'schema-array-of-invalid',
    ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',
    ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',
    ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',
    REFERENCE_TO_INVALID: 'schema-reference-to-invalid',
    REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',
    REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',
    REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',
    REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',
    SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',
    ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',
    CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',
};
function createValidationResult(severity, message, helpId) {
    if (helpId && !Object.keys(HELP_IDS).some(function (id) { return HELP_IDS[id] === helpId; })) {
        throw new Error("Used the unknown helpId \"".concat(helpId, "\", please add it to the array in createValidationResult.js"));
    }
    return {
        severity: severity,
        message: message,
        helpId: helpId,
    };
}
var error = function (message, helpId) {
    return createValidationResult('error', message, helpId);
};
var warning = function (message, helpId) {
    return createValidationResult('warning', message, helpId);
};

/**
 * @internal
 */
function groupProblems(types) {
    return lodash.flatten(types.map(function (type) { return getTypeProblems(type); })).filter(function (type) { return type.problems.length > 0; });
}
function createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers) {
    if (getMembers === void 0) { getMembers = function (type) { return lodash.get(type, memberPropertyName); }; }
    return function getProblems(type, parentPath) {
        var currentPath = tslib_es6.__spreadArray(tslib_es6.__spreadArray([], tslib_es6.__read(parentPath), false), [
            { kind: 'type', type: type.type, name: type.name },
        ], false);
        var members = getMembers(type) || [];
        var memberProblems = Array.isArray(members)
            ? members.map(function (memberType) {
                var propertySegment = {
                    kind: 'property',
                    name: memberPropertyName,
                };
                var memberPath = tslib_es6.__spreadArray(tslib_es6.__spreadArray([], tslib_es6.__read(currentPath), false), [propertySegment], false);
                return getTypeProblems(memberType, memberPath);
            })
            : [
                [
                    {
                        path: currentPath,
                        problems: [error("Member declaration (".concat(memberPropertyName, ") is not an array"))],
                    },
                ],
            ];
        return tslib_es6.__spreadArray([
            {
                path: currentPath,
                problems: type._problems || [],
            }
        ], tslib_es6.__read(lodash.flatten(memberProblems)), false);
    };
}
var arrify = function (val) { return (Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]); };
var getObjectProblems = createTypeWithMembersProblemsAccessor('fields');
var getImageProblems = createTypeWithMembersProblemsAccessor('fields');
var getFileProblems = createTypeWithMembersProblemsAccessor('fields');
var getArrayProblems = createTypeWithMembersProblemsAccessor('of');
var getReferenceProblems = createTypeWithMembersProblemsAccessor('to', function (type) {
    return 'to' in type ? arrify(type.to) : [];
});
var getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations');
var getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of');
var getBlockProblems = function (type, problems) { return tslib_es6.__spreadArray(tslib_es6.__spreadArray([], tslib_es6.__read(getBlockAnnotationProblems(type, problems)), false), tslib_es6.__read(getBlockMemberProblems(type, problems)), false); };
function getDefaultProblems(type, path) {
    if (path === void 0) { path = []; }
    return [
        {
            path: tslib_es6.__spreadArray(tslib_es6.__spreadArray([], tslib_es6.__read(path), false), [{ kind: 'type', type: type.type, name: type.name }], false),
            problems: type._problems || [],
        },
    ];
}
function getTypeProblems(type, path) {
    if (path === void 0) { path = []; }
    switch (type.type) {
        case 'object': {
            return getObjectProblems(type, path);
        }
        case 'document': {
            return getObjectProblems(type, path);
        }
        case 'array': {
            return getArrayProblems(type, path);
        }
        case 'reference': {
            return getReferenceProblems(type, path);
        }
        case 'block': {
            return getBlockProblems(type, path);
        }
        case 'image': {
            return getImageProblems(type, path);
        }
        case 'file': {
            return getFileProblems(type, path);
        }
        default: {
            return getDefaultProblems(type, path);
        }
    }
}

function getDupes(array, selector) {
    if (selector === void 0) { selector = function (v) { return v; }; }
    var dupes = array.reduce(function (acc, item) {
        var key = selector(item);
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(item);
        return acc;
    }, {});
    return Object.keys(dupes)
        .map(function (key) { return (dupes[key].length > 1 ? dupes[key] : null); })
        .filter(Boolean);
}

var NOOP_VISITOR = function (typeDef) { return typeDef; };
var TYPE_TYPE = { name: 'type', type: null };
var FUTURE_RESERVED = ['any', 'time', 'date'];
function traverseSchema(types, coreTypes, visitor) {
    if (types === void 0) { types = []; }
    if (coreTypes === void 0) { coreTypes = []; }
    if (visitor === void 0) { visitor = NOOP_VISITOR; }
    var coreTypesRegistry = Object.create(null);
    var registry = Object.create(null);
    var coreTypeNames = coreTypes.map(function (typeDef) { return typeDef.name; });
    var reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames);
    var typeNames = types.map(function (typeDef) { return typeDef && typeDef.name; }).filter(Boolean);
    coreTypes.forEach(function (coreType) {
        coreTypesRegistry[coreType.name] = coreType;
    });
    types.forEach(function (type, i) {
        // Allocate a placeholder for each type
        registry[(type && type.name) || "__unnamed_".concat(i)] = {};
    });
    function getType(typeName) {
        return typeName === 'type'
            ? TYPE_TYPE
            : coreTypesRegistry[typeName] || registry[typeName] || null;
    }
    var duplicateNames = lodash.uniq(lodash.flatten(getDupes(typeNames)));
    function isDuplicate(typeName) {
        return duplicateNames.includes(typeName);
    }
    function getTypeNames() {
        return typeNames.concat(coreTypeNames);
    }
    function isReserved(typeName) {
        return typeName === 'type' || reservedTypeNames.includes(typeName);
    }
    var visitType = function (isRoot) { return function (typeDef, index) {
        return visitor(typeDef, {
            visit: visitType(false),
            isRoot: isRoot,
            getType: getType,
            getTypeNames: getTypeNames,
            isReserved: isReserved,
            isDuplicate: isDuplicate,
            index: index,
        });
    }; };
    coreTypes.forEach(function (coreTypeDef) {
        Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
    });
    types.forEach(function (typeDef, i) {
        Object.assign(registry[(typeDef && typeDef.name) || "__unnamed_".concat(i)], visitType(true)(typeDef, i));
    });
    return {
        get: function (typeName) {
            var res = registry[typeName] || coreTypesRegistry[typeName];
            if (res) {
                return res;
            }
            throw new Error("No such type: ".concat(typeName));
        },
        has: function (typeName) {
            return typeName in registry || typeName in coreTypesRegistry;
        },
        getTypeNames: function () {
            return Object.keys(registry);
        },
        getTypes: function () {
            return this.getTypeNames().map(this.get);
        },
        toJSON: function () {
            return this.getTypes();
        },
    };
}

var coreTypes = [
    { name: 'array', jsonType: 'array', type: 'type' },
    { name: 'block', jsonType: 'object', type: 'type' },
    { name: 'boolean', jsonType: 'boolean', type: 'type' },
    { name: 'datetime', jsonType: 'string', type: 'type' },
    { name: 'date', jsonType: 'string', type: 'type' },
    { name: 'document', jsonType: 'object', type: 'type' },
    { name: 'email', jsonType: 'string', type: 'type' },
    { name: 'file', jsonType: 'object', type: 'type' },
    { name: 'geopoint', jsonType: 'object', type: 'type' },
    { name: 'image', jsonType: 'object', type: 'type' },
    { name: 'number', jsonType: 'number', type: 'type' },
    { name: 'object', jsonType: 'object', type: 'type' },
    { name: 'reference', jsonType: 'object', type: 'type' },
    { name: 'crossDatasetReference', jsonType: 'object', type: 'type' },
    { name: 'slug', jsonType: 'object', type: 'type' },
    { name: 'string', jsonType: 'string', type: 'type' },
    { name: 'telephone', jsonType: 'string', type: 'type' },
    { name: 'text', jsonType: 'string', type: 'type' },
    { name: 'url', jsonType: 'string', type: 'type' },
];
var coreTypeNames = coreTypes.map(function (t) { return t.name; });

function traverseSanitySchema(schemaTypes, visitor) {
    return traverseSchema(schemaTypes, coreTypes, visitor);
}

var REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isInputComponentLike(value) {
    var type = typeof value;
    // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.
    return (type === 'function' ||
        (typeof (value === null || value === void 0 ? void 0 : value.$$typeof) === 'symbol' && REACT_SYM_RE.test(String(value === null || value === void 0 ? void 0 : value.$$typeof))));
}

function validateInputComponent(typeDef) {
    if ('components' in typeDef && !isInputComponentLike(typeDef.components.input)) {
        return [
            warning("The `components.input` property is set but does not appear to be a valid React component (expected a function, but saw ".concat(inspect__default["default"](typeDef.components.input), "). If you have imported a custom input component, please verify that you have imported the correct named/default export.")),
        ];
    }
    return [];
}

var VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
var CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
    if (typeof name !== 'string') {
        return [
            error("Field names must be strings. Saw \"".concat(inspect__default["default"](name), "\""), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (name.startsWith('_')) {
        return [
            error("Invalid field name \"".concat(name, "\". Field names cannot start with underscores \"_\" as it's reserved for system fields."), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!VALID_FIELD_RE.test(name)) {
        return [
            error("Invalid field name: \"".concat(name, "\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ").concat(String(VALID_FIELD_RE), ")."), HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!CONVENTIONAL_FIELD_RE.test(name)) {
        return [
            warning('Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +
                ' It may be wise to keep special characters out of field names for easier access later on.'),
            HELP_IDS.OBJECT_FIELD_NAME_INVALID,
        ];
    }
    return [];
}
function validateField(field, _visitorContext) {
    if (!lodash.isPlainObject(field)) {
        return [
            error("Incorrect type for field definition - should be an object, saw ".concat(inspect__default["default"](field)), HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE),
        ];
    }
    var problems = [];
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(('name' in field
        ? validateFieldName(field.name)
        : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)])), false));
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(validateInputComponent(field)), false));
    return problems;
}
function getDuplicateFields(array) {
    var dupes = {};
    array.forEach(function (field) {
        if (!dupes[field.name]) {
            dupes[field.name] = [];
        }
        dupes[field.name].push(field);
    });
    return Object.keys(dupes)
        .map(function (fieldName) { return (dupes[fieldName].length > 1 ? dupes[fieldName] : null); })
        .filter(Boolean);
}
function validateFields(fields, options) {
    if (options === void 0) { options = { allowEmpty: false }; }
    var problems = [];
    var fieldsIsArray = Array.isArray(fields);
    if (!fieldsIsArray) {
        return [
            error("The \"fields\" property must be an array of fields. Instead saw \"".concat(typeof fields, "\""), HELP_IDS.OBJECT_FIELDS_INVALID),
        ];
    }
    var fieldsWithNames = fields.filter(function (field) { return typeof field.name === 'string'; });
    getDuplicateFields(fieldsWithNames).forEach(function (dupes) {
        problems.push(error("Found ".concat(dupes.length, " fields with name \"").concat(dupes[0].name, "\" in object"), HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
    });
    if (fields.length === 0 && !options.allowEmpty) {
        problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID));
    }
    return problems;
}
function validatePreview(preview) {
    if (!lodash.isPlainObject(preview)) {
        return [error("The \"preview\" property must be an object, instead saw \"".concat(typeof preview, "\""))];
    }
    if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {
        return [
            error("The \"preview.prepare\" property must be a function, instead saw \"".concat(typeof preview.prepare, "\"")),
        ];
    }
    if (!preview.select) {
        return [];
    }
    if (!lodash.isPlainObject(preview.select)) {
        return [
            error("The \"preview.select\" property must be an object, instead saw \"".concat(typeof preview.prepare, "\"")),
        ];
    }
    return Object.keys(preview.select).reduce(function (errs, key) {
        return typeof preview.select[key] === 'string'
            ? errs
            : errs.concat(error("The key \"".concat(key, "\" of \"preview.select\" must be a string, instead saw \"").concat(typeof preview
                .select[key], "\"")));
    }, []);
}
var object = (function (typeDef, visitorContext) {
    var problems = validateFields(typeDef.fields);
    var preview = typeDef.preview;
    if (preview) {
        var previewErrors = validatePreview(typeDef.preview);
        problems = problems.concat(previewErrors);
        preview = previewErrors.some(function (err) { return err.severity === 'error'; }) ? {} : preview;
    }
    if (typeDef.type !== 'document' &&
        typeDef.type !== 'object' &&
        typeof typeDef.initialValue !== 'undefined') {
        problems.push(error("The \"initialValue\" property is currently only supported for document & object types."));
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { preview: preview, fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map(function (field, index) {
            var name = field.name, fieldTypeDef = tslib_es6.__rest(field, ["name"]);
            var _a = visitorContext.visit(fieldTypeDef, index), _problems = _a._problems, fieldType = tslib_es6.__rest(_a, ["_problems"]);
            return tslib_es6.__assign(tslib_es6.__assign({ name: name }, fieldType), { _problems: validateField(field).concat(_problems || []) });
        }), _problems: problems });
});

var documentVisitor = (function (typeDefinition, visitorContext) {
    var typeDef = object(typeDefinition, visitorContext);
    var initialValue = typeDef.initialValue, initialValues = typeDef.initialValues;
    var hasInitialValue = typeof initialValue !== 'undefined';
    if (hasInitialValue && !lodash.isPlainObject(initialValue) && typeof initialValue !== 'function') {
        typeDef._problems.push(error("The \"initialValue\" property must be either a plain object or a function"));
    }
    if (typeof initialValues !== 'undefined') {
        typeDef._problems.push(error("Found property \"initialValues\" - did you mean \"initialValue\"?"));
    }
    return typeDef;
});

function normalizeToProp$1(typeDef) {
    if (Array.isArray(typeDef.to)) {
        return typeDef.to;
    }
    return typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (function (typeDef, visitorContext) {
    var isValidTo = Array.isArray(typeDef.to) || lodash.isPlainObject(typeDef.to);
    var normalizedTo = normalizeToProp$1(typeDef);
    var problems = lodash.flatten([
        isValidTo
            ? getDupes(normalizedTo, function (t) { return "".concat(t.name, ";").concat(t.type); }).map(function (dupes) {
                return error("Found ".concat(dupes.length, " members with same type, but not unique names \"").concat(dupes[0].type, "\" in reference. This makes it impossible to tell their values apart and you should consider naming them"), HELP_IDS.REFERENCE_TO_INVALID);
            })
            : error('The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.REFERENCE_TO_INVALID),
    ]);
    if (isValidTo && normalizedTo.length === 0) {
        problems.push(error('The reference type should define at least one accepted type. Please check the "to" property.', HELP_IDS.REFERENCE_TO_INVALID));
    }
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(getOptionErrors$1(typeDef)), false));
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { to: (isValidTo ? normalizedTo : []).map(visitorContext.visit), _problems: problems });
});
function getOptionErrors$1(typeDef) {
    var options = typeDef.options;
    var problems = [];
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(['filter', 'filterParams']
        .filter(function (key) { return key in typeDef; })
        .map(function (key) {
        return error("`".concat(key, "` is not allowed on a reference type definition - did you mean `options.").concat(key, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION);
    })), false));
    if (!options) {
        return problems;
    }
    if (!lodash.isPlainObject(options)) {
        return problems.concat(error('The reference type expects `options` to be an object', HELP_IDS.REFERENCE_INVALID_OPTIONS));
    }
    if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {
        return problems.concat(error('`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.', HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
    }
    if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {
        return problems;
    }
    if (typeof options.filter !== 'string') {
        return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
    }
    if (typeof options.filterParams !== 'undefined' && !lodash.isPlainObject(options.filterParams)) {
        return problems.concat(error("If set, `filterParams` must be an object."));
    }
    if (options.filterParams) {
        return problems.concat(Object.keys(options.filterParams)
            .filter(function (key) { return key.startsWith('__') || key.startsWith('$'); })
            .map(function (key) { return error("Filter parameter cannot be prefixed with \"$\" or \"__\". Got ".concat(key, "\".")); }));
    }
    return problems;
}

var array = (function (typeDef, visitorContext) {
    var _a, _b;
    // name should already have been marked
    var ofIsArray = Array.isArray(typeDef.of);
    if (ofIsArray) {
        var invalid = typeDef.of.reduce(function (errs, def, idx) {
            if (typeof def.name === 'string') {
                // If an array member has been given a "local" type name, we want to trigger an error if the given member type name
                // is one of the builtin types
                //
                // The following examples should be an error (where book is an existing root level type and reference is a built-in type):
                //  - (…) of: [{type: 'book', name: 'image'}]
                //  - (…) of: [{type: 'book', name: 'object'}]
                //  - (…) of: [{type: 'object', name: 'reference'}]
                // The following examples are valid (where "address" is not defined as a global object type)
                //  - (…) of: [{type: 'object', name: 'address'}]
                // The following examples are redundant, but should be allowed (at least for now)
                //  - (…) of: [{type: 'object', name: 'object'}]
                //  - (…) of: [{type: 'image', name: 'image'}]
                if (
                // specifying the same name as the type is redundant, but should not be a hard error at this point
                // Consider showing a warning for this and deprecate this ability eventually
                def.name !== def.type &&
                    coreTypeNames.includes(def.name)) {
                    return errs.concat(error("Found array member declaration with the same type name as a built-in type (\"".concat(def.name, "\"). Array members can not be given the same name as a built-in type."), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
                }
            }
            if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {
                return errs.concat(warning("Found array member declaration with the same name as the global schema type \"".concat(def.name, "\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name."), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
            }
            if (def.type === 'array') {
                return errs.concat(error("Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity", HELP_IDS.ARRAY_OF_ARRAY));
            }
            if (def) {
                return errs;
            }
            var err = "Found ".concat(def === null ? 'null' : typeof def, ", expected member declaration");
            return errs.concat(error("Found invalid type member declaration in array at index ".concat(idx, ": ").concat(err), HELP_IDS.ARRAY_OF_INVALID));
        }, []);
        if (invalid.length > 0) {
            return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { of: [], _problems: invalid });
        }
    }
    var problems = lodash.flatten([
        ofIsArray
            ? getDupes(typeDef.of, function (t) { return "".concat(t.name, ";").concat(t.type); }).map(function (dupes) {
                return error("Found ".concat(dupes.length, " members with same type, but not unique names \"").concat(dupes[0].type, "\" in array. This makes it impossible to tell their values apart and you should consider naming them"), HELP_IDS.ARRAY_OF_NOT_UNIQUE);
            })
            : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID),
    ]);
    var of = ofIsArray ? typeDef.of : [];
    // Don't allow object types without a name in block arrays
    var hasObjectTypesWithoutName = of.some(function (type) { return type.type === 'object' && typeof type.name === 'undefined'; });
    var hasBlockType = of.some(function (ofType) { return ofType.type === 'block'; });
    if (hasBlockType && hasObjectTypesWithoutName) {
        problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
    }
    if (((_a = typeDef === null || typeDef === void 0 ? void 0 : typeDef.options) === null || _a === void 0 ? void 0 : _a.list) && ((_b = typeDef === null || typeDef === void 0 ? void 0 : typeDef.options) === null || _b === void 0 ? void 0 : _b.layout) === 'tags') {
        problems.push(warning('Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.'));
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { of: of.map(visitorContext.visit), _problems: problems });
});

var slug = (function (typeDef, visitorContext) {
    var problems = [];
    if (typeDef.options && typeDef.options.slugifyFn) {
        problems.push(warning('Heads up! The "slugifyFn" option has been renamed to "slugify".', HELP_IDS.SLUG_SLUGIFY_FN_RENAMED));
        typeDef.options.slugify = typeDef.options.slugifyFn;
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { _problems: problems });
});

var file = (function (typeDef, visitorContext) {
    var problems = [];
    var fields = typeDef.fields;
    if (fields) {
        problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(validateFields(fields, { allowEmpty: true })), false));
    }
    if (typeDef.options &&
        typeof typeDef.options.metadata !== 'undefined' &&
        !Array.isArray(typeDef.options.metadata)) {
        problems.push(error("Invalid type for file `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { fields: (Array.isArray(fields) ? fields : []).map(function (field, index) {
            var name = field.name, fieldTypeDef = tslib_es6.__rest(field, ["name"]);
            var _a = visitorContext.visit(fieldTypeDef, index), _problems = _a._problems, fieldType = tslib_es6.__rest(_a, ["_problems"]);
            return tslib_es6.__assign(tslib_es6.__assign({ name: name }, fieldType), { _problems: validateField(field).concat(_problems || []) });
        }), _problems: problems });
});

var autoMeta = ['dimensions', 'hasAlpha', 'isOpaque'];
var image = (function (typeDef, visitorContext) {
    var problems = [];
    var fields = typeDef.fields;
    if (fields) {
        problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(validateFields(fields, { allowEmpty: true })), false));
    }
    var options = typeDef.options;
    var metadata = options === null || options === void 0 ? void 0 : options.metadata;
    var superfluousMeta = Array.isArray(metadata)
        ? metadata.filter(function (meta) { return autoMeta.includes(meta); })
        : [];
    if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {
        problems.push(error("Invalid type for image `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID));
    }
    else if (superfluousMeta.length > 0) {
        problems.push(warning("Image `metadata` field contains superfluous properties (they are always included): ".concat(superfluousMeta.join(', '))));
        options = tslib_es6.__assign(tslib_es6.__assign({}, options), { metadata: metadata.filter(function (meta) { return !autoMeta.includes(meta); }) });
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { options: options, fields: (Array.isArray(fields) ? fields : []).map(function (field, index) {
            var name = field.name, fieldTypeDef = tslib_es6.__rest(field, ["name"]);
            var _a = visitorContext.visit(fieldTypeDef, index), _problems = _a._problems, fieldType = tslib_es6.__rest(_a, ["_problems"]);
            return tslib_es6.__assign(tslib_es6.__assign({ name: name }, fieldType), { _problems: validateField(field).concat(_problems || []) });
        }), _problems: problems });
});

function isJSONTypeOf(type, jsonType, visitorContext) {
    if ('jsonType' in type) {
        return type.jsonType === jsonType;
    }
    var parentType = visitorContext.getType(type.type);
    if (!parentType) {
        throw new Error("Could not resolve jsonType of ".concat(type.name, ". No parent type found"));
    }
    return isJSONTypeOf(parentType, jsonType, visitorContext);
}

var getTypeOf = function (thing) { return (Array.isArray(thing) ? 'array' : typeof thing); };
var quote$1 = function (str) { return "\"".concat(str, "\""); };
var allowedKeys = [
    'lists',
    'marks',
    'name',
    'of',
    'options',
    'styles',
    'title',
    'type',
    'validation',
];
var allowedMarkKeys = ['decorators', 'annotations'];
var allowedStyleKeys = ['title', 'value', 'blockEditor'];
var allowedDecoratorKeys = ['title', 'value', 'blockEditor', 'icon'];
function validateBlockType(typeDef, visitorContext) {
    var problems = [];
    var styles = typeDef.styles;
    var marks = typeDef.marks;
    var members = typeDef.of;
    var disallowedKeys = Object.keys(typeDef).filter(function (key) { return !allowedKeys.includes(key) && !key.startsWith('_'); });
    if (disallowedKeys.length > 0) {
        problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList__default["default"](disallowedKeys.map(quote$1)))));
    }
    if (marks) {
        marks = validateMarks(typeDef.marks, visitorContext, problems);
    }
    if (styles) {
        styles = validateStyles(styles, visitorContext, problems);
    }
    if (members) {
        members = validateMembers(members, visitorContext, problems);
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, lodash.omit(typeDef, disallowedKeys)), { marks: marks, styles: styles, of: members, _problems: problems });
}
function validateMarks(marks, visitorContext, problems) {
    var decorators = marks.decorators;
    var annotations = marks.annotations;
    if (!lodash.isPlainObject(marks)) {
        problems.push(error("\"marks\" declaration should be an object, got ".concat(getTypeOf(marks))));
        return problems;
    }
    var disallowedMarkKeys = Object.keys(marks).filter(function (key) { return !allowedMarkKeys.includes(key) && !key.startsWith('_'); });
    if (disallowedMarkKeys.length > 0) {
        problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList__default["default"](disallowedMarkKeys.map(quote$1)))));
    }
    if (decorators && !Array.isArray(decorators)) {
        problems.push(error("\"marks.decorators\" declaration should be an array, got ".concat(getTypeOf(decorators))));
    }
    else if (decorators) {
        decorators = validateDecorators(decorators, visitorContext, problems);
    }
    if (annotations && !Array.isArray(annotations)) {
        problems.push(error("\"marks.annotations\" declaration should be an array, got ".concat(getTypeOf(annotations))));
    }
    else if (annotations) {
        annotations = validateAnnotations(annotations, visitorContext);
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, marks), { decorators: decorators, annotations: annotations });
}
function validateStyles(styles, visitorContext, problems) {
    if (!Array.isArray(styles)) {
        problems.push(error("\"styles\" declaration should be an array, got ".concat(getTypeOf(styles))));
        return problems;
    }
    styles.forEach(function (style, index) {
        if (!lodash.isPlainObject(style)) {
            problems.push(error("Style must be an object, got ".concat(getTypeOf(style))));
            return;
        }
        var name = style.value || "#".concat(index);
        var disallowedKeys = Object.keys(style).filter(function (key) { return !allowedStyleKeys.includes(key) && !key.startsWith('_'); });
        if (disallowedKeys.length > 0) {
            problems.push(error("Found unknown properties for style ".concat(name, ": ").concat(humanizeList__default["default"](disallowedKeys.map(quote$1)))));
        }
        if (!style.value) {
            problems.push(error("Style #".concat(index, " is missing required \"value\" property")));
        }
        else if (typeof style.value !== 'string') {
            problems.push(error("Style #".concat(index, " has an invalid \"value\" property, expected string, got ").concat(getTypeOf(style.value))));
        }
        else if (!style.title) {
            problems.push(warning("Style ".concat(name, " is missing recommended \"title\" property")));
        }
    });
    return styles;
}
function validateDecorators(decorators, visitorContext, problems) {
    decorators.forEach(function (decorator, index) {
        if (!lodash.isPlainObject(decorator)) {
            problems.push(error("Annotation must be an object, got ".concat(getTypeOf(decorator))));
            return;
        }
        var name = decorator.value || "#".concat(index);
        var disallowedKeys = Object.keys(decorator).filter(function (key) { return !allowedDecoratorKeys.includes(key) && !key.startsWith('_'); });
        if (disallowedKeys.length > 0) {
            problems.push(error("Found unknown properties for decorator ".concat(name, ": ").concat(humanizeList__default["default"](disallowedKeys.map(quote$1)))));
        }
        if (!decorator.value) {
            problems.push(error("Decorator #".concat(index, " is missing required \"value\" property")));
        }
        else if (typeof decorator.value !== 'string') {
            problems.push(error("Decorator #".concat(index, " has an invalid \"value\" property, expected string, got ").concat(getTypeOf(decorator.value))));
        }
        else if (!decorator.title) {
            problems.push(warning("Decorator ".concat(name, " is missing recommended \"title\" property")));
        }
    });
    return decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
    return annotations.map(function (annotation) {
        if (!lodash.isPlainObject(annotation)) {
            return tslib_es6.__assign(tslib_es6.__assign({}, annotation), { _problems: [error("Annotation must be an object, got ".concat(getTypeOf(annotation)))] });
        }
        var _problems = visitorContext.visit(annotation, visitorContext)._problems;
        var targetType = annotation.type && visitorContext.getType(annotation.type);
        if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {
            _problems.push(error("Annotation cannot have type \"".concat(annotation.type, "\" - annotation types must inherit from object")));
        }
        return tslib_es6.__assign(tslib_es6.__assign({}, annotation), { _problems: _problems });
    });
}
function validateMembers(members, visitorContext, problems) {
    if (!Array.isArray(members)) {
        problems.push(error("\"of\" declaration should be an array, got ".concat(getTypeOf(members))));
        return undefined;
    }
    return members.map(function (member) {
        var _problems = visitorContext.visit(member, visitorContext)._problems;
        return tslib_es6.__assign(tslib_es6.__assign({}, member), { _problems: _problems });
    });
}

function validateNonObjectFieldsProp(typeDef, visitorContext) {
    if (!('fields' in typeDef)) {
        return [];
    }
    var type = typeDef;
    while (type && !type.jsonType) {
        type = visitorContext.getType(type.type);
    }
    if (type && type.jsonType !== 'object') {
        return [error("Type has propery \"fields\", but is not an object/document type.")];
    }
    return [];
}

var quote = function (str) { return "\"".concat(str, "\""); };
function validateTypeName(typeName, visitorContext) {
    var possibleTypeNames = visitorContext.getTypeNames();
    if (!typeName) {
        return [
            error("Type is missing a type. Valid types are: ".concat(humanizeList__default["default"](possibleTypeNames)), HELP_IDS.TYPE_MISSING_TYPE),
        ];
    }
    if (typeof typeName !== 'string') {
        return [
            error("Type has an invalid \"type\"-property - should be a string. Valid types are: ".concat(humanizeList__default["default"](possibleTypeNames)), HELP_IDS.TYPE_MISSING_TYPE),
        ];
    }
    var isValid = possibleTypeNames.includes(typeName);
    if (!isValid) {
        var suggestions = possibleTypeNames
            .map(function (possibleTypeName) {
            return [leven__default["default"](typeName, possibleTypeName), possibleTypeName];
        })
            .filter(function (_a) {
            var _b = tslib_es6.__read(_a, 1), distance = _b[0];
            return distance < 3;
        })
            .map(function (_a) {
            var _b = tslib_es6.__read(_a, 2), name = _b[1];
            return name;
        });
        var suggestion = suggestions.length > 0
            ? " Did you mean ".concat(humanizeList__default["default"](suggestions.map(quote), { conjunction: 'or' }), "?")
            : '';
        return [
            error("Unknown type: ".concat(typeName, ".").concat(suggestion, "\n\nValid types are: ").concat(humanizeList__default["default"](possibleTypeNames))),
        ];
    }
    return [];
}

var common = (function (typeDef, visitorContext) {
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { _problems: tslib_es6.__spreadArray(tslib_es6.__spreadArray([], tslib_es6.__read(validateTypeName(typeDef.type, visitorContext)), false), tslib_es6.__read(validateNonObjectFieldsProp(typeDef, visitorContext)), false).filter(Boolean) });
});

var rootType = (function (typeDef, visitorContext) {
    var hasName = Boolean(typeDef.name);
    if (!hasName && Object.keys(typeDef).length === 1) {
        // Short-circuit on obviously invalid types (only key is _problems)
        return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { _problems: [
                error('Invalid/undefined type declaration, check declaration or the import/export of the schema type.', HELP_IDS.TYPE_INVALID),
            ] });
    }
    var problems = [];
    if (looksLikeEsmModule(typeDef)) {
        problems.push(error('Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property', HELP_IDS.TYPE_IS_ESM_MODULE));
    }
    else if (!hasName) {
        problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME));
    }
    else if (visitorContext.isReserved(typeDef.name)) {
        problems.push(error("Invalid type name: \"".concat(typeDef.name, "\" is a reserved name."), HELP_IDS.TYPE_NAME_RESERVED));
    }
    if (visitorContext.isDuplicate(typeDef.name)) {
        problems.push(error("Invalid type name: A type with name \"".concat(typeDef.name, "\" is already defined in the schema.")));
    }
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(validateInputComponent(typeDef)), false));
    if (!('title' in typeDef)) {
        problems.push(warning("Type is missing title. It's recommended to always set a descriptive title.", HELP_IDS.TYPE_TITLE_RECOMMENDED));
    }
    else if (typeof typeDef.title !== 'string') {
        problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID));
    }
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { _problems: problems });
});
function looksLikeEsmModule(typeDef) {
    return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}

var validateExperimentalSearch = function (configs) {
    if (!Array.isArray(configs)) {
        return ['The search config of a document type must be an array of search config objects'];
    }
    return configs
        .map(function (conf) {
        if (!lodash.isPlainObject(conf)) {
            return 'Search config must be an object of {path: string, weight: number}';
        }
        return null;
    })
        .filter(Boolean);
};

function normalizeToProp(typeDef) {
    if (Array.isArray(typeDef.to)) {
        return typeDef.to;
    }
    return typeDef.to ? [typeDef.to] : typeDef.to;
}
var VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
    var isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name);
    return (isValid ||
        "The provided dataset \"".concat(name, "\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore"));
}
var VALID_TOKEN_ID = /^[a-zA-Z0-9_][a-zA-Z0-9_-]+$/;
function isValidTokenId(tokenId) {
    var isValid = tokenId.length >= 2 && VALID_TOKEN_ID.test(tokenId);
    return (isValid ||
        "The provided tokenId \"".concat(tokenId, "\" is invalid. The tokenId must be a string made up of at least 2 characters in the a-zA-Z0-9_- range and cannot start with a - (dash) character"));
}
var crossDatasetReference = (function (typeDef, visitorContext) {
    var isValidTo = Array.isArray(typeDef.to) || lodash.isPlainObject(typeDef.to);
    var normalizedTo = normalizeToProp(typeDef);
    var problems = lodash.flatten([
        isValidTo
            ? getDupes(normalizedTo, function (t) { return "".concat(t.name, ";").concat(t.type); }).map(function (dupes) {
                return error("Found ".concat(dupes.length, " members with same type, but not unique names \"").concat(dupes[0].type, "\" in reference. This makes it impossible to tell their values apart and you should consider naming them"), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID);
            })
            : error('The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID),
    ]);
    if (isValidTo && normalizedTo.length === 0) {
        problems.push(error('The cross dataset reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    normalizedTo.forEach(function (crossDatasetTypeDef, index) {
        if (!crossDatasetTypeDef.type) {
            problems.push(error("The referenced type at index ".concat(index, " must be named. Specify the name of the type you want to create references to."), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
        if (!lodash.isPlainObject(crossDatasetTypeDef.preview)) {
            problems.push(error("Missing required preview config for the referenced type \"".concat(crossDatasetTypeDef.type || '<unknown type>', "\""), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
        validateExperimentalSearch(crossDatasetTypeDef.__experimental_search).forEach(function (err) {
            problems.push(error("Invalid \"__experimental_search\" config for referenced type \"".concat(crossDatasetTypeDef.type || '<unknown type>', "\": ").concat(err), HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        });
    });
    if (typeof typeDef.tokenId === 'string') {
        var validationResult = isValidTokenId(typeDef.tokenId);
        if (validationResult !== true) {
            problems.push(error(validationResult, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
    }
    if (typeof typeDef.projectId !== 'string') {
        problems.push(error('A cross dataset reference must specify a `projectId`', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (typeof typeDef.dataset === 'string') {
        var datasetValidation = isValidDatasetName(typeDef.dataset);
        if (datasetValidation !== true) {
            problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
    }
    else {
        problems.push(error('A cross dataset reference must specify a `dataset`', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {
        problems.push(error('The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(getOptionErrors(typeDef)), false));
    return tslib_es6.__assign(tslib_es6.__assign({}, typeDef), { _problems: problems });
});
function getOptionErrors(typeDef) {
    var options = typeDef.options;
    var problems = [];
    problems.push.apply(problems, tslib_es6.__spreadArray([], tslib_es6.__read(['filter', 'filterParams']
        .filter(function (key) { return key in typeDef; })
        .map(function (key) {
        return error("`".concat(key, "` is not allowed on a reference type definition - did you mean `options.").concat(key, "`?"), HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION);
    })), false));
    if (!options) {
        return problems;
    }
    if (!lodash.isPlainObject(options)) {
        return problems.concat(error('The reference type expects `options` to be an object', HELP_IDS.REFERENCE_INVALID_OPTIONS));
    }
    if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {
        return problems.concat(error('`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.', HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
    }
    if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {
        return problems;
    }
    if (typeof options.filter !== 'string') {
        return problems.concat(error("If set, `filter` must be a string. Got ".concat(typeof options.filter)));
    }
    if (typeof options.filterParams !== 'undefined' && !lodash.isPlainObject(options.filterParams)) {
        return problems.concat(error("If set, `filterParams` must be an object."));
    }
    if (options.filterParams) {
        return problems.concat(Object.keys(options.filterParams)
            .filter(function (key) { return key.startsWith('__') || key.startsWith('$'); })
            .map(function (key) { return error("Filter parameter cannot be prefixed with \"$\" or \"__\". Got ".concat(key, "\".")); }));
    }
    return problems;
}

var typeVisitors = {
    array: array,
    object: object,
    slug: slug,
    file: file,
    image: image,
    block: validateBlockType,
    document: documentVisitor,
    reference: reference,
    crossDatasetReference: crossDatasetReference,
};
var getNoopVisitor = function (visitorContext) { return function (schemaDef) { return (tslib_es6.__assign(tslib_es6.__assign({ name: "<unnamed_type_@_index_".concat(visitorContext.index, ">") }, schemaDef), { _problems: [] })); }; };
function combine() {
    var visitors = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        visitors[_i] = arguments[_i];
    }
    return function (schemaType, visitorContext) {
        return visitors.reduce(function (result, visitor) {
            var res = visitor(result, visitorContext);
            return tslib_es6.__assign(tslib_es6.__assign({}, res), { _problems: result._problems.concat(res._problems) });
        }, tslib_es6.__assign({ _problems: [] }, schemaType));
    };
}
/**
 * @internal
 */
function validateSchema(schemaTypes) {
    return traverseSanitySchema(schemaTypes, function (schemaDef, visitorContext) {
        var typeVisitor = (schemaDef && schemaDef.type && typeVisitors[schemaDef.type]) ||
            getNoopVisitor(visitorContext);
        if (visitorContext.isRoot) {
            return combine(rootType, common, typeVisitor)(schemaDef, visitorContext);
        }
        return combine(common, typeVisitor)(schemaDef, visitorContext);
    });
}

var ACTIONS_FLAG = '__experimental_actions';
var DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish'];
var VALID_ACTIONS = DEFAULT_ACTIONS;
var readActions = function (schemaType) {
    return ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS;
};
var validateActions = function (typeName, actions) {
    if (!Array.isArray(actions)) {
        throw new Error("The value of <type>.".concat(ACTIONS_FLAG, " should be an array with any of the actions ").concat(VALID_ACTIONS.join(', ')));
    }
    var invalid = lodash.difference(actions, VALID_ACTIONS);
    if (invalid.length > 0) {
        throw new Error("Invalid action".concat(invalid.length > 1 ? 's' : '', " configured for schema type \"").concat(typeName, "\": ").concat(invalid.join(', '), ". Valid actions are: ").concat(VALID_ACTIONS.join(', ')));
    }
    return actions;
};
var resolveEnabledActions = function (schemaType) {
    return validateActions(schemaType.name, readActions(schemaType));
};
var isActionEnabled = function (schemaType, action) {
    return resolveEnabledActions(schemaType).includes(action);
};

exports.groupProblems = groupProblems;
exports.isActionEnabled = isActionEnabled;
exports.validateSchema = validateSchema;
//# sourceMappingURL=_internal.cjs.map
