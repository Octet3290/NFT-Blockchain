var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { omit, isPlainObject } from 'lodash';
import humanizeList from 'humanize-list';
import { error, warning } from '../createValidationResult';
import { isJSONTypeOf } from '../utils/isJSONTypeOf';
var getTypeOf = function (thing) { return (Array.isArray(thing) ? 'array' : typeof thing); };
var quote = function (str) { return "\"".concat(str, "\""); };
var allowedKeys = [
    'lists',
    'marks',
    'name',
    'of',
    'options',
    'styles',
    'title',
    'type',
    'validation',
];
var allowedMarkKeys = ['decorators', 'annotations'];
var allowedStyleKeys = ['title', 'value', 'blockEditor'];
var allowedDecoratorKeys = ['title', 'value', 'blockEditor', 'icon'];
export default function validateBlockType(typeDef, visitorContext) {
    var problems = [];
    var styles = typeDef.styles;
    var marks = typeDef.marks;
    var members = typeDef.of;
    var disallowedKeys = Object.keys(typeDef).filter(function (key) { return !allowedKeys.includes(key) && !key.startsWith('_'); });
    if (disallowedKeys.length > 0) {
        problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList(disallowedKeys.map(quote)))));
    }
    if (marks) {
        marks = validateMarks(typeDef.marks, visitorContext, problems);
    }
    if (styles) {
        styles = validateStyles(styles, visitorContext, problems);
    }
    if (members) {
        members = validateMembers(members, visitorContext, problems);
    }
    return __assign(__assign({}, omit(typeDef, disallowedKeys)), { marks: marks, styles: styles, of: members, _problems: problems });
}
function validateMarks(marks, visitorContext, problems) {
    var decorators = marks.decorators;
    var annotations = marks.annotations;
    if (!isPlainObject(marks)) {
        problems.push(error("\"marks\" declaration should be an object, got ".concat(getTypeOf(marks))));
        return problems;
    }
    var disallowedMarkKeys = Object.keys(marks).filter(function (key) { return !allowedMarkKeys.includes(key) && !key.startsWith('_'); });
    if (disallowedMarkKeys.length > 0) {
        problems.push(error("Found unknown properties for block declaration: ".concat(humanizeList(disallowedMarkKeys.map(quote)))));
    }
    if (decorators && !Array.isArray(decorators)) {
        problems.push(error("\"marks.decorators\" declaration should be an array, got ".concat(getTypeOf(decorators))));
    }
    else if (decorators) {
        decorators = validateDecorators(decorators, visitorContext, problems);
    }
    if (annotations && !Array.isArray(annotations)) {
        problems.push(error("\"marks.annotations\" declaration should be an array, got ".concat(getTypeOf(annotations))));
    }
    else if (annotations) {
        annotations = validateAnnotations(annotations, visitorContext, problems);
    }
    return __assign(__assign({}, marks), { decorators: decorators, annotations: annotations });
}
function validateStyles(styles, visitorContext, problems) {
    if (!Array.isArray(styles)) {
        problems.push(error("\"styles\" declaration should be an array, got ".concat(getTypeOf(styles))));
        return problems;
    }
    styles.forEach(function (style, index) {
        if (!isPlainObject(style)) {
            problems.push(error("Style must be an object, got ".concat(getTypeOf(style))));
            return;
        }
        var name = style.value || "#".concat(index);
        var disallowedKeys = Object.keys(style).filter(function (key) { return !allowedStyleKeys.includes(key) && !key.startsWith('_'); });
        if (disallowedKeys.length > 0) {
            problems.push(error("Found unknown properties for style ".concat(name, ": ").concat(humanizeList(disallowedKeys.map(quote)))));
        }
        if (!style.value) {
            problems.push(error("Style #".concat(index, " is missing required \"value\" property")));
        }
        else if (typeof style.value !== 'string') {
            problems.push(error("Style #".concat(index, " has an invalid \"value\" property, expected string, got ").concat(getTypeOf(style.value))));
        }
        else if (!style.title) {
            problems.push(warning("Style ".concat(name, " is missing recommended \"title\" property")));
        }
    });
    return styles;
}
function validateDecorators(decorators, visitorContext, problems) {
    decorators.forEach(function (decorator, index) {
        if (!isPlainObject(decorator)) {
            problems.push(error("Annotation must be an object, got ".concat(getTypeOf(decorator))));
            return;
        }
        var name = decorator.value || "#".concat(index);
        var disallowedKeys = Object.keys(decorator).filter(function (key) { return !allowedDecoratorKeys.includes(key) && !key.startsWith('_'); });
        if (disallowedKeys.length > 0) {
            problems.push(error("Found unknown properties for decorator ".concat(name, ": ").concat(humanizeList(disallowedKeys.map(quote)))));
        }
        if (!decorator.value) {
            problems.push(error("Decorator #".concat(index, " is missing required \"value\" property")));
        }
        else if (typeof decorator.value !== 'string') {
            problems.push(error("Decorator #".concat(index, " has an invalid \"value\" property, expected string, got ").concat(getTypeOf(decorator.value))));
        }
        else if (!decorator.title) {
            problems.push(warning("Decorator ".concat(name, " is missing recommended \"title\" property")));
        }
    });
    return decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
    return annotations.map(function (annotation) {
        if (!isPlainObject(annotation)) {
            return __assign(__assign({}, annotation), { _problems: [error("Annotation must be an object, got ".concat(getTypeOf(annotation)))] });
        }
        var _problems = visitorContext.visit(annotation, visitorContext)._problems;
        var targetType = annotation.type && visitorContext.getType(annotation.type);
        if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {
            _problems.push(error("Annotation cannot have type \"".concat(annotation.type, "\" - annotation types must inherit from object")));
        }
        return __assign(__assign({}, annotation), { _problems: _problems });
    });
}
function validateMembers(members, visitorContext, problems) {
    if (!Array.isArray(members)) {
        problems.push(error("\"of\" declaration should be an array, got ".concat(getTypeOf(members))));
        return undefined;
    }
    return members.map(function (member) {
        var _problems = visitorContext.visit(member, visitorContext)._problems;
        return __assign(__assign({}, member), { _problems: _problems });
    });
}
//# sourceMappingURL=block.js.map