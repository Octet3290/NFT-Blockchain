var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { flatten } from 'lodash';
import { findBlockType } from '../util/findBlockType';
import { resolveJsType } from '../util/resolveJsType';
import { createRules } from './rules';
import { createRuleOptions, defaultParseHtml, ensureRootIsBlocks, flattenNestedBlocks, trimWhitespace, preprocess, tagName, isNodeList, isMinimalSpan, isPlaceholderDecorator, isPlaceholderAnnotation, isMinimalBlock, } from './helpers';
/**
 * HTML Deserializer
 *
 */
var HtmlDeserializer = /** @class */ (function () {
    /**
     * Create a new serializer respecting a Sanity block content type's schema
     *
     * @param blockContentType - Schema type for array containing _at least_ a block child type
     * @param options - Options for the deserialization process
     */
    function HtmlDeserializer(blockContentType, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._markDefs = [];
        /**
         * Deserialize HTML.
         *
         * @param html - The HTML to deserialize, as a string
         * @returns Array of blocks - either portable text blocks or other allowed blocks
         */
        this.deserialize = function (html) {
            _this._markDefs = [];
            var parseHtml = _this.parseHtml;
            var fragment = parseHtml(html);
            var children = Array.from(fragment.childNodes);
            // Ensure that there are no blocks within blocks, and trim whitespace
            var blocks = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(_this.deserializeElements(children))));
            if (_this._markDefs.length > 0) {
                blocks
                    .filter(function (block) { return block._type === 'block'; })
                    .forEach(function (block) {
                    block.markDefs = block.markDefs || [];
                    block.markDefs = block.markDefs.concat(_this._markDefs.filter(function (def) {
                        return flatten(block.children.map(function (child) { return child.marks || []; })).includes(def._key);
                    }));
                });
            }
            // Set back the potentially hoisted block type
            var type = _this.blockContentType.of.find(findBlockType);
            if (!type) {
                return blocks;
            }
            return blocks.map(function (block) {
                if (block._type === 'block') {
                    block._type = type.name;
                }
                return block;
            });
        };
        /**
         * Deserialize an array of DOM elements.
         *
         * @param elements - Array of DOM elements to deserialize
         * @returns
         */
        this.deserializeElements = function (elements) {
            if (elements === void 0) { elements = []; }
            var nodes = [];
            elements.forEach(function (element) {
                nodes = nodes.concat(_this.deserializeElement(element));
            });
            return nodes;
        };
        /**
         * Deserialize a DOM element
         *
         * @param element - Deserialize a DOM element
         * @returns
         */
        this.deserializeElement = function (element) {
            var _a, _b;
            var next = function (elements) {
                if (isNodeList(elements)) {
                    return _this.deserializeElements(Array.from(elements));
                }
                if (Array.isArray(elements)) {
                    return _this.deserializeElements(elements);
                }
                if (!elements) {
                    return undefined;
                }
                return _this.deserializeElement(elements);
            };
            var block = function (props) {
                return {
                    _type: '__block',
                    block: props,
                };
            };
            var node;
            var _loop_1 = function (i) {
                var rule = _this.rules[i];
                if (!rule.deserialize) {
                    return "continue";
                }
                var ret = rule.deserialize(element, next, block);
                var type = resolveJsType(ret);
                if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {
                    throw new Error("A rule returned an invalid deserialized representation: \"".concat(node, "\"."));
                }
                if (ret === undefined) {
                    return "continue";
                }
                else if (ret === null) {
                    throw new Error('Deserializer rule returned `null`');
                }
                else if (Array.isArray(ret)) {
                    node = ret;
                }
                else if (isPlaceholderDecorator(ret)) {
                    node = _this.deserializeDecorator(ret);
                }
                else if (isPlaceholderAnnotation(ret)) {
                    node = _this.deserializeAnnotation(ret);
                }
                else {
                    node = ret;
                }
                // Set list level on list item
                if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {
                    var parent_1 = (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode;
                    while (parent_1 && tagName(parent_1) === 'li') {
                        parent_1 = (_b = parent_1.parentNode) === null || _b === void 0 ? void 0 : _b.parentNode;
                        ret.level = ret.level ? ret.level + 1 : 1;
                    }
                }
                // Set newlines on spans orginating from a block element within a blockquote
                if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {
                    ret.children.forEach(function (child, index) {
                        if (isMinimalSpan(child) && child.text === '\r') {
                            child.text = '\n\n';
                            if (index === 0 || index === ret.children.length - 1) {
                                ret.children.splice(index, 1);
                            }
                        }
                    });
                }
                return "break";
            };
            for (var i = 0; i < _this.rules.length; i++) {
                var state_1 = _loop_1(i);
                if (state_1 === "break")
                    break;
            }
            return node || next(element.childNodes) || [];
        };
        /**
         * Deserialize a `__decorator` type
         * (an internal made up type to process decorators exclusively)
         *
         * @param decorator -
         * @returns array of ...
         */
        this.deserializeDecorator = function (decorator) {
            var name = decorator.name;
            var applyDecorator = function (node) {
                if (isPlaceholderDecorator(node)) {
                    return _this.deserializeDecorator(node);
                }
                else if (isMinimalSpan(node)) {
                    node.marks = node.marks || [];
                    if (node.text.trim()) {
                        // Only apply marks if this is an actual text
                        node.marks.unshift(name);
                    }
                }
                else if ('children' in node && Array.isArray(node.children)) {
                    var block = node;
                    block.children = block.children.map(applyDecorator);
                }
                return node;
            };
            return decorator.children.reduce(function (children, node) {
                var ret = applyDecorator(node);
                if (Array.isArray(ret)) {
                    return children.concat(ret);
                }
                children.push(ret);
                return children;
            }, []);
        };
        /**
         * Deserialize a `__annotation` object.
         * (an internal made up type to process annotations exclusively)
         *
         * @param annotation -
         * @returns Array of...
         */
        this.deserializeAnnotation = function (annotation) {
            var markDef = annotation.markDef;
            _this._markDefs.push(markDef);
            var applyAnnotation = function (node) {
                if (isPlaceholderAnnotation(node)) {
                    return _this.deserializeAnnotation(node);
                }
                else if (isMinimalSpan(node)) {
                    node.marks = node.marks || [];
                    if (node.text.trim()) {
                        // Only apply marks if this is an actual text
                        node.marks.unshift(markDef._key);
                    }
                }
                else if ('children' in node && Array.isArray(node.children)) {
                    var block = node;
                    block.children = block.children.map(applyAnnotation);
                }
                return node;
            };
            return annotation.children.reduce(function (children, node) {
                var ret = applyAnnotation(node);
                if (Array.isArray(ret)) {
                    return children.concat(ret);
                }
                children.push(ret);
                return children;
            }, []);
        };
        var _a = options.rules, rules = _a === void 0 ? [] : _a;
        if (!blockContentType) {
            throw new Error("Parameter 'blockContentType' is required");
        }
        var standardRules = createRules(blockContentType, createRuleOptions(blockContentType));
        this.rules = __spreadArray(__spreadArray([], __read(rules), false), __read(standardRules), false);
        var parseHtml = options.parseHtml || defaultParseHtml();
        this.blockContentType = blockContentType;
        this.parseHtml = function (html) {
            var doc = preprocess(html, parseHtml);
            return doc.body;
        };
    }
    return HtmlDeserializer;
}());
export default HtmlDeserializer;
//# sourceMappingURL=index.js.map