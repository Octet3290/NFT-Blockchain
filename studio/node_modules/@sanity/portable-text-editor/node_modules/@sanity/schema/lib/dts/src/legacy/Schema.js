import * as types from './types';
function compileRegistry(schemaDef) {
    var registry = Object.assign(Object.create(null), types);
    var defsByName = schemaDef.types.reduce(function (acc, def) {
        if (acc[def.name]) {
            throw new Error("Duplicate type name added to schema: ".concat(def.name));
        }
        acc[def.name] = def;
        return acc;
    }, {});
    schemaDef.types.forEach(add);
    return registry;
    function ensure(typeName) {
        if (!registry[typeName]) {
            if (!defsByName[typeName]) {
                throw new Error("Unknown type: ".concat(typeName));
            }
            add(defsByName[typeName]);
        }
    }
    function extendMember(memberDef) {
        ensure(memberDef.type);
        return registry[memberDef.type].extend(memberDef, extendMember).get();
    }
    function add(typeDef) {
        ensure(typeDef.type);
        if (registry[typeDef.name]) {
            return;
        }
        registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
    }
}
/**
 * @beta
 */
var Schema = /** @class */ (function () {
    function Schema(schemaDef) {
        this._original = schemaDef;
        this._registry = compileRegistry(schemaDef);
    }
    Schema.compile = function (schemaDef) {
        return new Schema(schemaDef);
    };
    Object.defineProperty(Schema.prototype, "name", {
        get: function () {
            return this._original.name;
        },
        enumerable: false,
        configurable: true
    });
    Schema.prototype.get = function (name) {
        return this._registry[name] && this._registry[name].get();
    };
    Schema.prototype.has = function (name) {
        return name in this._registry;
    };
    Schema.prototype.getTypeNames = function () {
        return Object.keys(this._registry);
    };
    return Schema;
}());
export default Schema;
//# sourceMappingURL=Schema.js.map