var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/* eslint-disable max-statements */
/* eslint-disable complexity */
import { Editor, Transforms, Path, Range } from 'slate';
import isHotkey from 'is-hotkey';
import { debugWithName } from '../../utils/debug';
import { toSlateValue } from '../../utils/values';
var debug = debugWithName('plugin:withHotKeys');
var DEFAULT_HOTKEYS = {
    marks: {
        'mod+b': 'strong',
        'mod+i': 'em',
        'mod+u': 'underline',
        "mod+'": 'code',
    },
    custom: {},
};
/**
 * This plugin takes care of all hotkeys in the editor
 *
 */
export function createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeysFromOptions) {
    var reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end'];
    var activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS; // TODO: Merge where possible? A union?
    var createEmptyBlock = function () {
        return toSlateValue([
            {
                _type: portableTextFeatures.types.block.name,
                _key: keyGenerator(),
                style: 'normal',
                markDefs: [],
                children: [
                    {
                        _type: 'span',
                        _key: keyGenerator(),
                        text: '',
                        marks: [],
                    },
                ],
            },
        ], portableTextEditor)[0];
    };
    return function withHotKeys(editor) {
        editor.pteWithHotKeys = function (event) {
            var _a;
            // Wire up custom marks hotkeys
            Object.keys(activeHotkeys).forEach(function (cat) {
                if (cat === 'marks') {
                    // eslint-disable-next-line guard-for-in
                    for (var hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            event.preventDefault();
                            var possibleMark = activeHotkeys[cat];
                            if (possibleMark) {
                                var mark = possibleMark[hotkey];
                                debug("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                                editor.pteToggleMark(mark);
                            }
                        }
                    }
                }
                if (cat === 'custom') {
                    // eslint-disable-next-line guard-for-in
                    for (var hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            var possibleCommand = activeHotkeys[cat];
                            if (possibleCommand) {
                                var command = possibleCommand[hotkey];
                                command(event, portableTextEditor);
                            }
                        }
                    }
                }
            });
            var isEnter = isHotkey('enter', event.nativeEvent);
            var isTab = isHotkey('tab', event.nativeEvent);
            var isShiftEnter = isHotkey('shift+enter', event.nativeEvent);
            var isShiftTab = isHotkey('shift+tab', event.nativeEvent);
            var isBackspace = isHotkey('backspace', event.nativeEvent);
            var isDelete = isHotkey('delete', event.nativeEvent);
            // Disallow deleting void blocks by backspace from another line.
            // Otherwise it's so easy to delete the void block above when trying to delete text on
            // the line below or above
            if (isBackspace &&
                editor.selection &&
                editor.selection.focus.path[0] > 0 &&
                Range.isCollapsed(editor.selection)) {
                var _b = __read(Editor.node(editor, Path.previous(editor.selection.focus.path.slice(0, 1))), 2), prevBlock = _b[0], prevPath = _b[1];
                var _c = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 1), focusBlock_1 = _c[0];
                if (prevBlock &&
                    focusBlock_1 &&
                    Editor.isVoid(editor, prevBlock) &&
                    editor.selection.focus.offset === 0) {
                    debug('Preventing deleting void block above');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: function (n) { return n === focusBlock_1; } });
                    Transforms.select(editor, prevPath);
                    editor.onChange();
                    return;
                }
            }
            if (isDelete &&
                editor.selection &&
                editor.selection.focus.offset === 0 &&
                Range.isCollapsed(editor.selection) &&
                editor.children[editor.selection.focus.path[0] + 1]) {
                var _d = __read(Editor.node(editor, Path.next(editor.selection.focus.path.slice(0, 1))), 1), nextBlock = _d[0];
                var _e = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 2), focusBlock_2 = _e[0], focusBlockPath = _e[1];
                if (nextBlock &&
                    focusBlock_2 &&
                    !Editor.isVoid(editor, focusBlock_2) &&
                    Editor.isVoid(editor, nextBlock)) {
                    debug('Preventing deleting void block below');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: function (n) { return n === focusBlock_2; } });
                    Transforms.select(editor, focusBlockPath);
                    editor.onChange();
                    return;
                }
            }
            // Tab for lists
            if (isTab || isShiftTab) {
                if (editor.pteIncrementBlockLevels(isShiftTab)) {
                    event.preventDefault();
                }
            }
            // Deal with enter key combos
            if (isEnter && !isShiftEnter && editor.selection) {
                var focusBlock = void 0;
                try {
                    ;
                    _a = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 1), focusBlock = _a[0];
                }
                catch (err) {
                    // Just ignore
                }
                // List item enter key
                if (editor.isListBlock(focusBlock)) {
                    if (editor.pteEndList()) {
                        event.preventDefault();
                    }
                    return;
                }
                // Enter from another style than the first (default one)
                if (editor.isTextBlock(focusBlock) &&
                    focusBlock.style &&
                    focusBlock.style !== portableTextFeatures.styles[0].value) {
                    var _f = __read(Range.edges(editor.selection), 2), end = _f[1];
                    var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
                    if (endAtEndOfNode) {
                        Editor.insertNode(editor, createEmptyBlock());
                        event.preventDefault();
                        return;
                    }
                }
                // Block object enter key
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    Editor.insertNode(editor, createEmptyBlock());
                    event.preventDefault();
                    return;
                }
            }
            // Soft line breaks
            if (isShiftEnter) {
                event.preventDefault();
                editor.insertText('\n');
                return;
            }
            // Undo/redo
            if (isHotkey('mod+z', event.nativeEvent)) {
                event.preventDefault();
                editor.undo();
                return;
            }
            if (isHotkey('mod+y', event.nativeEvent) || isHotkey('mod+shift+z', event.nativeEvent)) {
                event.preventDefault();
                editor.redo();
            }
        };
        return editor;
    };
}
//# sourceMappingURL=createWithHotKeys.js.map