"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_RECENT_SEARCHES = void 0;
exports.createRecentSearchesStore = createRecentSearchesStore;

var _internal = require("@sanity/base/_internal");

var _versionedClient = require("../../../versionedClient");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SEARCH_TERMS_KEY = 'search-terms::recent';
var MAX_RECENT_SEARCHES = 5; // might come in handy in the future

exports.MAX_RECENT_SEARCHES = MAX_RECENT_SEARCHES;
var CURRENT_VERSION = 1;

var _versionedClient$conf = _versionedClient.versionedClient.config(),
    projectId = _versionedClient$conf.projectId,
    dataset = _versionedClient$conf.dataset;

function createRecentSearchesStore(schema, user) {
  if (!supportsLocalStorage || !user) {
    return undefined;
  }

  var lsKey = "".concat(SEARCH_TERMS_KEY, "__").concat(projectId, ":").concat(dataset, ":").concat(user.id);
  return {
    /**
     * Write a search term to Local Storage and return updated recent searches.
     */
    addSearchTerm: searchTerm => {
      var saveTerm = {
        created: new Date().toISOString(),
        terms: {
          query: searchTerm.query.trim(),
          typeNames: searchTerm.types.map(s => s.name)
        }
      };
      var comparator = JSON.stringify(saveTerm.terms);
      var newRecent = {
        version: CURRENT_VERSION,
        recentSearches: [saveTerm, ...getRecentStoredSearchTerms(lsKey).recentSearches.filter(r => {
          return JSON.stringify(r.terms) !== comparator;
        })].slice(0, MAX_RECENT_SEARCHES)
      };
      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms(lsKey, schema);
    },

    /**
     * Fetch all recent searches from Local Storage.
     * Invalid search terms will be filtered out and terms will be re-written to Local Storage.
     */
    getRecentSearchTerms: getRecentSearchTerms.bind(undefined, lsKey, schema),

    /**
     * Remove all search terms from Local Storage and return updated recent searches.
     */
    removeSearchTerms: () => {
      var searchTerms = getRecentStoredSearchTerms(lsKey);

      var newRecent = _objectSpread(_objectSpread({}, searchTerms), {}, {
        recentSearches: []
      });

      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms(lsKey, schema);
    },

    /**
     * Remove a search term from Local Storage and return updated recent searches.
     */
    removeSearchTermAtIndex: index => {
      var searchTerms = getRecentStoredSearchTerms(lsKey);

      if (index < 0 || index > searchTerms.recentSearches.length) {
        return getRecentSearchTerms(lsKey, schema);
      }

      var newRecent = _objectSpread(_objectSpread({}, searchTerms), {}, {
        recentSearches: [...searchTerms.recentSearches.slice(0, index), ...searchTerms.recentSearches.slice(index + 1)]
      });

      window.localStorage.setItem(lsKey, JSON.stringify(newRecent));
      return getRecentSearchTerms(lsKey, schema);
    }
  };
}
/**
 * Get the 'raw' stored search terms from Local Storage.
 * Stored search terms are the minimal representation of saved terms and only include schema names.
 */


function getRecentStoredSearchTerms(lsKey) {
  var recentString = supportsLocalStorage ? window.localStorage.getItem(lsKey) : undefined;
  return recentString ? JSON.parse(recentString) : {
    version: CURRENT_VERSION,
    recentSearches: []
  };
}
/**
 * Get a list of recent searches from Local Storage.
 * Recent searches contain full document schemas.
 */


function getRecentSearchTerms(lsKey, schema) {
  var storedSearchTerms = getRecentStoredSearchTerms(lsKey);
  return sanitizeStoredSearchTerms(schema, storedSearchTerms, lsKey).recentSearches.filter(r => !!r.terms).map(r => ({
    __recentTimestamp: new Date(r.created).getTime(),
    query: r.terms.query,
    types: r.terms.typeNames.map(typeName => schema.get(typeName)).filter(s => s && s.jsonType === 'object')
  }));
}
/**
 * Sanitize stored search terms - recent searches containing _any_ number of invalid document schemas are removed.
 * This mutates Local Storage if any invalid terms are found.
 */


function sanitizeStoredSearchTerms(studioSchema, storedSearchTerms, lsKey) {
  var searchableTypeNames = (0, _internal.getSearchableTypes)(studioSchema).map(schema => schema.name);
  var filteredSearchTerms = storedSearchTerms.recentSearches.filter(searchTerm => {
    return searchTerm.terms.typeNames.every(typeName => searchableTypeNames.includes(typeName));
  });
  var newStoredSearchTerms = {
    version: CURRENT_VERSION,
    recentSearches: filteredSearchTerms
  };

  if (newStoredSearchTerms.recentSearches.length < storedSearchTerms.recentSearches.length) {
    window.localStorage.setItem(lsKey, JSON.stringify(newStoredSearchTerms));
  }

  return getRecentStoredSearchTerms(lsKey);
}

var supportsLocalStorage = (() => {
  var key = '__tmp__can_use';

  try {
    if (typeof localStorage === 'undefined') {
      return false;
    }

    localStorage.setItem(key, '---');
    localStorage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
})();