var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { isEqual } from 'lodash';
import { Element, Text } from 'slate';
var EMPTY_MARKDEFS = [];
function keepObjectEquality(object, keyMap) {
    var value = keyMap[object._key];
    if (value && isEqual(object, value)) {
        return value;
    }
    keyMap[object._key] = object;
    return object;
}
export function toSlateValue(value, _a, keyMap) {
    var portableTextFeatures = _a.portableTextFeatures;
    if (keyMap === void 0) { keyMap = {}; }
    if (value && Array.isArray(value)) {
        return value.map(function (block) {
            var _type = block._type, _key = block._key, rest = __rest(block, ["_type", "_key"]);
            var voidChildren = [{ _key: "".concat(_key, "-void-child"), _type: 'span', text: '', marks: [] }];
            var isPortableText = block && block._type === portableTextFeatures.types.block.name;
            if (isPortableText) {
                var textBlock = block;
                var hasInlines_1 = false;
                var hasMissingStyle = typeof textBlock.style === 'undefined';
                var hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined';
                var children = textBlock.children.map(function (child) {
                    var cType = child._type, cKey = child._key, cRest = __rest(child, ["_type", "_key"]);
                    if (cType !== 'span') {
                        hasInlines_1 = true;
                        return keepObjectEquality({
                            _type: cType,
                            _key: cKey,
                            children: voidChildren,
                            value: cRest,
                            __inline: true,
                        }, keyMap);
                    }
                    // Original object
                    return child;
                });
                if (!hasMissingStyle && !hasMissingMarkDefs && !hasInlines_1 && Element.isElement(block)) {
                    // Original object
                    return block;
                }
                if (hasMissingStyle) {
                    rest.style = portableTextFeatures.styles[0].value;
                }
                if (hasMissingMarkDefs) {
                    rest.markDefs = EMPTY_MARKDEFS;
                }
                return keepObjectEquality(__assign(__assign({ _type: _type, _key: _key }, rest), { children: children }), keyMap);
            }
            return keepObjectEquality({
                _type: _type,
                _key: _key,
                children: voidChildren,
                value: rest,
            }, keyMap);
        });
    }
    return [];
}
export function fromSlateValue(value, textBlockType, keyMap) {
    if (keyMap === void 0) { keyMap = {}; }
    return value.map(function (block) {
        var _key = block._key, _type = block._type;
        if (!_key || !_type) {
            throw new Error('Not a valid block');
        }
        if (_type === textBlockType && 'children' in block && Array.isArray(block.children) && _key) {
            var hasInlines_2 = false;
            var children = block.children.map(function (child) {
                var _cType = child._type;
                if ('value' in child && _cType !== 'span') {
                    hasInlines_2 = true;
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var v = child.value, k = child._key, t = child._type, _i = child.__inline, _c = child.children, rest = __rest(child, ["value", "_key", "_type", "__inline", "children"]);
                    return keepObjectEquality(__assign(__assign(__assign({}, rest), v), { _key: k, _type: t }), keyMap);
                }
                return child;
            });
            if (!hasInlines_2) {
                return block; // Original object
            }
            return keepObjectEquality(__assign(__assign({}, block), { children: children, _key: _key, _type: _type }), keyMap);
        }
        var blockValue = 'value' in block && block.value;
        return keepObjectEquality(__assign({ _key: _key, _type: _type }, (typeof blockValue === 'object' ? blockValue : {})), keyMap);
    });
}
export function isEqualToEmptyEditor(children, portableTextFeatures) {
    return (children === undefined ||
        (children && Array.isArray(children) && children.length === 0) ||
        (children &&
            Array.isArray(children) &&
            children.length === 1 &&
            Element.isElement(children[0]) &&
            children[0]._type === portableTextFeatures.types.block.name &&
            'style' in children[0] &&
            children[0].style === portableTextFeatures.styles[0].value &&
            Array.isArray(children[0].children) &&
            children[0].children.length === 1 &&
            Text.isText(children[0].children[0]) &&
            children[0].children[0]._type === 'span' &&
            children[0].children[0].text === ''));
}
export function findBlockAndIndexFromPath(firstPathSegment, children) {
    var blockIndex = -1;
    var isNumber = Number.isInteger(Number(firstPathSegment));
    if (isNumber) {
        blockIndex = Number(firstPathSegment);
    }
    else if (children) {
        blockIndex = children.findIndex(function (blk) { return Element.isElement(blk) && isEqual({ _key: blk._key }, firstPathSegment); });
    }
    if (blockIndex > -1) {
        return [children[blockIndex], blockIndex];
    }
    return [undefined, -1];
}
export function findChildAndIndexFromPath(secondPathSegment, block) {
    var childIndex = -1;
    var isNumber = Number.isInteger(Number(secondPathSegment));
    if (isNumber) {
        childIndex = Number(secondPathSegment);
    }
    else {
        childIndex = block.children.findIndex(function (child) { return isEqual({ _key: child._key }, secondPathSegment); });
    }
    if (childIndex > -1) {
        return [block.children[childIndex], childIndex];
    }
    return [undefined, -1];
}
export function getValueOrInitialValue(value, initialValue) {
    if (value && Array.isArray(value) && value.length > 0) {
        return value;
    }
    return initialValue;
}
//# sourceMappingURL=values.js.map