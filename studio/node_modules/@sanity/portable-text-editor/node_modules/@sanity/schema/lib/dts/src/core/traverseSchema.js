import { flatten, uniq } from 'lodash';
import { getDupes } from '../sanity/validation/utils/getDupes';
var NOOP_VISITOR = function (typeDef) { return typeDef; };
var UnknownType = /** @class */ (function () {
    function UnknownType(name) {
        this.name = name;
    }
    return UnknownType;
}());
export { UnknownType };
var TYPE_TYPE = { name: 'type', type: null };
var FUTURE_RESERVED = ['any', 'time', 'date'];
export function traverseSchema(types, coreTypes, visitor) {
    if (types === void 0) { types = []; }
    if (coreTypes === void 0) { coreTypes = []; }
    if (visitor === void 0) { visitor = NOOP_VISITOR; }
    var coreTypesRegistry = Object.create(null);
    var registry = Object.create(null);
    var coreTypeNames = coreTypes.map(function (typeDef) { return typeDef.name; });
    var reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames);
    var typeNames = types.map(function (typeDef) { return typeDef && typeDef.name; }).filter(Boolean);
    coreTypes.forEach(function (coreType) {
        coreTypesRegistry[coreType.name] = coreType;
    });
    types.forEach(function (type, i) {
        // Allocate a placeholder for each type
        registry[(type && type.name) || "__unnamed_".concat(i)] = {};
    });
    function getType(typeName) {
        return typeName === 'type'
            ? TYPE_TYPE
            : coreTypesRegistry[typeName] || registry[typeName] || null;
    }
    var duplicateNames = uniq(flatten(getDupes(typeNames)));
    function isDuplicate(typeName) {
        return duplicateNames.includes(typeName);
    }
    function getTypeNames() {
        return typeNames.concat(coreTypeNames);
    }
    function isReserved(typeName) {
        return typeName === 'type' || reservedTypeNames.includes(typeName);
    }
    var visitType = function (isRoot) { return function (typeDef, index) {
        return visitor(typeDef, {
            visit: visitType(false),
            isRoot: isRoot,
            getType: getType,
            getTypeNames: getTypeNames,
            isReserved: isReserved,
            isDuplicate: isDuplicate,
            index: index,
        });
    }; };
    coreTypes.forEach(function (coreTypeDef) {
        Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
    });
    types.forEach(function (typeDef, i) {
        Object.assign(registry[(typeDef && typeDef.name) || "__unnamed_".concat(i)], visitType(true)(typeDef, i));
    });
    return {
        get: function (typeName) {
            var res = registry[typeName] || coreTypesRegistry[typeName];
            if (res) {
                return res;
            }
            throw new Error("No such type: ".concat(typeName));
        },
        has: function (typeName) {
            return typeName in registry || typeName in coreTypesRegistry;
        },
        getTypeNames: function () {
            return Object.keys(registry);
        },
        getTypes: function () {
            return this.getTypeNames().map(this.get);
        },
        toJSON: function () {
            return this.getTypes();
        },
    };
}
//# sourceMappingURL=traverseSchema.js.map