/* eslint-disable complexity */
/**
 *
 * This plugin will change Slate's default marks model (every prop is a mark) with the Portable Text model (marks is an array of strings on prop .marks).
 *
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { isEqual, flatten, uniq } from 'lodash';
import { Editor, Range, Transforms, Text, Path, Element } from 'slate';
import { debugWithName } from '../../utils/debug';
var debug = debugWithName('plugin:withPortableTextMarkModel');
export function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator) {
    return function withPortableTextMarkModel(editor) {
        var apply = editor.apply, normalizeNode = editor.normalizeNode;
        var decorators = portableTextFeatures.decorators.map(function (t) { return t.value; });
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks
        editor.normalizeNode = function (nodeEntry) {
            var e_1, _a;
            normalizeNode(nodeEntry);
            if (editor.operations.some(function (op) {
                return [
                    'insert_node',
                    'insert_text',
                    'merge_node',
                    'remove_node',
                    'remove_text',
                    'set_node',
                ].includes(op.type);
            })) {
                mergeSpans(editor);
            }
            var _b = __read(nodeEntry, 2), node = _b[0], path = _b[1];
            var isSpan = Text.isText(node) && node._type === portableTextFeatures.types.span.name;
            var isTextBlock = editor.isTextBlock(node);
            if (isSpan || isTextBlock) {
                if (!isTextBlock && !Array.isArray(node.marks)) {
                    debug('Adding .marks to span node');
                    Transforms.setNodes(editor, { marks: [] }, { at: path });
                    editor.onChange();
                }
                try {
                    for (var _c = __values(editor.operations), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var op = _d.value;
                        // Make sure markDefs are copied over when merging two blocks.
                        if (op.type === 'merge_node' &&
                            op.path.length === 1 &&
                            'markDefs' in op.properties &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0 &&
                            op.path[0] - 1 >= 0) {
                            var _e = __read(Editor.node(editor, [op.path[0] - 1]), 2), targetBlock = _e[0], targetPath = _e[1];
                            debug("Copying markDefs over to merged block", op);
                            if (editor.isTextBlock(targetBlock)) {
                                var oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                                var newMarkDefs = uniq(__spreadArray(__spreadArray([], __read(oldDefs), false), __read(op.properties.markDefs), false));
                                var isNormalized = isEqual(newMarkDefs, targetBlock.markDefs);
                                // eslint-disable-next-line max-depth
                                if (!isNormalized) {
                                    Transforms.setNodes(editor, { markDefs: newMarkDefs }, { at: targetPath, voids: false });
                                    editor.onChange();
                                }
                            }
                        }
                        // Make sure markDefs are copied over to new block when splitting a block.
                        if (op.type === 'split_node' &&
                            op.path.length === 1 &&
                            Element.isElementProps(op.properties) &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            'markDefs' in op.properties &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0 &&
                            op.path[0] + 1 < editor.children.length) {
                            var _f = __read(Editor.node(editor, [op.path[0] + 1]), 2), targetBlock = _f[0], targetPath = _f[1];
                            debug("Copying markDefs over to split block", op);
                            if (editor.isTextBlock(targetBlock)) {
                                var oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                                Transforms.setNodes(editor, { markDefs: uniq(__spreadArray(__spreadArray([], __read(oldDefs), false), __read(op.properties.markDefs), false)) }, { at: targetPath, voids: false });
                                editor.onChange();
                            }
                        }
                        // Make sure marks are reset, if a block is split at the end.
                        if (op.type === 'split_node' &&
                            op.path.length === 2 &&
                            op.properties._type === portableTextFeatures.types.span.name &&
                            'marks' in op.properties &&
                            Array.isArray(op.properties.marks) &&
                            op.properties.marks.length > 0 &&
                            op.path[0] + 1 < editor.children.length) {
                            var _g = __read(Editor.node(editor, [op.path[0] + 1, 0]), 2), child = _g[0], childPath = _g[1];
                            if (Text.isText(child) &&
                                child.text === '' &&
                                Array.isArray(child.marks) &&
                                child.marks.length > 0) {
                                Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: false });
                                editor.onChange();
                            }
                        }
                        // Make sure markDefs are reset, if a block is split at start.
                        if (op.type === 'split_node' &&
                            op.path.length === 1 &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            'markDefs' in op.properties &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0) {
                            var _h = __read(Editor.node(editor, [op.path[0]]), 2), block = _h[0], blockPath = _h[1];
                            if (editor.isTextBlock(block) &&
                                block.children.length === 1 &&
                                block.markDefs.length > 0 &&
                                Text.isText(block.children[0]) &&
                                block.children[0].text === '' &&
                                block.children[0].marks.length === 0) {
                                Transforms.setNodes(editor, { markDefs: [] }, { at: blockPath });
                                editor.onChange();
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // Empty marks if text is empty
                if (isSpan && Array.isArray(node.marks) && node.marks.length > 0 && node.text === '') {
                    Transforms.setNodes(editor, { marks: [] }, { at: path, voids: false });
                    editor.onChange();
                }
            }
            // Check consistency of markDefs
            if (isTextBlock &&
                editor.operations.some(function (op) {
                    return ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type);
                })) {
                normalizeMarkDefs(editor);
            }
        };
        // Special hook before inserting text at the end of an annotation.
        editor.apply = function (op) {
            var _a, _b;
            if (op.type === 'insert_text') {
                var selection = editor.selection;
                if (selection &&
                    Range.isCollapsed(selection) &&
                    ((_b = (_a = Editor.marks(editor)) === null || _a === void 0 ? void 0 : _a.marks) === null || _b === void 0 ? void 0 : _b.some(function (mark) { return !decorators.includes(mark); }))) {
                    var _c = __read(Array.from(Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: function (n) { return n._type === portableTextFeatures.types.span.name; },
                        voids: false,
                    }))[0] || [undefined], 1), node = _c[0];
                    if (Text.isText(node) &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        Transforms.splitNodes(editor, {
                            match: Text.isText,
                            at: __assign(__assign({}, selection.focus), { offset: selection.focus.offset }),
                        });
                        var marksWithoutAnnotationMarks = (__assign({}, (Editor.marks(editor) || {})).marks || []).filter(function (mark) { return decorators.includes(mark); });
                        Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: Path.next(selection.focus.path) });
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = function (mark) {
            if (editor.selection) {
                if (Range.isExpanded(editor.selection)) {
                    // Split if needed
                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                    // Use new selection
                    var splitTextNodes_1 = __spreadArray([], __read(Editor.nodes(editor, { at: editor.selection, match: Text.isText })), false);
                    var shouldRemoveMark = flatten(splitTextNodes_1.map(function (item) { return item[0]; }).map(function (node) { return node.marks; })).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    Editor.withoutNormalizing(editor, function () {
                        splitTextNodes_1.forEach(function (_a) {
                            var _b = __read(_a, 2), node = _b[0], path = _b[1];
                            var marks = __spreadArray(__spreadArray([], __read((Array.isArray(node.marks) ? node.marks : []).filter(function (eMark) { return eMark !== mark; })), false), [
                                mark,
                            ], false);
                            Transforms.setNodes(editor, { marks: marks }, { at: path, match: Text.isText, split: true, hanging: true });
                        });
                    });
                    Editor.normalize(editor);
                }
                else {
                    var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
                    var marks = __assign(__assign({}, (Editor.marks(editor) || {})), { marks: __spreadArray(__spreadArray([], __read(existingMarks), false), [mark], false) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = function (mark) {
            var selection = editor.selection;
            if (selection) {
                if (Range.isExpanded(selection)) {
                    Editor.withoutNormalizing(editor, function () {
                        // Split if needed
                        Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                        if (editor.selection) {
                            var splitTextNodes = __spreadArray([], __read(Editor.nodes(editor, { at: editor.selection, match: Text.isText })), false);
                            splitTextNodes.forEach(function (_a) {
                                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                                var block = editor.children[path[0]];
                                if (Element.isElement(block) && block.children.includes(node)) {
                                    Transforms.setNodes(editor, {
                                        marks: (Array.isArray(node.marks) ? node.marks : []).filter(function (eMark) { return eMark !== mark; }),
                                    }, { at: path });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                }
                else {
                    var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
                    var marks = __assign(__assign({}, (Editor.marks(editor) || {})), { marks: existingMarks.filter(function (eMark) { return eMark !== mark; }) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = function (mark) {
            if (!editor.selection || editor.selection.focus.path.length < 2) {
                return false;
            }
            var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
            if (Range.isExpanded(editor.selection)) {
                Array.from(Editor.nodes(editor, { match: Text.isText, at: editor.selection })).forEach(function (n) {
                    var _a = __read(n, 1), node = _a[0];
                    existingMarks = uniq(__spreadArray(__spreadArray([], __read(existingMarks), false), __read((node.marks || [])), false));
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = function (mark) {
            var isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug("Remove mark '".concat(mark, "'"));
                Editor.removeMark(editor, mark);
            }
            else {
                debug("Add mark '".concat(mark, "'"));
                Editor.addMark(editor, mark, true);
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     */
    function mergeSpans(editor) {
        var e_2, _a;
        var selection = editor.selection;
        if (selection) {
            try {
                for (var _b = __values(Array.from(Editor.nodes(editor, {
                    at: Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
                })).reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), node = _d[0], path = _d[1];
                    var _e = __read(path.length > 1 ? Editor.node(editor, Path.parent(path)) : [undefined], 1), parent_1 = _e[0];
                    var nextPath = [path[0], path[1] + 1];
                    if (Editor.isBlock(editor, parent_1)) {
                        var nextNode = parent_1.children[nextPath[1]];
                        if (Text.isText(node) && Text.isText(nextNode) && isEqual(nextNode.marks, node.marks)) {
                            debug('Merging spans');
                            Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                            editor.onChange();
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     */
    function normalizeMarkDefs(editor) {
        var e_3, _a;
        var selection = editor.selection;
        if (selection) {
            var blocks = Editor.nodes(editor, {
                at: selection,
                match: function (n) { return n._type === portableTextFeatures.types.block.name; },
            });
            var _loop_1 = function (block, path) {
                if (editor.isTextBlock(block)) {
                    var newMarkDefs = block.markDefs.filter(function (def) {
                        return block.children.find(function (child) {
                            return (Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key));
                        });
                    });
                    if (!isEqual(newMarkDefs, block.markDefs)) {
                        debug('Removing markDef not in use');
                        Transforms.setNodes(editor, {
                            markDefs: newMarkDefs,
                        }, { at: path });
                        editor.onChange();
                    }
                }
            };
            try {
                for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
                    var _b = __read(blocks_1_1.value, 2), block = _b[0], path = _b[1];
                    _loop_1(block, path);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
}
//# sourceMappingURL=createWithPortableTextMarkModel.js.map