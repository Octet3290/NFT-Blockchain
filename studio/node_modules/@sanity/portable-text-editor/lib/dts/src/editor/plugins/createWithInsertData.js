var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { Transforms, Editor, Range, Text } from 'slate';
import { htmlToBlocks, normalizeBlock } from '@sanity/block-tools';
import { ReactEditor } from '@sanity/slate-react';
import { fromSlateValue, toSlateValue } from '../../utils/values';
import { validateValue } from '../../utils/validateValue';
import { debugWithName } from '../../utils/debug';
var debug = debugWithName('plugin:withInsertData');
/**
 * This plugin handles copy/paste in the editor
 *
 */
export function createWithInsertData(change$, portableTextFeatures, keyGenerator) {
    return function withInsertData(editor) {
        var blockTypeName = portableTextFeatures.types.block.name;
        var spanTypeName = portableTextFeatures.types.span.name;
        var toPlainText = function (blocks) {
            return blocks
                .map(function (block) {
                var _a;
                if (block._type === blockTypeName) {
                    return block.children
                        .map(function (child) {
                        var _a;
                        if (child._type === spanTypeName) {
                            return child.text;
                        }
                        return "[".concat(((_a = portableTextFeatures.types.inlineObjects.find(function (t) { return t.name === child._type; })) === null || _a === void 0 ? void 0 : _a.title) || 'Object', "]");
                    })
                        .join('');
                }
                return "[".concat(((_a = portableTextFeatures.types.blockObjects.find(function (t) { return t.name === block._type; })) === null || _a === void 0 ? void 0 : _a.title) ||
                    'Object', "]");
            })
                .join('\n\n');
        };
        editor.setFragmentData = function (data, originEvent) {
            var selection = editor.selection;
            if (!selection) {
                return;
            }
            var _a = __read(Range.edges(selection), 2), start = _a[0], end = _a[1];
            var startVoid = Editor.void(editor, { at: start.path });
            var endVoid = Editor.void(editor, { at: end.path });
            if (Range.isCollapsed(selection) && !startVoid) {
                return;
            }
            // Create a fake selection so that we can add a Base64-encoded copy of the
            // fragment to the HTML, to decode on future pastes.
            var domRange = ReactEditor.toDOMRange(editor, selection);
            var contents = domRange.cloneContents();
            // COMPAT: If the end node is a void node, we need to move the end of the
            // range from the void node's spacer span, to the end of the void node's
            // content, since the spacer is before void's content in the DOM.
            if (endVoid) {
                var _b = __read(endVoid, 1), voidNode = _b[0];
                var r = domRange.cloneRange();
                var domNode = ReactEditor.toDOMNode(editor, voidNode);
                r.setEndAfter(domNode);
                contents = r.cloneContents();
            }
            // Remove any zero-width space spans from the cloned DOM so that they don't
            // show up elsewhere when pasted.
            Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {
                var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
                zw.textContent = isNewline ? '\n' : '';
            });
            // Clean up the clipboard HTML for editor spesific attributes
            Array.from(contents.querySelectorAll('*')).forEach(function (elm) {
                elm.removeAttribute('contentEditable');
                elm.removeAttribute('data-slate-inline');
                elm.removeAttribute('data-slate-leaf');
                elm.removeAttribute('data-slate-node');
                elm.removeAttribute('data-slate-spacer');
                elm.removeAttribute('data-slate-string');
                elm.removeAttribute('data-slate-zero-width');
                elm.removeAttribute('draggable');
                for (var key in elm.attributes) {
                    if (elm.hasAttribute(key)) {
                        elm.removeAttribute(key);
                    }
                }
            });
            var div = contents.ownerDocument.createElement('div');
            div.appendChild(contents);
            div.setAttribute('hidden', 'true');
            contents.ownerDocument.body.appendChild(div);
            var asHTML = div.innerHTML;
            contents.ownerDocument.body.removeChild(div);
            var fragment = editor.getFragment();
            var portableText = fromSlateValue(fragment, portableTextFeatures.types.block.name);
            var asJSON = JSON.stringify(portableText);
            var asPlainText = toPlainText(portableText);
            data.clearData();
            data.setData('text/plain', asPlainText);
            data.setData('text/html', asHTML);
            data.setData('application/json', asJSON);
            data.setData('application/x-portable-text', asJSON);
            debug('text', asPlainText);
            data.setData('application/x-portable-text-event-origin', originEvent || 'external');
            debug('Set fragment data', asJSON, asHTML);
        };
        editor.insertPortableTextData = function (data) {
            var _a;
            if (!editor.selection) {
                return false;
            }
            var pText = data.getData('application/x-portable-text');
            var origin = data.getData('application/x-portable-text-event-origin');
            debug("Inserting portable text from ".concat(origin, " event"), pText);
            if (pText) {
                var parsed = JSON.parse(pText);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    var slateValue = regenerateKeys(editor, toSlateValue(parsed, { portableTextFeatures: portableTextFeatures }), keyGenerator, spanTypeName);
                    // Validate the result
                    var validation = validateValue(parsed, portableTextFeatures, keyGenerator);
                    // Bail out if it's not valid
                    if (!validation.valid) {
                        var errorDescription = "".concat((_a = validation.resolution) === null || _a === void 0 ? void 0 : _a.description);
                        change$.next({
                            type: 'error',
                            level: 'warning',
                            name: 'pasteError',
                            description: errorDescription,
                            data: validation,
                        });
                        debug('Invalid insert result', validation);
                        return false;
                    }
                    mixMarkDefs(editor, slateValue);
                    editor.insertFragment(slateValue);
                    editor.onChange();
                    return true;
                }
            }
            return false;
        };
        editor.insertTextOrHTMLData = function (data) {
            var _a;
            if (!editor.selection) {
                debug('No selection, not inserting');
                return false;
            }
            change$.next({ type: 'loading', isLoading: true }); // This could potentially take some time
            var html = data.getData('text/html');
            var text = data.getData('text/plain');
            if (html || text) {
                debug('Inserting data', data);
                var portableText = void 0;
                var fragment = void 0;
                var insertedType = void 0;
                if (html) {
                    portableText = htmlToBlocks(html, portableTextFeatures.types.portableText).map(function (block) {
                        return normalizeBlock(block, { blockTypeName: blockTypeName });
                    });
                    fragment = toSlateValue(portableText, { portableTextFeatures: portableTextFeatures });
                    insertedType = 'HTML';
                }
                else {
                    // plain text
                    var blocks = escapeHtml(text)
                        .split(/\n{2,}/)
                        .map(function (line) {
                        return line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, '<br/>'), "</p>") : '<p></p>';
                    })
                        .join('');
                    var textToHtml = "<html><body>".concat(blocks, "</body></html>");
                    portableText = htmlToBlocks(textToHtml, portableTextFeatures.types.portableText).map(function (block) { return normalizeBlock(block, { blockTypeName: blockTypeName }); });
                    fragment = toSlateValue(portableText, {
                        portableTextFeatures: portableTextFeatures,
                    });
                    insertedType = 'text';
                }
                // Validate the result
                var validation = validateValue(portableText, portableTextFeatures, keyGenerator);
                // Bail out if it's not valid
                if (!validation.valid) {
                    var errorDescription = "Could not validate the resulting portable text to insert.\n".concat((_a = validation.resolution) === null || _a === void 0 ? void 0 : _a.description, "\nTry to insert as plain text (shift-paste) instead.");
                    change$.next({
                        type: 'error',
                        level: 'warning',
                        name: 'pasteError',
                        description: errorDescription,
                        data: validation,
                    });
                    debug('Invalid insert result', validation);
                    return false;
                }
                debug("Inserting ".concat(insertedType, " fragment at ").concat(JSON.stringify(editor.selection)));
                mixMarkDefs(editor, fragment);
                editor.insertFragment(fragment);
                editor.onChange();
                change$.next({ type: 'loading', isLoading: false });
                return true;
            }
            change$.next({ type: 'loading', isLoading: false });
            return false;
        };
        editor.insertData = function (data) {
            if (!editor.insertPortableTextData(data)) {
                editor.insertTextOrHTMLData(data);
            }
        };
        editor.insertFragmentData = function (data) {
            var fragment = data.getData('application/x-portable-text');
            if (fragment) {
                var parsed = JSON.parse(fragment);
                editor.insertFragment(parsed);
                return true;
            }
            return false;
        };
        return editor;
    };
}
var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;',
};
function escapeHtml(str) {
    return String(str).replace(/[&<>"'`=/]/g, function (s) { return entityMap[s]; });
}
function regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
    return fragment.map(function (node) {
        var newNode = __assign({}, node);
        // Ensure the copy has new keys
        if (editor.isTextBlock(newNode)) {
            newNode.markDefs = newNode.markDefs.map(function (def) {
                var oldKey = def._key;
                var newKey = keyGenerator();
                if (Array.isArray(newNode.children)) {
                    newNode.children = newNode.children.map(function (child) {
                        return child._type === spanTypeName && Text.isText(child)
                            ? __assign(__assign({}, child), { marks: child.marks && child.marks.includes(oldKey)
                                    ? // eslint-disable-next-line max-nested-callbacks
                                        __spreadArray([], __read(child.marks), false).filter(function (mark) { return mark !== oldKey; }).concat(newKey)
                                    : child.marks }) : child;
                    });
                }
                return __assign(__assign({}, def), { _key: newKey });
            });
        }
        var nodeWithNewKeys = __assign(__assign({}, newNode), { _key: keyGenerator() });
        if (editor.isTextBlock(nodeWithNewKeys)) {
            nodeWithNewKeys.children = nodeWithNewKeys.children.map(function (child) { return (__assign(__assign({}, child), { _key: keyGenerator() })); });
        }
        return nodeWithNewKeys;
    });
}
function mixMarkDefs(editor, fragment) {
    if (!editor.selection) {
        return false;
    }
    var _a = __read(Editor.node(editor, editor.selection, { depth: 1 }), 2), focusBlock = _a[0], focusPath = _a[1];
    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
        var markDefs = focusBlock.markDefs;
        debug('Mixing markDefs of focusBlock and fragments[0] block', markDefs, fragment[0].markDefs);
        // As the first block will be inserted into another block (potentially), mix those markDefs
        Transforms.setNodes(editor, {
            markDefs: __spreadArray(__spreadArray([], __read(fragment[0].markDefs), false), __read(markDefs), false),
        }, { at: focusPath, mode: 'lowest', voids: false });
        return true;
    }
    return false;
}
//# sourceMappingURL=createWithInsertData.js.map