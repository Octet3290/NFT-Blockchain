var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React, { useCallback } from 'react';
import { Range, Text } from 'slate';
import { useSelected, useSlateStatic } from '@sanity/slate-react';
import { uniq } from 'lodash';
import { debugWithName } from '../utils/debug';
import { DefaultAnnotation } from './nodes/DefaultAnnotation';
import { DraggableChild } from './DraggableChild';
var debug = debugWithName('components:Leaf');
var debugRenders = false;
export var Leaf = function (props) {
    var editor = useSlateStatic();
    var selected = useSelected();
    var attributes = props.attributes, children = props.children, leaf = props.leaf, portableTextFeatures = props.portableTextFeatures, keyGenerator = props.keyGenerator, renderChild = props.renderChild, readOnly = props.readOnly;
    var spanRef = React.useRef(null);
    var returnedChildren = children;
    var focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    var handleMouseDown = useCallback(function (event) {
        // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
        if (focused) {
            event.stopPropagation();
            event.preventDefault();
        }
    }, [focused]);
    if (Text.isText(leaf) && leaf._type === portableTextFeatures.types.span.name) {
        var blockElement_1 = children.props.parent;
        var path_1 = blockElement_1 ? [{ _key: blockElement_1._key }, 'children', { _key: leaf._key }] : [];
        var decoratorValues_1 = portableTextFeatures.decorators.map(function (dec) { return dec.value; });
        var marks = uniq((Array.isArray(leaf.marks) ? leaf.marks : []).filter(function (mark) { return decoratorValues_1.includes(mark); }));
        marks.forEach(function (mark) {
            var _a, _b;
            var type = portableTextFeatures.decorators.find(function (dec) { return dec.value === mark; });
            if (type) {
                // TODO: look into this API!
                if ((_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render) {
                    var CustomComponent = (_b = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _b === void 0 ? void 0 : _b.render;
                    returnedChildren = React.createElement(CustomComponent, { mark: mark }, returnedChildren);
                }
                if (props.renderDecorator) {
                    returnedChildren = props.renderDecorator(mark, type, { focused: focused, selected: selected, path: path_1 }, function () { return React.createElement(React.Fragment, null, returnedChildren); }, spanRef);
                }
            }
        });
        var annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : [];
        var annotations_1 = annotationMarks
            .map(function (mark) {
            return !decoratorValues_1.includes(mark) &&
                blockElement_1 &&
                blockElement_1.markDefs &&
                blockElement_1.markDefs.find(function (def) { return def._key === mark; });
        })
            .filter(Boolean);
        if (annotations_1.length > 0) {
            annotations_1.forEach(function (annotation) {
                var _a;
                var type = portableTextFeatures.types.annotations.find(function (t) { return t.name === annotation._type; });
                // TODO: look into this API!
                var CustomComponent = (_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render;
                var defaultRender = function () {
                    // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
                    return CustomComponent ? (React.createElement(CustomComponent, __assign({}, annotation, { attributes: attributes }), returnedChildren)) : (React.createElement(React.Fragment, null, returnedChildren));
                };
                if (type) {
                    if (props.renderAnnotation) {
                        returnedChildren = (React.createElement("span", { ref: spanRef, key: keyGenerator() }, props.renderAnnotation(annotation, type, { focused: focused, selected: selected, path: path_1, annotations: annotations_1 }, defaultRender, spanRef)));
                    }
                    else {
                        returnedChildren = (React.createElement(DefaultAnnotation, { annotation: annotation },
                            React.createElement("span", { ref: spanRef, key: keyGenerator(), onMouseDown: handleMouseDown }, defaultRender())));
                    }
                }
            });
        }
        if (blockElement_1 && renderChild) {
            var child = blockElement_1.children.find(function (_child) { return _child._key === leaf._key; }); // Ensure object equality
            if (child) {
                returnedChildren = renderChild(child, portableTextFeatures.types.span, { focused: focused, selected: selected, path: path_1, annotations: annotations_1 }, function () { return returnedChildren; }, spanRef);
            }
        }
    }
    if (debugRenders) {
        debug("Render ".concat(leaf._key, " (span)"));
    }
    var key = leaf._key || keyGenerator();
    return (React.createElement("span", __assign({ key: key }, attributes, { ref: spanRef }),
        React.createElement(DraggableChild, { element: leaf, readOnly: readOnly }, returnedChildren)));
};
//# sourceMappingURL=Leaf.js.map