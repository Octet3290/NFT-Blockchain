var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Transforms } from 'slate';
import React, { useCallback, useMemo, useEffect, forwardRef } from 'react';
import { Editable as SlateEditable, ReactEditor } from '@sanity/slate-react';
import { fromSlateValue, isEqualToEmptyEditor, toSlateValue } from '../utils/values';
import { normalizeSelection } from '../utils/selection';
import { toSlateRange } from '../utils/ranges';
import { debugWithName } from '../utils/debug';
import { Leaf } from './Leaf';
import { Element } from './Element';
import { usePortableTextEditor } from './hooks/usePortableTextEditor';
import { PortableTextEditor } from './PortableTextEditor';
import { createWithInsertData, createWithHotkeys } from './plugins';
import { useForwardedRef } from './hooks/useForwardedRef';
import { usePortableTextEditorReadOnlyStatus } from './hooks/usePortableTextReadOnly';
var debug = debugWithName('component:Editable');
var PLACEHOLDER_STYLE = {
    opacity: 0.5,
    position: 'absolute',
    userSelect: 'none',
    pointerEvents: 'none',
};
var NOOP = function () {
    // Nope
};
var isDOMNode = function (value) {
    return value instanceof Node;
};
/**
 * Check if the target is editable and in the editor.
 */
export var hasEditableTarget = function (editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, { editable: true });
};
var EMPTY_DECORATORS = [];
export var PortableTextEditable = forwardRef(function PortableTextEditable(props, forwardedRef) {
    var hotkeys = props.hotkeys, onBeforeInput = props.onBeforeInput, onPaste = props.onPaste, onCopy = props.onCopy, renderAnnotation = props.renderAnnotation, renderBlock = props.renderBlock, renderChild = props.renderChild, renderDecorator = props.renderDecorator, renderPlaceholder = props.renderPlaceholder, propsSelection = props.selection, scrollSelectionIntoView = props.scrollSelectionIntoView, spellCheck = props.spellCheck, restProps = __rest(props, ["hotkeys", "onBeforeInput", "onPaste", "onCopy", "renderAnnotation", "renderBlock", "renderChild", "renderDecorator", "renderPlaceholder", "selection", "scrollSelectionIntoView", "spellCheck"]);
    var portableTextEditor = usePortableTextEditor();
    var readOnly = usePortableTextEditorReadOnlyStatus();
    var ref = useForwardedRef(forwardedRef);
    var change$ = portableTextEditor.change$, keyGenerator = portableTextEditor.keyGenerator, portableTextFeatures = portableTextEditor.portableTextFeatures, slateEditor = portableTextEditor.slateInstance;
    // React/UI-spesific plugins
    var withInsertData = useMemo(function () { return createWithInsertData(change$, portableTextFeatures, keyGenerator); }, [change$, keyGenerator, portableTextFeatures]);
    var withHotKeys = useMemo(function () { return createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys); }, [hotkeys, keyGenerator, portableTextEditor, portableTextFeatures]);
    // Output a minimal React editor inside Editable when in readOnly mode.
    // NOTE: make sure all the plugins used here can be safely run over again at any point.
    // There will be a problem if they redefine editor methods and then calling the original method within themselves.
    useMemo(function () {
        if (readOnly) {
            debug('Editable is in read only mode');
            return withInsertData(slateEditor);
        }
        debug('Editable is in edit mode');
        return withInsertData(withHotKeys(slateEditor));
    }, [readOnly, slateEditor, withHotKeys, withInsertData]);
    var renderElement = useCallback(function (eProps) { return (React.createElement(Element, __assign({}, eProps, { portableTextFeatures: portableTextFeatures, readOnly: readOnly, renderBlock: renderBlock, renderChild: renderChild, spellCheck: spellCheck }))); }, [portableTextFeatures, spellCheck, readOnly, renderBlock, renderChild]);
    var renderLeaf = useCallback(function (lProps) {
        if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === '') {
            return (React.createElement(React.Fragment, null,
                React.createElement("div", { style: PLACEHOLDER_STYLE, contentEditable: false }, renderPlaceholder()),
                React.createElement(Leaf, __assign({}, lProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly }))));
        }
        return (React.createElement(Leaf, __assign({}, lProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly })));
    }, [
        readOnly,
        keyGenerator,
        portableTextFeatures,
        renderAnnotation,
        renderChild,
        renderDecorator,
        renderPlaceholder,
    ]);
    // Restore selection from props
    useEffect(function () {
        if (propsSelection) {
            debug("Selection from props ".concat(JSON.stringify(propsSelection)));
            var normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, portableTextFeatures.types.block.name));
            if (normalizedSelection !== null) {
                debug("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
                var slateRange = toSlateRange(normalizedSelection, slateEditor);
                if (slateRange) {
                    Transforms.select(slateEditor, slateRange);
                    // Output selection here in those cases where the editor selection was the same, and there are no set selection operations in the
                    // editor (this is usually automatically outputted by the withPortableTextSelections plugin)
                    if (!slateEditor.operations.some(function (o) { return o.type === 'set_selection'; })) {
                        change$.next({ type: 'selection', selection: normalizedSelection });
                    }
                    slateEditor.onChange();
                }
            }
        }
    }, [slateEditor, propsSelection, portableTextFeatures.types.block.name, change$]);
    // Set initial selection from props
    useEffect(function () {
        if (propsSelection) {
            PortableTextEditor.select(portableTextEditor, propsSelection);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // Only initial
    // Handle from props onCopy function
    var handleCopy = useCallback(function (event) {
        if (onCopy) {
            var result = onCopy(event);
            // CopyFn may return something to avoid doing default stuff
            if (result !== undefined) {
                event.preventDefault();
            }
        }
    }, [onCopy]);
    // Handle incoming pasting events in the editor
    var handlePaste = useCallback(function (event) {
        if (!slateEditor.selection) {
            return;
        }
        if (onPaste) {
            var resolveOnPasteResultOrError = function () {
                var _a;
                try {
                    return onPaste({
                        event: event,
                        value: PortableTextEditor.getValue(portableTextEditor),
                        path: ((_a = slateEditor.selection) === null || _a === void 0 ? void 0 : _a.focus.path) || [],
                        portableTextFeatures: portableTextFeatures,
                        type: portableTextFeatures.types.portableText, // For legacy support
                    });
                }
                catch (error) {
                    return error;
                }
            };
            // Resolve it as promise (can be either async promise or sync return value)
            var resolved = Promise.resolve(resolveOnPasteResultOrError());
            resolved
                .then(function (result) {
                debug('Custom paste function from client resolved', result);
                change$.next({ type: 'loading', isLoading: true });
                if (!result) {
                    return;
                }
                if (result instanceof Error) {
                    throw result;
                }
                if (result && result.insert) {
                    event.preventDefault(); // Stop the chain
                    slateEditor.insertFragment(toSlateValue(result.insert, { portableTextFeatures: portableTextFeatures }));
                    change$.next({ type: 'loading', isLoading: false });
                    return;
                }
                console.warn('Your onPaste function returned something unexpected:', result);
            })
                .catch(function (error) {
                change$.next({ type: 'loading', isLoading: false });
                console.error(error); // eslint-disable-line no-console
                return error;
            });
        }
        event.preventDefault();
        slateEditor.insertData(event.clipboardData);
    }, [change$, onPaste, portableTextEditor, portableTextFeatures, slateEditor]);
    var handleOnFocus = useCallback(function () {
        change$.next({ type: 'focus' });
    }, [change$]);
    var handleOnBlur = useCallback(function () {
        change$.next({ type: 'blur' });
    }, [change$]);
    var handleOnBeforeInput = useCallback(function (event) {
        if (onBeforeInput) {
            onBeforeInput(event);
        }
    }, [onBeforeInput]);
    var handleKeyDown = slateEditor.pteWithHotKeys;
    var scrollSelectionIntoViewToSlate = useMemo(function () {
        // Use slate-react default scroll into view
        if (scrollSelectionIntoView === undefined) {
            return undefined;
        }
        // Disable scroll into view totally
        if (scrollSelectionIntoView === null) {
            return NOOP;
        }
        // Translate PortableTextEditor prop fn to Slate plugin fn
        return function (editor, domRange) {
            scrollSelectionIntoView(portableTextEditor, domRange);
        };
    }, [portableTextEditor, scrollSelectionIntoView]);
    var decorate = useCallback(function () {
        if (isEqualToEmptyEditor(slateEditor.children, portableTextFeatures)) {
            return [
                {
                    anchor: {
                        path: [0, 0],
                        offset: 0,
                    },
                    focus: {
                        path: [0, 0],
                        offset: 0,
                    },
                    placeholder: true,
                },
            ];
        }
        return EMPTY_DECORATORS;
    }, [portableTextFeatures, slateEditor.children]);
    // The editor
    var slateEditable = useMemo(function () { return (React.createElement(SlateEditable, { autoFocus: false, className: "pt-editable", decorate: decorate, onBlur: handleOnBlur, onCopy: handleCopy, onDOMBeforeInput: handleOnBeforeInput, onFocus: handleOnFocus, onKeyDown: handleKeyDown, onPaste: handlePaste, readOnly: readOnly, renderElement: renderElement, renderLeaf: renderLeaf, scrollSelectionIntoView: scrollSelectionIntoViewToSlate })); }, [
        decorate,
        handleCopy,
        handleKeyDown,
        handleOnBeforeInput,
        handleOnBlur,
        handleOnFocus,
        handlePaste,
        readOnly,
        renderElement,
        renderLeaf,
        scrollSelectionIntoViewToSlate,
    ]);
    if (!portableTextEditor) {
        return null;
    }
    return (React.createElement("div", __assign({ ref: ref }, restProps), slateEditable));
});
//# sourceMappingURL=Editable.js.map