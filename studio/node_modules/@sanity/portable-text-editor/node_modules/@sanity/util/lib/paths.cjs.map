{"version":3,"file":"paths.cjs","sources":["../src/paths.ts"],"sourcesContent":["import {\n  IndexTuple,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  KeyedSegment,\n  Path,\n  PathSegment,\n} from '@sanity/types'\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst EMPTY_PATH: Path = []\n\nexport const FOCUS_TERMINATOR = '$'\n\nexport function get<R>(obj: unknown, path: Path | string): R | undefined\nexport function get<R>(obj: unknown, path: Path | string, defaultValue: R): R\nexport function get(obj: unknown, path: Path | string, defaultVal?: unknown): unknown {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Record<string, unknown>)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc\n}\n\nconst pathsMemo = new Map<string, Path>()\nexport function pathFor(path: Path): Path {\n  if (path.length === 0) {\n    return EMPTY_PATH\n  }\n  const asString = toString(path)\n  if (pathsMemo.has(asString)) {\n    return pathsMemo.get(asString)!\n  }\n  pathsMemo.set(asString, path)\n  Object.freeze(path)\n  return path\n}\n\nexport function isEqual(path: Path, otherPath: Path): boolean {\n  return (\n    path.length === otherPath.length &&\n    path.every((segment, i) => isSegmentEqual(segment, otherPath[i]))\n  )\n}\n\nexport function numEqualSegments(path: Path, otherPath: Path): number {\n  const length = Math.min(path.length, otherPath.length)\n  for (let i = 0; i < length; i++) {\n    if (!isSegmentEqual(path[i], otherPath[i])) {\n      return i\n    }\n  }\n  return length\n}\n\nexport function isSegmentEqual(segmentA: PathSegment, segmentB: PathSegment): boolean {\n  if (isKeySegment(segmentA) && isKeySegment(segmentB)) {\n    return segmentA._key === segmentB._key\n  }\n\n  if (isIndexSegment(segmentA)) {\n    return Number(segmentA) === Number(segmentB)\n  }\n\n  if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {\n    return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1]\n  }\n\n  return segmentA === segmentB\n}\n\nexport function hasFocus(focusPath: Path, path: Path): boolean {\n  const withoutTerminator =\n    focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath\n  return isEqual(withoutTerminator, path)\n}\n\nexport function hasItemFocus(focusPath: Path, item: PathSegment): boolean {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item)\n}\n\nexport function isExpanded(segment: PathSegment, focusPath: Path): boolean {\n  const [head, ...tail] = focusPath\n  return tail.length > 0 && isSegmentEqual(segment, head)\n}\n\nexport function startsWith(prefix: Path, path: Path): boolean {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]))\n}\n\nexport function trimLeft(prefix: Path, path: Path): Path {\n  if (prefix.length === 0 || path.length === 0) {\n    return path\n  }\n  const [prefixHead, ...prefixTail] = prefix\n  const [pathHead, ...pathTail] = path\n  if (!isSegmentEqual(prefixHead, pathHead)) {\n    return path\n  }\n  return pathFor(trimLeft(prefixTail, pathTail))\n}\n\nexport function trimRight(suffix: Path, path: Path): Path {\n  const sufLen = suffix.length\n  const pathLen = path.length\n  if (sufLen === 0 || pathLen === 0) {\n    return path\n  }\n\n  let i = 0\n  while (\n    i < sufLen &&\n    i < pathLen &&\n    isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])\n  ) {\n    i++\n  }\n\n  return pathFor(path.slice(0, pathLen - i))\n}\n\nexport function trimChildPath(path: Path, childPath: Path): Path {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH\n}\n\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(normalizePathSegment)\n}\n\nfunction normalizePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return normalizeIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return normalizeKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return normalizeIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction normalizeIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction normalizeKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction normalizeIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n"],"names":["isIndexSegment","isKeySegment","isIndexTuple"],"mappings":"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"}