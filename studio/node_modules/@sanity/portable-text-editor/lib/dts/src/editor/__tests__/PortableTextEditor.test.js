/**
 * \@jest-environment ./test/setup/jsdom.jest.env.ts
 */
/* eslint-disable no-irregular-whitespace */
// eslint-disable-next-line import/no-unassigned-import
import '@testing-library/jest-dom/extend-expect';
import React from 'react';
import { act } from 'react-dom/test-utils';
import { render } from '@testing-library/react';
import { PortableTextEditor } from '../PortableTextEditor';
import { PortableTextEditorTester, type } from './PortableTextEditorTester';
var helloBlock = {
    _key: '123',
    _type: 'myTestBlockType',
    markDefs: [],
    children: [{ _key: '567', _type: 'span', text: 'Hello', marks: [] }],
};
describe('initialization', function () {
    it('receives initial onChange events and has custom placeholder', function () {
        var editorRef = React.createRef();
        var onChange = jest.fn();
        var container = render(React.createElement(PortableTextEditorTester, { onChange: onChange, renderPlaceholder: function () { return 'Jot something down here'; }, ref: editorRef, type: type, value: undefined })).container;
        expect(editorRef.current).not.toBe(null);
        expect(onChange).toHaveBeenCalledWith({ type: 'ready' });
        expect(onChange).toHaveBeenCalledWith({ type: 'value', value: undefined });
        expect(container).toMatchInlineSnapshot("\n      <div>\n        <div>\n          <div\n            autocapitalize=\"false\"\n            autocorrect=\"false\"\n            class=\"pt-editable\"\n            contenteditable=\"true\"\n            data-slate-editor=\"true\"\n            data-slate-node=\"value\"\n            role=\"textbox\"\n            spellcheck=\"false\"\n            style=\"position: relative; outline: none; white-space: pre-wrap; word-wrap: break-word;\"\n            zindex=\"-1\"\n          >\n            <div\n              class=\"pt-block pt-text-block pt-text-block-style-normal\"\n              data-slate-node=\"element\"\n            >\n              <div\n                draggable=\"false\"\n              >\n                <div>\n                  <span\n                    data-slate-node=\"text\"\n                  >\n                    <div\n                      contenteditable=\"false\"\n                      style=\"opacity: 0.5; position: absolute; user-select: none; pointer-events: none;\"\n                    >\n                      Jot something down here\n                    </div>\n                    <span\n                      data-slate-leaf=\"true\"\n                    >\n                      <span\n                        draggable=\"false\"\n                      >\n                        <span\n                          data-slate-length=\"0\"\n                          data-slate-zero-width=\"n\"\n                        >\n                          \uFEFF\n                          <br />\n                        </span>\n                      </span>\n                    </span>\n                  </span>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ");
    });
    it('takes value from props', function () {
        var initialValue = [helloBlock];
        var onChange = jest.fn();
        render(React.createElement(PortableTextEditorTester, { onChange: onChange, type: type, value: initialValue }));
        expect(onChange).toHaveBeenCalledWith({ type: 'value', value: initialValue });
    });
    it('takes initial selection from props', function () {
        var editorRef = React.createRef();
        var initialValue = [helloBlock];
        var initialSelection = {
            anchor: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 2 },
            focus: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 2 },
        };
        var onChange = jest.fn();
        render(React.createElement(PortableTextEditorTester, { onChange: onChange, ref: editorRef, selection: initialSelection, type: type, value: initialValue }));
        if (!editorRef.current) {
            throw new Error('No editor');
        }
        act(function () {
            if (editorRef.current) {
                PortableTextEditor.focus(editorRef.current);
            }
        });
        expect(PortableTextEditor.getSelection(editorRef.current)).toEqual(initialSelection);
    });
    it('updates editor selection from new prop and keeps object equality in editor.getSelection()', function () {
        var editorRef = React.createRef();
        var initialValue = [helloBlock];
        var initialSelection = {
            anchor: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 0 },
            focus: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 0 },
        };
        var newSelection = {
            anchor: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 0 },
            focus: { path: [{ _key: '123' }, 'children', { _key: '567' }], offset: 3 },
        };
        var onChange = jest.fn();
        var rerender = render(React.createElement(PortableTextEditorTester, { onChange: onChange, ref: editorRef, selection: initialSelection, type: type, value: initialValue })).rerender;
        if (!editorRef.current) {
            throw new Error('No editor');
        }
        act(function () {
            if (editorRef.current) {
                var sel = PortableTextEditor.getSelection(editorRef.current);
                PortableTextEditor.focus(editorRef.current);
                // Test for object equality here!
                var anotherSel = PortableTextEditor.getSelection(editorRef.current);
                expect(PortableTextEditor.getSelection(editorRef.current)).toStrictEqual(initialSelection);
                expect(sel).toBe(anotherSel);
            }
        });
        rerender(React.createElement(PortableTextEditorTester, { onChange: onChange, ref: editorRef, selection: newSelection, type: type, value: initialValue }));
        act(function () {
            if (editorRef.current) {
                expect(PortableTextEditor.getSelection(editorRef.current)).toEqual(newSelection);
            }
        });
    });
});
//# sourceMappingURL=PortableTextEditor.test.js.map