var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { omitBy, isUndefined, get } from 'lodash';
import { Text, } from 'slate';
import { set, insert, unset, diffMatchPatch, setIfMissing } from '../patch/PatchEvent';
import { fromSlateValue } from './values';
import { debugWithName } from './debug';
var debug = debugWithName('operationToPatches');
export function createOperationToPatches(portableTextFeatures) {
    var textBlockName = portableTextFeatures.types.block.name;
    function insertTextPatch(editor, operation, beforeValue) {
        debug('Operation', JSON.stringify(operation, null, 2));
        var block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        var textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        var path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        var prevBlock = beforeValue[operation.path[0]];
        var prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
        var prevText = Text.isText(prevChild) ? prevChild.text : '';
        var patch = diffMatchPatch(prevText, textChild.text, path);
        return patch.value.length ? [patch] : [];
    }
    function removeTextPatch(editor, operation, beforeValue) {
        var block = editor && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        var textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        var path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        var beforeBlock = beforeValue[operation.path[0]];
        var prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
        var prevText = Text.isText(prevTextChild) && prevTextChild.text;
        var patch = diffMatchPatch(prevText || '', textChild.text, path);
        return patch.value ? [patch] : [];
    }
    function setNodePatch(editor, operation) {
        if (operation.path.length === 1) {
            var block = editor.children[operation.path[0]];
            if (typeof block._key !== 'string') {
                throw new Error('Expected block to have a _key');
            }
            var setNode = omitBy(__assign(__assign({}, editor.children[operation.path[0]]), operation.newProperties), isUndefined);
            return [set(fromSlateValue([setNode], textBlockName)[0], [{ _key: block._key }])];
        }
        else if (operation.path.length === 2) {
            var block = editor.children[operation.path[0]];
            if (editor.isTextBlock(block)) {
                var child = block.children[operation.path[1]];
                if (child) {
                    var blockKey_1 = block._key;
                    var childKey_1 = child._key;
                    var patches_1 = [];
                    Object.keys(operation.newProperties).forEach(function (keyName) {
                        var val = get(operation.newProperties, keyName);
                        patches_1.push(set(val, [{ _key: blockKey_1 }, 'children', { _key: childKey_1 }, keyName]));
                    });
                    return patches_1;
                }
                throw new Error('Could not find a valid child');
            }
            throw new Error('Could not find a valid block');
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
    }
    function insertNodePatch(editor, operation, beforeValue) {
        var block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            var position = operation.path[0] === 0 ? 'before' : 'after';
            var beforeBlock = beforeValue[operation.path[0] - 1];
            var targetKey = operation.path[0] === 0 ? block === null || block === void 0 ? void 0 : block._key : beforeBlock === null || beforeBlock === void 0 ? void 0 : beforeBlock._key;
            if (targetKey) {
                return [
                    insert([fromSlateValue([operation.node], textBlockName)[0]], position, [
                        { _key: targetKey },
                    ]),
                ];
            }
            return [
                setIfMissing(beforeValue, []),
                insert([fromSlateValue([operation.node], textBlockName)[0]], 'before', [operation.path[0]]),
            ];
        }
        else if (operation.path.length === 2 && editor.children[operation.path[0]]) {
            if (!editor.isTextBlock(block)) {
                throw new Error('Invalid block');
            }
            var position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? 'before' : 'after';
            var child = fromSlateValue([
                {
                    _key: 'bogus',
                    _type: textBlockName,
                    children: [operation.node],
                },
            ], textBlockName)[0].children[0];
            return [
                insert([child], position, [
                    { _key: block._key },
                    'children',
                    block.children.length <= 1 || !block.children[operation.path[1] - 1]
                        ? 0
                        : { _key: block.children[operation.path[1] - 1]._key },
                ]),
            ];
        }
        throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path), " - ").concat(JSON.stringify(beforeValue)));
    }
    function splitNodePatch(editor, operation, beforeValue) {
        var patches = [];
        var splitBlock = editor.children[operation.path[0]];
        if (!editor.isTextBlock(splitBlock)) {
            throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
        }
        if (operation.path.length === 1) {
            var oldBlock_1 = beforeValue[operation.path[0]];
            if (editor.isTextBlock(oldBlock_1)) {
                var targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
                if (targetValue) {
                    patches.push(insert([targetValue], 'after', [{ _key: splitBlock._key }]));
                    var spansToUnset = oldBlock_1.children.slice(operation.position);
                    spansToUnset.forEach(function (span) {
                        var path = [{ _key: oldBlock_1._key }, 'children', { _key: span._key }];
                        patches.push(unset(path));
                    });
                }
            }
            return patches;
        }
        if (operation.path.length === 2) {
            var splitSpan = splitBlock.children[operation.path[1]];
            if (Text.isText(splitSpan)) {
                var targetSpans = fromSlateValue([
                    __assign(__assign({}, splitBlock), { children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2) }),
                ], textBlockName)[0].children;
                patches.push(insert(targetSpans, 'after', [
                    { _key: splitBlock._key },
                    'children',
                    { _key: splitSpan._key },
                ]));
                patches.push(set(splitSpan.text, [{ _key: splitBlock._key }, 'children', { _key: splitSpan._key }, 'text']));
            }
            return patches;
        }
        return patches;
    }
    function removeNodePatch(_, operation, beforeValue) {
        var block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            // Remove a single block
            if (block && block._key) {
                return [unset([{ _key: block._key }])];
            }
            throw new Error('Block not found');
        }
        else if (operation.path.length === 2) {
            var spanToRemove = block && block.children && block.children[operation.path[1]];
            if (spanToRemove) {
                return [unset([{ _key: block._key }, 'children', { _key: spanToRemove._key }])];
            }
            // If it was not there before, do nothing
            debug('Span not found in editor trying to remove node');
            return [];
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
    }
    function mergeNodePatch(editor, operation, beforeValue) {
        var patches = [];
        if (operation.path.length === 1) {
            var block = beforeValue[operation.path[0]];
            var targetKey = block && block._key;
            if (targetKey) {
                var newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
                patches.push(set(newBlock, [{ _key: newBlock._key }]));
                patches.push(unset([{ _key: targetKey }]));
            }
            else {
                throw new Error('Target key not found!');
            }
        }
        else if (operation.path.length === 2) {
            var block = beforeValue[operation.path[0]];
            var mergedSpan = block.children[operation.path[1]];
            var targetBlock = editor.children[operation.path[0]];
            if (!editor.isTextBlock(targetBlock)) {
                throw new Error('Invalid block');
            }
            var targetSpan = targetBlock.children[operation.path[1] - 1];
            if (Text.isText(targetSpan)) {
                // Set the merged span with it's new value
                patches.push(set(targetSpan.text, [{ _key: block._key }, 'children', { _key: targetSpan._key }, 'text']));
                patches.push(unset([{ _key: block._key }, 'children', { _key: mergedSpan._key }]));
            }
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
        return patches;
    }
    function moveNodePatch(_, operation, beforeValue) {
        var patches = [];
        var block = beforeValue[operation.path[0]];
        var targetBlock = beforeValue[operation.newPath[0]];
        if (operation.path.length === 1) {
            var position = operation.path[0] > operation.newPath[0] ? 'before' : 'after';
            patches.push(unset([{ _key: block._key }]));
            patches.push(insert([fromSlateValue([block], textBlockName)[0]], position, [{ _key: targetBlock._key }]));
        }
        else if (operation.path.length === 2) {
            var child = block.children[operation.path[1]];
            var targetChild = targetBlock.children[operation.newPath[1]];
            var position = operation.newPath[1] === targetBlock.children.length ? 'after' : 'before';
            var childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
            patches.push(unset([{ _key: block._key }, 'children', { _key: child._key }]));
            patches.push(insert([childToInsert], position, [
                { _key: targetBlock._key },
                'children',
                { _key: targetChild._key },
            ]));
        }
        return patches;
    }
    return {
        insertNodePatch: insertNodePatch,
        insertTextPatch: insertTextPatch,
        mergeNodePatch: mergeNodePatch,
        moveNodePatch: moveNodePatch,
        removeNodePatch: removeNodePatch,
        removeTextPatch: removeTextPatch,
        setNodePatch: setNodePatch,
        splitNodePatch: splitNodePatch,
    };
}
//# sourceMappingURL=operationToPatches.js.map