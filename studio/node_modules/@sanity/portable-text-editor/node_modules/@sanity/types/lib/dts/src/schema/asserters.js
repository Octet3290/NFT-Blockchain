var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function isRecord(value) {
    return !!value && (typeof value == 'object' || typeof value == 'function');
}
/**
 * Returns wether or not the given type is a document type
 * (eg that it was defined as `type: 'document'`)
 *
 * @param type - Schema type to test
 * @returns True if type is a document type, false otherwise
 * @public
 */
export function isDocumentSchemaType(type) {
    if (!isObjectSchemaType(type)) {
        return false;
    }
    var current = type;
    while (current) {
        if (current.name === 'document') {
            return true;
        }
        current = current.type;
    }
    return false;
}
export function isObjectSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'object';
}
export function isArraySchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'array';
}
export function isArrayOfObjectsSchemaType(type) {
    return isArraySchemaType(type) && type.of.every(function (memberType) { return isObjectSchemaType(memberType); });
}
export function isArrayOfPrimitivesSchemaType(type) {
    return isArraySchemaType(type) && type.of.every(function (memberType) { return isPrimitiveSchemaType(memberType); });
}
export function isBooleanSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'boolean';
}
export function isStringSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'string';
}
export function isNumberSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'number';
}
export function isPrimitiveSchemaType(type) {
    return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
export function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type));
}
export function isCrossDatasetReferenceSchemaType(type) {
    return (isRecord(type) &&
        (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type)));
}
export function isTitledListValue(item) {
    return typeof item === 'object' && item !== null && 'title' in item && 'value' in item;
}
export function isSpanSchemaType(type) {
    if (!isRecord(type))
        return false;
    // we check for `annotations` and `decorators` instead of `type.name` because
    // schema names can technically change if someone extends the type
    return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
export function isBlockSchemaType(type) {
    if (!isRecord(type))
        return false;
    if (!Array.isArray(type.fields))
        return false;
    var _a = __read(type.fields, 3), maybeSpanChildren = _a[0], maybeStyle = _a[1], maybeList = _a[2];
    return (isBlockChildrenObjectField(maybeSpanChildren) &&
        isStyleObjectField(maybeStyle) &&
        isListObjectField(maybeList));
}
export function isStyleObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'style')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
export function isListObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'list')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
export function isBlockChildrenObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'children')
        return false;
    if (!isArraySchemaType(field.type))
        return false;
    // there will always be a span item in `SpanChildrenObjectField`
    return field.type.of.some(isSpanSchemaType);
}
//# sourceMappingURL=asserters.js.map