var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { randomKey } from '../../util/randomKey';
import { isElement, tagName } from '../helpers';
import { DEFAULT_BLOCK, DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS, HTML_SPAN_TAGS, HTML_LIST_CONTAINER_TAGS, HTML_LIST_ITEM_TAGS, HTML_DECORATOR_TAGS, } from '../../constants';
export function resolveListItem(listNodeTagName) {
    var listStyle;
    switch (listNodeTagName) {
        case 'ul':
            listStyle = 'bullet';
            break;
        case 'ol':
            listStyle = 'number';
            break;
        default:
            listStyle = 'bullet';
    }
    return listStyle;
}
export default function createHTMLRules(blockContentType, options) {
    return [
        // Text nodes
        {
            deserialize: function (el) {
                var isValidWhiteSpace = el.nodeType === 3 &&
                    (el.textContent || '').replace(/[\r\n]/g, ' ').replace(/\s\s+/g, ' ') === ' ' &&
                    el.nextSibling &&
                    el.nextSibling.nodeType !== 3 &&
                    el.previousSibling &&
                    el.previousSibling.nodeType !== 3;
                var isValidText = (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body';
                if (el.nodeName === '#text' && isValidText) {
                    return __assign(__assign({}, DEFAULT_SPAN), { marks: [], text: (el.textContent || '').replace(/\s\s+/g, ' ') });
                }
                return undefined;
            },
        },
        {
            deserialize: function (el, next) {
                if (tagName(el) !== 'blockquote') {
                    return undefined;
                }
                var blocks = __assign(__assign({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
                delete blocks.blockquote;
                var children = [];
                el.childNodes.forEach(function (node, index) {
                    if (node.nodeType === 1 &&
                        Object.keys(blocks).includes(node.localName.toLowerCase())) {
                        if (!el.ownerDocument) {
                            return;
                        }
                        var span_1 = el.ownerDocument.createElement('span');
                        span_1.appendChild(el.ownerDocument.createTextNode('\r'));
                        node.childNodes.forEach(function (cn) {
                            span_1.appendChild(cn.cloneNode(true));
                        });
                        if (index !== el.childNodes.length) {
                            span_1.appendChild(el.ownerDocument.createTextNode('\r'));
                        }
                        children.push(span_1);
                    }
                    else {
                        children.push(node);
                    }
                });
                return {
                    _type: 'block',
                    style: 'blockquote',
                    markDefs: [],
                    children: next(children),
                };
            },
        },
        {
            deserialize: function (el, next) {
                var blocks = __assign(__assign({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
                var tag = tagName(el);
                var block = tag ? blocks[tag] : undefined;
                if (!block) {
                    return undefined;
                }
                // Don't add blocks into list items
                if (el.parentNode && tagName(el) === 'li') {
                    return next(el.childNodes);
                }
                // If style is not supported, return a defaultBlockType
                if (!options.enabledBlockStyles.includes(block.style)) {
                    block = DEFAULT_BLOCK;
                }
                return __assign(__assign({}, block), { children: next(el.childNodes) });
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                if (!tag || !(tag in HTML_SPAN_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el, next) {
                var div = tagName(el) === 'div';
                if (!div) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el) {
                if (tagName(el) === 'br') {
                    return __assign(__assign({}, DEFAULT_SPAN), { text: '\n' });
                }
                return undefined;
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                var listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined;
                var parentTag = tagName(el.parentNode) || '';
                if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
                    return undefined;
                }
                listItem.listItem = resolveListItem(parentTag);
                return __assign(__assign({}, listItem), { children: next(el.childNodes) });
            },
        },
        {
            deserialize: function (el, next) {
                var decorator = HTML_DECORATOR_TAGS[tagName(el) || ''];
                if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
                    return undefined;
                }
                return {
                    _type: '__decorator',
                    name: decorator,
                    children: next(el.childNodes),
                };
            },
        },
        // If not supported just write out the link text and href in plain text.
        {
            deserialize: function (el, next) {
                if (tagName(el) != 'a') {
                    return undefined;
                }
                var linkEnabled = options.enabledBlockAnnotations.includes('link');
                var href = isElement(el) && el.getAttribute('href');
                if (!href) {
                    return next(el.childNodes);
                }
                var markDef;
                if (linkEnabled) {
                    markDef = {
                        _key: randomKey(12),
                        _type: 'link',
                        href: href,
                    };
                    return {
                        _type: '__annotation',
                        markDef: markDef,
                        children: next(el.childNodes),
                    };
                }
                return el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
            },
        },
    ];
}
//# sourceMappingURL=html.js.map