var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Text as SlateText } from 'slate';
import { debugWithName } from '../../utils/debug';
var debug = debugWithName('plugin:withSchemaTypes');
/**
 * This plugin makes sure that shema types are recognized properly by Slate as blocks, voids, inlines
 *
 */
export function createWithSchemaTypes(portableTextFeatures) {
    return function withSchemaTypes(editor) {
        editor.isTextBlock = function (value) {
            return (!editor.isVoid(value) &&
                'markDefs' in value &&
                'style' in value &&
                'children' in value &&
                '_type' in value &&
                portableTextFeatures.types.block.name === value._type);
        };
        editor.isTextSpan = function (value) {
            return (!editor.isVoid(value) &&
                'text' in value &&
                'marks' in value &&
                '_type' in value &&
                portableTextFeatures.types.span.name === value._type);
        };
        editor.isListBlock = function (value) {
            return Boolean(editor.isTextBlock(value) &&
                'listItem' in value &&
                'level' in value &&
                value.listItem &&
                Number.isInteger(value.level));
        };
        editor.isVoid = function (element) {
            return (portableTextFeatures.types.block.name !== element._type &&
                (portableTextFeatures.types.blockObjects.map(function (obj) { return obj.name; }).includes(element._type) ||
                    portableTextFeatures.types.inlineObjects.map(function (obj) { return obj.name; }).includes(element._type)));
        };
        editor.isInline = function (element) {
            var inlineSchemaTypes = portableTextFeatures.types.inlineObjects.map(function (obj) { return obj.name; });
            return (inlineSchemaTypes.includes(element._type) &&
                '__inline' in element &&
                element.__inline === true);
        };
        // Extend Slate's default normalization to add _type span to span inserted after a inline void object
        var apply = editor.apply;
        editor.apply = function (op) {
            var isInsertTextWithoutType = op.type === 'insert_node' &&
                op.path.length === 2 &&
                SlateText.isText(op.node) &&
                op.node._type === undefined;
            if (isInsertTextWithoutType) {
                var insertNodeOperation = op;
                var newNode = __assign(__assign({}, insertNodeOperation.node), { _type: 'span' });
                op.node = newNode;
                debug('Setting span type to child without a type', op);
            }
            apply(op);
        };
        return editor;
    };
}
//# sourceMappingURL=createWithSchemaTypes.js.map