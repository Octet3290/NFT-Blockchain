import { ArraySchemaType } from '@sanity/types';
import type { BlockEnabledFeatures, HtmlParser, MinimalBlock, MinimalSpan, PlaceholderAnnotation, PlaceholderDecorator, TypedObject } from '../types';
/**
 * A utility function to create the options needed for the various rule sets,
 * based on the structure of the blockContentType
 *
 * @param blockContentType - Schema type for array containing _at least_ a block child type
 * @returns
 */
export declare function createRuleOptions(blockContentType: ArraySchemaType): BlockEnabledFeatures;
/**
 * Utility function that always return a lowerCase version of the element.tagName
 *
 * @param el - Element to get tag name for
 * @returns Lowercase tagName for that element, or undefined if not an element
 */
export declare function tagName(el: HTMLElement | Node | null): string | undefined;
export declare function preprocess(html: string, parseHtml: HtmlParser): Document;
/**
 * A default `parseHtml` function that returns the html using `DOMParser`.
 *
 * @returns HTML Parser based on `DOMParser`
 */
export declare function defaultParseHtml(): HtmlParser;
export declare function flattenNestedBlocks(blocks: TypedObject[]): TypedObject[];
/**
 * NOTE: _mutates_ passed blocks!
 *
 * @param blocks - Array of blocks to trim whitespace for
 * @returns
 */
export declare function trimWhitespace(blocks: TypedObject[]): TypedObject[];
export declare function ensureRootIsBlocks(blocks: TypedObject[]): TypedObject[];
export declare function isNodeList(node: unknown): node is NodeList;
export declare function isMinimalSpan(node: TypedObject): node is MinimalSpan;
export declare function isMinimalBlock(node: TypedObject): node is MinimalBlock;
export declare function isPlaceholderDecorator(node: TypedObject): node is PlaceholderDecorator;
export declare function isPlaceholderAnnotation(node: TypedObject): node is PlaceholderAnnotation;
export declare function isElement(node: Node): node is Element;
//# sourceMappingURL=helpers.d.ts.map