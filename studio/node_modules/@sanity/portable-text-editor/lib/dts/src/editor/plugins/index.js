var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { createOperationToPatches } from '../../utils/operationToPatches';
import { createWithEditableAPI } from './createWithEditableAPI';
import { createWithMaxBlocks } from './createWithMaxBlocks';
import { createWithObjectKeys } from './createWithObjectKeys';
import { createWithPatches } from './createWithPatches';
import { createWithPlaceholderBlock } from './createWithPlaceholderBlock';
import { createWithPortableTextBlockStyle } from './createWithPortableTextBlockStyle';
import { createWithPortableTextLists } from './createWithPortableTextLists';
import { createWithPortableTextMarkModel } from './createWithPortableTextMarkModel';
import { createWithPortableTextSelections } from './createWithPortableTextSelections';
import { createWithSchemaTypes } from './createWithSchemaTypes';
import { createWithUndoRedo } from './createWithUndoRedo';
import { createWithUtils } from './createWithUtils';
export { createWithEditableAPI } from './createWithEditableAPI';
export { createWithHotkeys } from './createWithHotKeys';
export { createWithInsertData } from './createWithInsertData';
export { createWithMaxBlocks } from './createWithMaxBlocks';
export { createWithObjectKeys } from './createWithObjectKeys';
export { createWithPatches } from './createWithPatches';
export { createWithPortableTextBlockStyle } from './createWithPortableTextBlockStyle';
export { createWithPortableTextLists } from './createWithPortableTextLists';
export { createWithPortableTextMarkModel } from './createWithPortableTextMarkModel';
export { createWithPortableTextSelections } from './createWithPortableTextSelections';
export { createWithSchemaTypes } from './createWithSchemaTypes';
export { createWithUndoRedo } from './createWithUndoRedo';
export { createWithUtils } from './createWithUtils';
var originalFnMap = new WeakMap();
export var withPlugins = function (editor, options) {
    var e = editor;
    var portableTextEditor = options.portableTextEditor;
    var portableTextFeatures = portableTextEditor.portableTextFeatures, keyGenerator = portableTextEditor.keyGenerator, readOnly = portableTextEditor.readOnly, change$ = portableTextEditor.change$, syncValue = portableTextEditor.syncValue, incomingPatches$ = portableTextEditor.incomingPatches$;
    e.maxBlocks = portableTextEditor.maxBlocks || -1;
    e.readOnly = portableTextEditor.readOnly || false;
    if (e.destroy) {
        e.destroy();
    }
    else {
        // Save a copy of the original editor functions here before they were changed by plugins.
        // We will put them back when .destroy is called (see below).
        originalFnMap.set(e, {
            apply: e.apply,
            onChange: e.onChange,
            normalizeNode: e.normalizeNode,
        });
    }
    var operationToPatches = createOperationToPatches(portableTextFeatures);
    var withObjectKeys = createWithObjectKeys(portableTextFeatures, keyGenerator);
    var withSchemaTypes = createWithSchemaTypes(portableTextFeatures);
    var withEditableAPI = createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator);
    var _a = __read(readOnly
        ? []
        : createWithPatches({
            patchFunctions: operationToPatches,
            change$: change$,
            portableTextFeatures: portableTextFeatures,
            syncValue: syncValue,
            incomingPatches$: incomingPatches$,
        }), 2), withPatches = _a[0], withPatchesCleanupFunction = _a[1];
    var withMaxBlocks = createWithMaxBlocks();
    var withPortableTextLists = createWithPortableTextLists(portableTextFeatures);
    var _b = __read(readOnly
        ? []
        : createWithUndoRedo(incomingPatches$), 2), withUndoRedo = _b[0], withUndoRedoCleanupFunction = _b[1];
    var withPortableTextMarkModel = createWithPortableTextMarkModel(portableTextFeatures, keyGenerator);
    var withPortableTextBlockStyle = createWithPortableTextBlockStyle(portableTextFeatures, change$);
    var withPlaceholderBlock = createWithPlaceholderBlock({
        keyGenerator: keyGenerator,
        portableTextFeatures: portableTextFeatures,
    });
    var withUtils = createWithUtils({ keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures });
    var withPortableTextSelections = createWithPortableTextSelections(change$, portableTextFeatures);
    e.destroy = function () {
        var originalFunctions = originalFnMap.get(e);
        if (!originalFunctions) {
            throw new Error('Could not find pristine versions of editor functions');
        }
        e.onChange = originalFunctions.onChange;
        e.apply = originalFunctions.apply;
        e.normalizeNode = originalFunctions.normalizeNode;
        if (withPatchesCleanupFunction) {
            withPatchesCleanupFunction();
        }
        if (withUndoRedoCleanupFunction) {
            withUndoRedoCleanupFunction();
        }
    };
    if (readOnly) {
        return withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e)))))))));
    }
    // The 'if' here is only to satisfy Typscript
    if (withUndoRedo && withPatches) {
        // Ordering is important here, selection dealing last, data manipulation in the middle and core model stuff first.
        return withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e))))))))))));
    }
    return e;
};
//# sourceMappingURL=index.js.map