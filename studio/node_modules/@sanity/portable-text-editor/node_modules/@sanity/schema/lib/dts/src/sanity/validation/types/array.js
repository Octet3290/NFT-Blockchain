var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { error, HELP_IDS, warning } from '../createValidationResult';
import { flatten } from 'lodash';
import { getDupes } from '../utils/getDupes';
import { coreTypeNames } from '../../coreTypes';
export default (function (typeDef, visitorContext) {
    var _a, _b;
    // name should already have been marked
    var ofIsArray = Array.isArray(typeDef.of);
    if (ofIsArray) {
        var invalid = typeDef.of.reduce(function (errs, def, idx) {
            if (typeof def.name === 'string') {
                // If an array member has been given a "local" type name, we want to trigger an error if the given member type name
                // is one of the builtin types
                //
                // The following examples should be an error (where book is an existing root level type and reference is a built-in type):
                //  - (…) of: [{type: 'book', name: 'image'}]
                //  - (…) of: [{type: 'book', name: 'object'}]
                //  - (…) of: [{type: 'object', name: 'reference'}]
                // The following examples are valid (where "address" is not defined as a global object type)
                //  - (…) of: [{type: 'object', name: 'address'}]
                // The following examples are redundant, but should be allowed (at least for now)
                //  - (…) of: [{type: 'object', name: 'object'}]
                //  - (…) of: [{type: 'image', name: 'image'}]
                if (
                // specifying the same name as the type is redundant, but should not be a hard error at this point
                // Consider showing a warning for this and deprecate this ability eventually
                def.name !== def.type &&
                    coreTypeNames.includes(def.name)) {
                    return errs.concat(error("Found array member declaration with the same type name as a built-in type (\"".concat(def.name, "\"). Array members can not be given the same name as a built-in type."), HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
                }
            }
            if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {
                return errs.concat(warning("Found array member declaration with the same name as the global schema type \"".concat(def.name, "\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name."), HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
            }
            if (def.type === 'array') {
                return errs.concat(error("Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity", HELP_IDS.ARRAY_OF_ARRAY));
            }
            if (def) {
                return errs;
            }
            var err = "Found ".concat(def === null ? 'null' : typeof def, ", expected member declaration");
            return errs.concat(error("Found invalid type member declaration in array at index ".concat(idx, ": ").concat(err), HELP_IDS.ARRAY_OF_INVALID));
        }, []);
        if (invalid.length > 0) {
            return __assign(__assign({}, typeDef), { of: [], _problems: invalid });
        }
    }
    var problems = flatten([
        ofIsArray
            ? getDupes(typeDef.of, function (t) { return "".concat(t.name, ";").concat(t.type); }).map(function (dupes) {
                return error("Found ".concat(dupes.length, " members with same type, but not unique names \"").concat(dupes[0].type, "\" in array. This makes it impossible to tell their values apart and you should consider naming them"), HELP_IDS.ARRAY_OF_NOT_UNIQUE);
            })
            : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID),
    ]);
    var of = ofIsArray ? typeDef.of : [];
    // Don't allow object types without a name in block arrays
    var hasObjectTypesWithoutName = of.some(function (type) { return type.type === 'object' && typeof type.name === 'undefined'; });
    var hasBlockType = of.some(function (ofType) { return ofType.type === 'block'; });
    if (hasBlockType && hasObjectTypesWithoutName) {
        problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
    }
    if (((_a = typeDef === null || typeDef === void 0 ? void 0 : typeDef.options) === null || _a === void 0 ? void 0 : _a.list) && ((_b = typeDef === null || typeDef === void 0 ? void 0 : typeDef.options) === null || _b === void 0 ? void 0 : _b.layout) === 'tags') {
        problems.push(warning('Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.'));
    }
    return __assign(__assign({}, typeDef), { of: of.map(visitorContext.visit), _problems: problems });
});
//# sourceMappingURL=array.js.map