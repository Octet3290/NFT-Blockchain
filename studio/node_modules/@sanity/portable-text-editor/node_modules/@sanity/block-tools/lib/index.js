import { isBlockSchemaType, isBlockChildrenObjectField, isObjectSchemaType, isStyleObjectField, isListObjectField, isTitledListValue, isBlock, isSpan } from '@sanity/types';
import { uniq, isEqual, flatten } from 'lodash';
import getRandomValues from 'get-random-values-esm';

function findBlockType(type) {
    if (type.type) {
        return findBlockType(type.type);
    }
    if (type.name === 'block') {
        return true;
    }
    return false;
}

// Helper method for describing a blockContentType's feature set
function blockContentFeatures(blockContentType) {
    var _a, _b;
    if (!blockContentType) {
        throw new Error("Parameter 'blockContentType' required");
    }
    var blockType = blockContentType.of.find(findBlockType);
    if (!isBlockSchemaType(blockType)) {
        throw new Error("'block' type is not defined in this schema (required).");
    }
    var ofType = (_b = (_a = blockType.fields.find(isBlockChildrenObjectField)) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.of;
    if (!ofType) {
        throw new Error('No `of` declaration found for blocks `children` field');
    }
    var spanType = ofType.find(function (member) { return member.name === 'span'; });
    if (!spanType) {
        throw new Error('No `span` type found in `block` schema type `children` definition');
    }
    var inlineObjectTypes = ofType.filter(function (inlineType) {
        return inlineType.name !== 'span' && isObjectSchemaType(inlineType);
    });
    var blockObjectTypes = blockContentType.of.filter(function (memberType) {
        return memberType.name !== blockType.name && isObjectSchemaType(memberType);
    });
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        annotations: resolveEnabledAnnotationTypes(spanType),
        lists: resolveEnabledListItems(blockType),
        types: {
            block: blockContentType,
            span: spanType,
            inlineObjects: inlineObjectTypes,
            blockObjects: blockObjectTypes,
        },
    };
}
function resolveEnabledStyles(blockType) {
    var styleField = blockType.fields.find(isStyleObjectField);
    if (!styleField) {
        throw new Error("A field with name 'style' is not defined in the block type (required).");
    }
    var textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
    if (textStyles.length === 0) {
        throw new Error('The style fields need at least one style ' +
            "defined. I.e: {title: 'Normal', value: 'normal'}.");
    }
    return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
    return spanType.annotations.map(function (annotation) { return ({
        blockEditor: annotation.blockEditor,
        title: annotation.title,
        type: annotation,
        value: annotation.name,
        icon: annotation.icon,
    }); });
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    var listField = blockType.fields.find(isListObjectField);
    if (!listField) {
        throw new Error("A field with name 'list' is not defined in the block type (required).");
    }
    var listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
    if (!listItems) {
        throw new Error('The list field need at least to be an empty array');
    }
    return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
    var list = options ? options.list : undefined;
    if (!Array.isArray(list)) {
        return [];
    }
    return list.map(function (item) { return (isTitledListValue(item) ? item : { title: item, value: item }); });
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var toString = Object.prototype.toString;
// Copied from https://github.com/ForbesLindesay/type-of
// but inlined to have fine grained control
function resolveJsType(val) {
    switch (toString.call(val)) {
        case '[object Function]':
            return 'function';
        case '[object Date]':
            return 'date';
        case '[object RegExp]':
            return 'regexp';
        case '[object Arguments]':
            return 'arguments';
        case '[object Array]':
            return 'array';
        case '[object String]':
            return 'string';
    }
    if (val === null) {
        return 'null';
    }
    if (val === undefined) {
        return 'undefined';
    }
    if (val &&
        typeof val === 'object' &&
        'nodeType' in val &&
        val.nodeType === 1) {
        return 'element';
    }
    if (val === Object(val)) {
        return 'object';
    }
    return typeof val;
}

// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html
function whatwgRNG(length) {
    if (length === void 0) { length = 16; }
    var rnds8 = new Uint8Array(length);
    getRandomValues(rnds8);
    return rnds8;
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substring(1);
}
/**
 * Generate a random key of the given length
 *
 * @param length - Length of string to generate
 * @returns A string of the given length
 * @public
 */
function randomKey(length) {
    return whatwgRNG(length)
        .reduce(function (str, n) { return str + byteToHex[n]; }, '')
        .slice(0, length);
}

var BLOCK_DEFAULT_STYLE = 'normal';
var DEFAULT_BLOCK = Object.freeze({
    _type: 'block',
    markDefs: [],
    style: BLOCK_DEFAULT_STYLE,
});
var DEFAULT_SPAN = Object.freeze({
    _type: 'span',
    marks: [],
});
var HTML_BLOCK_TAGS = {
    p: DEFAULT_BLOCK,
    blockquote: __assign(__assign({}, DEFAULT_BLOCK), { style: 'blockquote' }),
};
var HTML_SPAN_TAGS = {
    span: { object: 'text' },
};
var HTML_LIST_CONTAINER_TAGS = {
    ol: { object: null },
    ul: { object: null },
};
var HTML_HEADER_TAGS = {
    h1: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h1' }),
    h2: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h2' }),
    h3: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h3' }),
    h4: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h4' }),
    h5: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h5' }),
    h6: __assign(__assign({}, DEFAULT_BLOCK), { style: 'h6' }),
};
var HTML_MISC_TAGS = {
    br: __assign(__assign({}, DEFAULT_BLOCK), { style: BLOCK_DEFAULT_STYLE }),
};
var HTML_DECORATOR_TAGS = {
    b: 'strong',
    strong: 'strong',
    i: 'em',
    em: 'em',
    u: 'underline',
    s: 'strike-through',
    strike: 'strike-through',
    del: 'strike-through',
    code: 'code',
};
var HTML_LIST_ITEM_TAGS = {
    li: __assign(__assign({}, DEFAULT_BLOCK), { style: BLOCK_DEFAULT_STYLE, level: 1, listItem: 'bullet' }),
};
var ELEMENT_MAP = __assign(__assign(__assign(__assign(__assign(__assign({}, HTML_BLOCK_TAGS), HTML_SPAN_TAGS), HTML_LIST_CONTAINER_TAGS), HTML_LIST_ITEM_TAGS), HTML_HEADER_TAGS), HTML_MISC_TAGS);
uniq(Object.values(ELEMENT_MAP)
    .filter(function (tag) { return 'style' in tag; })
    .map(function (tag) { return tag.style; }));
uniq(Object.values(HTML_DECORATOR_TAGS));

// We need this here if run server side
var _XPathResult = {
    ANY_TYPE: 0,
    NUMBER_TYPE: 1,
    STRING_TYPE: 2,
    BOOLEAN_TYPE: 3,
    UNORDERED_NODE_ITERATOR_TYPE: 4,
    ORDERED_NODE_ITERATOR_TYPE: 5,
    UNORDERED_NODE_SNAPSHOT_TYPE: 6,
    ORDERED_NODE_SNAPSHOT_TYPE: 7,
    ANY_UNORDERED_NODE_TYPE: 8,
    FIRST_ORDERED_NODE_TYPE: 9,
};

// Remove this cruft from the document
var unwantedWordDocumentPaths = [
    '/html/text()',
    '/html/head/text()',
    '/html/body/text()',
    '/html/body/ul/text()',
    '/html/body/ol/text()',
    '//comment()',
    '//style',
    '//xml',
    '//script',
    '//meta',
    '//link',
];
var preprocessHTML = (function (html, doc) {
    var _a, _b, _c;
    // Make sure text directly on the body is wrapped in spans.
    // This mimics what the browser does before putting html on the clipboard,
    // when used in a script context with JSDOM
    var bodyTextNodes = doc.evaluate('/html/body/text()', doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
        var node = bodyTextNodes.snapshotItem(i);
        var text = node.textContent || '';
        if (text.replace(/[^\S\n]+$/g, '')) {
            var newNode = doc.createElement('span');
            newNode.appendChild(doc.createTextNode(text));
            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(newNode, node);
        }
        else {
            (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(node);
        }
    }
    var unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join('|'), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
        var unwanted = unwantedNodes.snapshotItem(i);
        if (!unwanted) {
            continue;
        }
        (_c = unwanted.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(unwanted);
    }
    return doc;
});

var WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/;
// xPaths for elements that will be removed from the document
var unwantedPaths = [
    '//o:p',
    "//span[@style='mso-list:Ignore']",
    "//span[@style='mso-list: Ignore']",
];
// xPaths for elements that needs to be remapped into other tags
var mappedPaths = [
    "//p[@class='MsoTocHeading']",
    "//p[@class='MsoTitle']",
    "//p[@class='MsoToaHeading']",
    "//p[@class='MsoSubtitle']",
    "//span[@class='MsoSubtleEmphasis']",
    "//span[@class='MsoIntenseEmphasis']",
];
// Which HTML element(s) to map the elements matching mappedPaths into
var elementMap = {
    MsoTocHeading: ['h3'],
    MsoTitle: ['h1'],
    MsoToaHeading: ['h2'],
    MsoSubtitle: ['h5'],
    MsoSubtleEmphasis: ['span', 'em'],
    MsoIntenseEmphasis: ['span', 'em', 'strong'],
    // Remove cruft
};
function isWordHtml(html) {
    return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (function (html, doc) {
    var _a;
    if (!isWordHtml(html)) {
        return doc;
    }
    var unwantedNodes = doc.evaluate(unwantedPaths.join('|'), doc, function (prefix) {
        if (prefix === 'o') {
            return 'urn:schemas-microsoft-com:office:office';
        }
        return null;
    }, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
        var unwanted = unwantedNodes.snapshotItem(i);
        if (unwanted === null || unwanted === void 0 ? void 0 : unwanted.parentNode) {
            unwanted.parentNode.removeChild(unwanted);
        }
    }
    // Transform mapped elements into what they should be mapped to
    var mappedElements = doc.evaluate(mappedPaths.join('|'), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    var _loop_1 = function (i) {
        var mappedElm = mappedElements.snapshotItem(i);
        var tags = elementMap[mappedElm.className];
        var text = new Text(mappedElm.textContent || '');
        if (!tags) {
            return "continue";
        }
        var parentElement = document.createElement(tags[0]);
        var parent_1 = parentElement;
        var child = parentElement;
        tags.slice(1).forEach(function (tag) {
            child = document.createElement(tag);
            parent_1.appendChild(child);
            parent_1 = child;
        });
        child.appendChild(text);
        (_a = mappedElm === null || mappedElm === void 0 ? void 0 : mappedElm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(parentElement, mappedElm);
    };
    for (var i = mappedElements.snapshotLength - 1; i >= 0; i--) {
        _loop_1(i);
    }
    return doc;
});

function isGoogleDocsDocument(el) {
    if (el.nodeType !== 1) {
        return false;
    }
    var id = el.getAttribute('id');
    return id && id.match(/^docs-internal-guid-/) && el.tagName === 'B';
}
var preprocessGDocs = (function (html, doc) {
    var _a;
    if (doc.body.firstElementChild && isGoogleDocsDocument(doc.body.firstElementChild)) {
        // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can
        // work exclusivly on these children
        var childNodes = doc.evaluate('//*', doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
        for (var i = childNodes.snapshotLength - 1; i >= 0; i--) {
            var elm = childNodes.snapshotItem(i);
            elm === null || elm === void 0 ? void 0 : elm.setAttribute('data-is-google-docs', 'true');
        }
        // Remove that 'b' which Google Docs wraps the HTML content in
        (_a = doc.body.firstElementChild).replaceWith.apply(_a, __spreadArray([], __read(Array.from(doc.body.firstElementChild.childNodes)), false));
        return doc;
    }
    return doc;
});

var preprocessors = [preprocessWord, preprocessGDocs, preprocessHTML];

/**
 * A utility function to create the options needed for the various rule sets,
 * based on the structure of the blockContentType
 *
 * @param blockContentType - Schema type for array containing _at least_ a block child type
 * @returns
 */
function createRuleOptions(blockContentType) {
    var features = blockContentFeatures(blockContentType);
    var enabledBlockStyles = features.styles.map(function (item) { return item.value || item.title; });
    var enabledSpanDecorators = features.decorators.map(function (item) { return item.value || item.title; });
    var enabledBlockAnnotations = features.annotations.map(function (item) { return item.value || item.title || ''; });
    return {
        enabledBlockStyles: enabledBlockStyles,
        enabledSpanDecorators: enabledSpanDecorators,
        enabledBlockAnnotations: enabledBlockAnnotations,
    };
}
/**
 * Utility function that always return a lowerCase version of the element.tagName
 *
 * @param el - Element to get tag name for
 * @returns Lowercase tagName for that element, or undefined if not an element
 */
function tagName(el) {
    if (el && 'tagName' in el) {
        return el.tagName.toLowerCase();
    }
    return undefined;
}
// TODO: make this plugin-style
function preprocess(html, parseHtml) {
    var compactHtml = html
        .trim() // Trim whitespace
        .replace(/\s\s+/g, ' ') // Remove multiple whitespace
        .replace(/[\r\n]/g, ' '); // Remove newlines / carriage returns
    var doc = parseHtml(compactHtml);
    preprocessors.forEach(function (processor) {
        processor(html, doc);
    });
    return doc;
}
/**
 * A default `parseHtml` function that returns the html using `DOMParser`.
 *
 * @returns HTML Parser based on `DOMParser`
 */
function defaultParseHtml() {
    if (resolveJsType(DOMParser) === 'undefined') {
        throw new Error('The native `DOMParser` global which the `Html` deserializer uses by ' +
            'default is not present in this environment. ' +
            'You must supply the `options.parseHtml` function instead.');
    }
    return function (html) {
        return new DOMParser().parseFromString(html, 'text/html');
    };
}
function flattenNestedBlocks(blocks) {
    var depth = 0;
    var flattened = [];
    var traverse = function (nodes) {
        var toRemove = [];
        nodes.forEach(function (node) {
            if (depth === 0) {
                flattened.push(node);
            }
            if (isBlock(node)) {
                if (depth > 0) {
                    toRemove.push(node);
                    flattened.push(node);
                }
                depth++;
                traverse(node.children);
            }
            if (node._type === '__block') {
                toRemove.push(node);
                flattened.push(node.block);
            }
        });
        toRemove.forEach(function (node) {
            nodes.splice(nodes.indexOf(node), 1);
        });
        depth--;
    };
    traverse(blocks);
    return flattened;
}
function nextSpan(block, index) {
    var next = block.children[index + 1];
    return next && next._type === 'span' ? next : null;
}
function prevSpan(block, index) {
    var prev = block.children[index - 1];
    return prev && prev._type === 'span' ? prev : null;
}
function isWhiteSpaceChar(text) {
    return ['\xa0', ' '].includes(text);
}
/**
 * NOTE: _mutates_ passed blocks!
 *
 * @param blocks - Array of blocks to trim whitespace for
 * @returns
 */
function trimWhitespace(blocks) {
    blocks.forEach(function (block) {
        if (!isBlock(block)) {
            return;
        }
        // eslint-disable-next-line complexity
        block.children.forEach(function (child, index) {
            if (child._type !== 'span') {
                return;
            }
            var nextChild = nextSpan(block, index);
            var prevChild = prevSpan(block, index);
            if (index === 0) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (index === block.children.length - 1) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(child.text.length - 1)) &&
                nextChild &&
                /\s/.test(nextChild.text.substring(0, 1))) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(0, 1)) &&
                prevChild &&
                /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (!child.text) {
                block.children.splice(index, 1);
            }
            if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
                prevChild.text += ' ';
                block.children.splice(index, 1);
            }
            else if (nextChild &&
                isEqual(nextChild.marks, child.marks) &&
                isWhiteSpaceChar(child.text)) {
                nextChild.text = " ".concat(nextChild.text);
                block.children.splice(index, 1);
            }
        });
    });
    return blocks;
}
function ensureRootIsBlocks(blocks) {
    return blocks.reduce(function (memo, node, i, original) {
        if (node._type === 'block') {
            memo.push(node);
            return memo;
        }
        if (node._type === '__block') {
            memo.push(node.block);
            return memo;
        }
        var lastBlock = memo[memo.length - 1];
        if (i > 0 && !isBlock(original[i - 1]) && isBlock(lastBlock)) {
            lastBlock.children.push(node);
            return memo;
        }
        var block = __assign(__assign({}, DEFAULT_BLOCK), { children: [node] });
        memo.push(block);
        return memo;
    }, []);
}
function isNodeList(node) {
    return Object.prototype.toString.call(node) == '[object NodeList]';
}
function isMinimalSpan(node) {
    return node._type === 'span';
}
function isMinimalBlock(node) {
    return node._type === 'block';
}
function isPlaceholderDecorator(node) {
    return node._type === '__decorator';
}
function isPlaceholderAnnotation(node) {
    return node._type === '__annotation';
}
function isElement(node) {
    return node.nodeType === 1;
}

function resolveListItem(listNodeTagName) {
    var listStyle;
    switch (listNodeTagName) {
        case 'ul':
            listStyle = 'bullet';
            break;
        case 'ol':
            listStyle = 'number';
            break;
        default:
            listStyle = 'bullet';
    }
    return listStyle;
}
function createHTMLRules(blockContentType, options) {
    return [
        // Text nodes
        {
            deserialize: function (el) {
                var isValidWhiteSpace = el.nodeType === 3 &&
                    (el.textContent || '').replace(/[\r\n]/g, ' ').replace(/\s\s+/g, ' ') === ' ' &&
                    el.nextSibling &&
                    el.nextSibling.nodeType !== 3 &&
                    el.previousSibling &&
                    el.previousSibling.nodeType !== 3;
                var isValidText = (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body';
                if (el.nodeName === '#text' && isValidText) {
                    return __assign(__assign({}, DEFAULT_SPAN), { marks: [], text: (el.textContent || '').replace(/\s\s+/g, ' ') });
                }
                return undefined;
            },
        },
        {
            deserialize: function (el, next) {
                if (tagName(el) !== 'blockquote') {
                    return undefined;
                }
                var blocks = __assign(__assign({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
                delete blocks.blockquote;
                var children = [];
                el.childNodes.forEach(function (node, index) {
                    if (node.nodeType === 1 &&
                        Object.keys(blocks).includes(node.localName.toLowerCase())) {
                        if (!el.ownerDocument) {
                            return;
                        }
                        var span_1 = el.ownerDocument.createElement('span');
                        span_1.appendChild(el.ownerDocument.createTextNode('\r'));
                        node.childNodes.forEach(function (cn) {
                            span_1.appendChild(cn.cloneNode(true));
                        });
                        if (index !== el.childNodes.length) {
                            span_1.appendChild(el.ownerDocument.createTextNode('\r'));
                        }
                        children.push(span_1);
                    }
                    else {
                        children.push(node);
                    }
                });
                return {
                    _type: 'block',
                    style: 'blockquote',
                    markDefs: [],
                    children: next(children),
                };
            },
        },
        {
            deserialize: function (el, next) {
                var blocks = __assign(__assign({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
                var tag = tagName(el);
                var block = tag ? blocks[tag] : undefined;
                if (!block) {
                    return undefined;
                }
                // Don't add blocks into list items
                if (el.parentNode && tagName(el) === 'li') {
                    return next(el.childNodes);
                }
                // If style is not supported, return a defaultBlockType
                if (!options.enabledBlockStyles.includes(block.style)) {
                    block = DEFAULT_BLOCK;
                }
                return __assign(__assign({}, block), { children: next(el.childNodes) });
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                if (!tag || !(tag in HTML_SPAN_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el, next) {
                var div = tagName(el) === 'div';
                if (!div) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize: function (el) {
                if (tagName(el) === 'br') {
                    return __assign(__assign({}, DEFAULT_SPAN), { text: '\n' });
                }
                return undefined;
            },
        },
        {
            deserialize: function (el, next) {
                var tag = tagName(el);
                var listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined;
                var parentTag = tagName(el.parentNode) || '';
                if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
                    return undefined;
                }
                listItem.listItem = resolveListItem(parentTag);
                return __assign(__assign({}, listItem), { children: next(el.childNodes) });
            },
        },
        {
            deserialize: function (el, next) {
                var decorator = HTML_DECORATOR_TAGS[tagName(el) || ''];
                if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
                    return undefined;
                }
                return {
                    _type: '__decorator',
                    name: decorator,
                    children: next(el.childNodes),
                };
            },
        },
        // If not supported just write out the link text and href in plain text.
        {
            deserialize: function (el, next) {
                if (tagName(el) != 'a') {
                    return undefined;
                }
                var linkEnabled = options.enabledBlockAnnotations.includes('link');
                var href = isElement(el) && el.getAttribute('href');
                if (!href) {
                    return next(el.childNodes);
                }
                var markDef;
                if (linkEnabled) {
                    markDef = {
                        _key: randomKey(12),
                        _type: 'link',
                        href: href,
                    };
                    return {
                        _type: '__annotation',
                        markDef: markDef,
                        children: next(el.childNodes),
                    };
                }
                return el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
            },
        },
    ];
}

var LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
// font-style:italic seems like the most important rule for italic / emphasis in their html
function isEmphasis(el) {
    var style = isElement(el) && el.getAttribute('style');
    return /font-style:italic/.test(style || '');
}
// font-weight:700 seems like the most important rule for bold in their html
function isStrong(el) {
    var style = isElement(el) && el.getAttribute('style');
    return /font-weight:700/.test(style || '');
}
// Check for attribute given by the gdocs preprocessor
function isGoogleDocs(el) {
    return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'));
}
function getListItemStyle$1(el) {
    var parentTag = tagName(el.parentNode);
    if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {
        return undefined;
    }
    return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number';
}
function getListItemLevel$1(el) {
    var level = 0;
    if (tagName(el) === 'li') {
        var parentNode = el.parentNode;
        while (parentNode) {
            var parentTag = tagName(parentNode);
            if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {
                level++;
            }
            parentNode = parentNode.parentNode;
        }
    }
    else {
        level = 1;
    }
    return level;
}
var blocks = __assign(__assign({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
function getBlockStyle(el, enabledBlockStyles) {
    var childTag = tagName(el.firstChild);
    var block = childTag && blocks[childTag];
    if (!block) {
        return BLOCK_DEFAULT_STYLE;
    }
    if (!enabledBlockStyles.includes(block.style)) {
        return BLOCK_DEFAULT_STYLE;
    }
    return block.style;
}
function createGDocsRules(_blockContentType, options) {
    return [
        {
            deserialize: function (el) {
                if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {
                    var span = __assign(__assign({}, DEFAULT_SPAN), { marks: [], text: el.innerText });
                    if (isStrong(el)) {
                        span.marks.push('strong');
                    }
                    if (isEmphasis(el)) {
                        span.marks.push('em');
                    }
                    return span;
                }
                return undefined;
            },
        },
        {
            deserialize: function (el, next) {
                var _a;
                if (tagName(el) === 'li' && isGoogleDocs(el)) {
                    return __assign(__assign({}, DEFAULT_BLOCK), { listItem: getListItemStyle$1(el), level: getListItemLevel$1(el), style: getBlockStyle(el, options.enabledBlockStyles), children: next(((_a = el.firstChild) === null || _a === void 0 ? void 0 : _a.childNodes) || []) });
                }
                return undefined;
            },
        },
    ];
}

function getListItemStyle(el) {
    var style = isElement(el) && el.getAttribute('style');
    if (!style) {
        return undefined;
    }
    if (!style.match(/lfo\d+/)) {
        return undefined;
    }
    return style.match('lfo1') ? 'bullet' : 'number';
}
function getListItemLevel(el) {
    var style = isElement(el) && el.getAttribute('style');
    if (!style) {
        return undefined;
    }
    var levelMatch = style.match(/level\d+/);
    if (!levelMatch) {
        return undefined;
    }
    var _a = __read(levelMatch[0].match(/\d/) || [], 1), level = _a[0];
    var levelNum = level ? parseInt(level, 10) : 1;
    return levelNum || 1;
}
function isWordListElement(el) {
    return isElement(el) && el.className
        ? el.className === 'MsoListParagraphCxSpFirst' ||
            el.className === 'MsoListParagraphCxSpMiddle' ||
            el.className === 'MsoListParagraphCxSpLast'
        : false;
}
function createWordRules() {
    return [
        {
            deserialize: function (el, next) {
                if (tagName(el) === 'p' && isWordListElement(el)) {
                    return __assign(__assign({}, DEFAULT_BLOCK), { listItem: getListItemStyle(el), level: getListItemLevel(el), style: BLOCK_DEFAULT_STYLE, children: next(el.childNodes) });
                }
                return undefined;
            },
        },
    ];
}

function createRules(blockContentType, options) {
    return __spreadArray(__spreadArray(__spreadArray([], __read(createWordRules()), false), __read(createGDocsRules(blockContentType, options)), false), __read(createHTMLRules(blockContentType, options)), false);
}

/**
 * HTML Deserializer
 *
 */
var HtmlDeserializer = /** @class */ (function () {
    /**
     * Create a new serializer respecting a Sanity block content type's schema
     *
     * @param blockContentType - Schema type for array containing _at least_ a block child type
     * @param options - Options for the deserialization process
     */
    function HtmlDeserializer(blockContentType, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._markDefs = [];
        /**
         * Deserialize HTML.
         *
         * @param html - The HTML to deserialize, as a string
         * @returns Array of blocks - either portable text blocks or other allowed blocks
         */
        this.deserialize = function (html) {
            _this._markDefs = [];
            var parseHtml = _this.parseHtml;
            var fragment = parseHtml(html);
            var children = Array.from(fragment.childNodes);
            // Ensure that there are no blocks within blocks, and trim whitespace
            var blocks = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(_this.deserializeElements(children))));
            if (_this._markDefs.length > 0) {
                blocks
                    .filter(function (block) { return block._type === 'block'; })
                    .forEach(function (block) {
                    block.markDefs = block.markDefs || [];
                    block.markDefs = block.markDefs.concat(_this._markDefs.filter(function (def) {
                        return flatten(block.children.map(function (child) { return child.marks || []; })).includes(def._key);
                    }));
                });
            }
            // Set back the potentially hoisted block type
            var type = _this.blockContentType.of.find(findBlockType);
            if (!type) {
                return blocks;
            }
            return blocks.map(function (block) {
                if (block._type === 'block') {
                    block._type = type.name;
                }
                return block;
            });
        };
        /**
         * Deserialize an array of DOM elements.
         *
         * @param elements - Array of DOM elements to deserialize
         * @returns
         */
        this.deserializeElements = function (elements) {
            if (elements === void 0) { elements = []; }
            var nodes = [];
            elements.forEach(function (element) {
                nodes = nodes.concat(_this.deserializeElement(element));
            });
            return nodes;
        };
        /**
         * Deserialize a DOM element
         *
         * @param element - Deserialize a DOM element
         * @returns
         */
        this.deserializeElement = function (element) {
            var _a, _b;
            var next = function (elements) {
                if (isNodeList(elements)) {
                    return _this.deserializeElements(Array.from(elements));
                }
                if (Array.isArray(elements)) {
                    return _this.deserializeElements(elements);
                }
                if (!elements) {
                    return undefined;
                }
                return _this.deserializeElement(elements);
            };
            var block = function (props) {
                return {
                    _type: '__block',
                    block: props,
                };
            };
            var node;
            var _loop_1 = function (i) {
                var rule = _this.rules[i];
                if (!rule.deserialize) {
                    return "continue";
                }
                var ret = rule.deserialize(element, next, block);
                var type = resolveJsType(ret);
                if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {
                    throw new Error("A rule returned an invalid deserialized representation: \"".concat(node, "\"."));
                }
                if (ret === undefined) {
                    return "continue";
                }
                else if (ret === null) {
                    throw new Error('Deserializer rule returned `null`');
                }
                else if (Array.isArray(ret)) {
                    node = ret;
                }
                else if (isPlaceholderDecorator(ret)) {
                    node = _this.deserializeDecorator(ret);
                }
                else if (isPlaceholderAnnotation(ret)) {
                    node = _this.deserializeAnnotation(ret);
                }
                else {
                    node = ret;
                }
                // Set list level on list item
                if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {
                    var parent_1 = (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode;
                    while (parent_1 && tagName(parent_1) === 'li') {
                        parent_1 = (_b = parent_1.parentNode) === null || _b === void 0 ? void 0 : _b.parentNode;
                        ret.level = ret.level ? ret.level + 1 : 1;
                    }
                }
                // Set newlines on spans orginating from a block element within a blockquote
                if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {
                    ret.children.forEach(function (child, index) {
                        if (isMinimalSpan(child) && child.text === '\r') {
                            child.text = '\n\n';
                            if (index === 0 || index === ret.children.length - 1) {
                                ret.children.splice(index, 1);
                            }
                        }
                    });
                }
                return "break";
            };
            for (var i = 0; i < _this.rules.length; i++) {
                var state_1 = _loop_1(i);
                if (state_1 === "break")
                    break;
            }
            return node || next(element.childNodes) || [];
        };
        /**
         * Deserialize a `__decorator` type
         * (an internal made up type to process decorators exclusively)
         *
         * @param decorator -
         * @returns array of ...
         */
        this.deserializeDecorator = function (decorator) {
            var name = decorator.name;
            var applyDecorator = function (node) {
                if (isPlaceholderDecorator(node)) {
                    return _this.deserializeDecorator(node);
                }
                else if (isMinimalSpan(node)) {
                    node.marks = node.marks || [];
                    if (node.text.trim()) {
                        // Only apply marks if this is an actual text
                        node.marks.unshift(name);
                    }
                }
                else if ('children' in node && Array.isArray(node.children)) {
                    var block = node;
                    block.children = block.children.map(applyDecorator);
                }
                return node;
            };
            return decorator.children.reduce(function (children, node) {
                var ret = applyDecorator(node);
                if (Array.isArray(ret)) {
                    return children.concat(ret);
                }
                children.push(ret);
                return children;
            }, []);
        };
        /**
         * Deserialize a `__annotation` object.
         * (an internal made up type to process annotations exclusively)
         *
         * @param annotation -
         * @returns Array of...
         */
        this.deserializeAnnotation = function (annotation) {
            var markDef = annotation.markDef;
            _this._markDefs.push(markDef);
            var applyAnnotation = function (node) {
                if (isPlaceholderAnnotation(node)) {
                    return _this.deserializeAnnotation(node);
                }
                else if (isMinimalSpan(node)) {
                    node.marks = node.marks || [];
                    if (node.text.trim()) {
                        // Only apply marks if this is an actual text
                        node.marks.unshift(markDef._key);
                    }
                }
                else if ('children' in node && Array.isArray(node.children)) {
                    var block = node;
                    block.children = block.children.map(applyAnnotation);
                }
                return node;
            };
            return annotation.children.reduce(function (children, node) {
                var ret = applyAnnotation(node);
                if (Array.isArray(ret)) {
                    return children.concat(ret);
                }
                children.push(ret);
                return children;
            }, []);
        };
        var _a = options.rules, rules = _a === void 0 ? [] : _a;
        if (!blockContentType) {
            throw new Error("Parameter 'blockContentType' is required");
        }
        var standardRules = createRules(blockContentType, createRuleOptions(blockContentType));
        this.rules = __spreadArray(__spreadArray([], __read(rules), false), __read(standardRules), false);
        var parseHtml = options.parseHtml || defaultParseHtml();
        this.blockContentType = blockContentType;
        this.parseHtml = function (html) {
            var doc = preprocess(html, parseHtml);
            return doc.body;
        };
    }
    return HtmlDeserializer;
}());

/**
 * Normalizes a block by ensuring it has a `_key` property. If the block is a
 * portable text block, additional normalization is applied:
 *
 * - Ensures it has `children` and `markDefs` properties
 * - Ensures it has at least one child (adds an empty span if empty)
 * - Joins sibling spans that has the same marks
 * - Removes decorators that are not allowed according to the schema
 * - Removes marks that have no annotation definition
 *
 * @param node - The block to normalize
 * @param options - Options for normalization process. See {@link BlockNormalizationOptions}
 * @returns Normalized block
 * @public
 */
function normalizeBlock(node, options) {
    if (options === void 0) { options = {}; }
    if (node._type !== (options.blockTypeName || 'block')) {
        return '_key' in node ? node : __assign(__assign({}, node), { _key: randomKey(12) });
    }
    var block = __assign({ _key: randomKey(12), children: [], markDefs: [] }, node);
    var lastChild = block.children[block.children.length - 1];
    if (!lastChild) {
        // A block must at least have an empty span type child
        block.children = [
            {
                _type: 'span',
                _key: "".concat(block._key).concat(0),
                text: '',
                marks: [],
            },
        ];
        return block;
    }
    var usedMarkDefs = [];
    var allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators)
        ? options.allowedDecorators
        : false;
    block.children = block.children
        .reduce(function (acc, child) {
        var previousChild = acc[acc.length - 1];
        if (previousChild &&
            isSpan(child) &&
            isSpan(previousChild) &&
            isEqual(previousChild.marks, child.marks)) {
            if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {
                return acc;
            }
            previousChild.text += child.text;
            return acc;
        }
        acc.push(child);
        return acc;
    }, [])
        .map(function (child, index) {
        if (!child) {
            throw new Error('missing child');
        }
        child._key = "".concat(block._key).concat(index);
        if (isSpan(child)) {
            if (!child.marks) {
                child.marks = [];
            }
            else if (allowedDecorators) {
                child.marks = child.marks.filter(function (mark) {
                    var isAllowed = allowedDecorators.includes(mark);
                    var isUsed = block.markDefs.some(function (def) { return def._key === mark; });
                    return isAllowed || isUsed;
                });
            }
            usedMarkDefs.push.apply(usedMarkDefs, __spreadArray([], __read(child.marks), false));
        }
        return child;
    });
    // Remove leftover (unused) markDefs
    block.markDefs = block.markDefs.filter(function (markDef) { return usedMarkDefs.includes(markDef._key); });
    return block;
}

/**
 * Convert HTML to blocks respecting the block content type's schema
 *
 * @param html - The HTML to convert to blocks
 * @param blockContentType - A compiled version of the schema type for the block content
 * @param options - Options for deserializing HTML to blocks
 * @returns Array of blocks
 * @public
 */
function htmlToBlocks(html, blockContentType, options) {
    if (options === void 0) { options = {}; }
    var deserializer = new HtmlDeserializer(blockContentType, options);
    return deserializer.deserialize(html).map(function (block) { return normalizeBlock(block); });
}
/**
 * Normalize and extract features of an schema type containing a block type
 *
 * @param blockContentType - Schema type for the block type
 * @returns Returns the featureset of a compiled block content type.
 * @public
 */
function getBlockContentFeatures(blockContentType) {
    return blockContentFeatures(blockContentType);
}

export { getBlockContentFeatures, htmlToBlocks, normalizeBlock, randomKey };
//# sourceMappingURL=index.js.map
