'use strict';

function isObject(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
}

function isReference(reference) {
    return isObject(reference) && typeof reference._ref === 'string';
}

function isImage(value) {
    return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith('image-');
}

function isCrossDatasetReference(reference) {
    return (isObject(reference) &&
        typeof reference._ref === 'string' &&
        typeof reference._dataset === 'string' &&
        typeof reference._projectId === 'string');
}

function isSanityDocument(document) {
    return (isObject(document) && typeof document._id === 'string' && typeof document._type === 'string');
}
function isTypedObject(obj) {
    return isObject(obj) && typeof obj._type === 'string';
}
function isKeyedObject(obj) {
    return isObject(obj) && typeof obj._key === 'string';
}

function isValidationErrorMarker(marker) {
    return marker.level === 'error';
}
function isValidationWarningMarker(marker) {
    return marker.level === 'warning';
}
function isValidationInfoMarker(marker) {
    return marker.level === 'info';
}

function isCreateMutation(mutation) {
    return 'create' in mutation;
}
function isCreateIfNotExistsMutation(mutation) {
    return 'createIfNotExists' in mutation;
}
function isCreateOrReplaceMutation(mutation) {
    return 'createOrReplace' in mutation;
}
function isDeleteMutation(mutation) {
    return 'delete' in mutation;
}
function isPatchMutation(mutation) {
    return 'patch' in mutation;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

var reKeySegment = /_key\s*==\s*['"](.*)['"]/;
var reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment === 'number' || (typeof segment === 'string' && /^\[\d+\]$/.test(segment));
}
function isKeySegment(segment) {
    if (typeof segment === 'string') {
        return reKeySegment.test(segment.trim());
    }
    return typeof segment === 'object' && '_key' in segment;
}
function isIndexTuple(segment) {
    if (typeof segment === 'string' && reIndexTuple.test(segment)) {
        return true;
    }
    if (!Array.isArray(segment) || segment.length !== 2) {
        return false;
    }
    var _a = __read(segment, 2), from = _a[0], to = _a[1];
    return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '');
}

function isRecord$1(value) {
    return !!value && (typeof value == 'object' || typeof value == 'function');
}
function isBlock(value) {
    return (isRecord$1(value) &&
        typeof value._type === 'string' && // block types can be named, so expect anything here.
        typeof value.style === 'string' &&
        Array.isArray(value.children) &&
        Array.isArray(value.markDefs));
}
function isSpan(value) {
    return (isRecord$1(value) &&
        value._type === 'span' &&
        typeof value.text === 'string' &&
        Array.isArray(value.marks));
}

function defineType(schemaDefinition) {
    return schemaDefinition;
}
function defineField(schemaField) {
    return schemaField;
}

function isRecord(value) {
    return !!value && (typeof value == 'object' || typeof value == 'function');
}
/**
 * Returns wether or not the given type is a document type
 * (eg that it was defined as `type: 'document'`)
 *
 * @param type - Schema type to test
 * @returns True if type is a document type, false otherwise
 * @public
 */
function isDocumentSchemaType(type) {
    if (!isObjectSchemaType(type)) {
        return false;
    }
    var current = type;
    while (current) {
        if (current.name === 'document') {
            return true;
        }
        current = current.type;
    }
    return false;
}
function isObjectSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'object';
}
function isArraySchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'array';
}
function isArrayOfObjectsSchemaType(type) {
    return isArraySchemaType(type) && type.of.every(function (memberType) { return isObjectSchemaType(memberType); });
}
function isArrayOfPrimitivesSchemaType(type) {
    return isArraySchemaType(type) && type.of.every(function (memberType) { return isPrimitiveSchemaType(memberType); });
}
function isBooleanSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'boolean';
}
function isStringSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'string';
}
function isNumberSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'number';
}
function isPrimitiveSchemaType(type) {
    return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type));
}
function isCrossDatasetReferenceSchemaType(type) {
    return (isRecord(type) &&
        (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type)));
}
function isTitledListValue(item) {
    return typeof item === 'object' && item !== null && 'title' in item && 'value' in item;
}
function isSpanSchemaType(type) {
    if (!isRecord(type))
        return false;
    // we check for `annotations` and `decorators` instead of `type.name` because
    // schema names can technically change if someone extends the type
    return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType(type) {
    if (!isRecord(type))
        return false;
    if (!Array.isArray(type.fields))
        return false;
    var _a = __read(type.fields, 3), maybeSpanChildren = _a[0], maybeStyle = _a[1], maybeList = _a[2];
    return (isBlockChildrenObjectField(maybeSpanChildren) &&
        isStyleObjectField(maybeStyle) &&
        isListObjectField(maybeList));
}
function isStyleObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'style')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
function isListObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'list')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
function isBlockChildrenObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'children')
        return false;
    if (!isArraySchemaType(field.type))
        return false;
    // there will always be a span item in `SpanChildrenObjectField`
    return field.type.of.some(isSpanSchemaType);
}

function isCreateSquashedMutation(mutation) {
    return 'createSquashed' in mutation;
}

function isValidationError(node) {
    return node.level === 'error';
}
function isValidationWarning(node) {
    return node.level === 'warning';
}
function isValidationInfo(node) {
    return node.level === 'info';
}

exports.defineField = defineField;
exports.defineType = defineType;
exports.isArrayOfObjectsSchemaType = isArrayOfObjectsSchemaType;
exports.isArrayOfPrimitivesSchemaType = isArrayOfPrimitivesSchemaType;
exports.isArraySchemaType = isArraySchemaType;
exports.isBlock = isBlock;
exports.isBlockChildrenObjectField = isBlockChildrenObjectField;
exports.isBlockSchemaType = isBlockSchemaType;
exports.isBooleanSchemaType = isBooleanSchemaType;
exports.isCreateIfNotExistsMutation = isCreateIfNotExistsMutation;
exports.isCreateMutation = isCreateMutation;
exports.isCreateOrReplaceMutation = isCreateOrReplaceMutation;
exports.isCreateSquashedMutation = isCreateSquashedMutation;
exports.isCrossDatasetReference = isCrossDatasetReference;
exports.isCrossDatasetReferenceSchemaType = isCrossDatasetReferenceSchemaType;
exports.isDeleteMutation = isDeleteMutation;
exports.isDocumentSchemaType = isDocumentSchemaType;
exports.isImage = isImage;
exports.isIndexSegment = isIndexSegment;
exports.isIndexTuple = isIndexTuple;
exports.isKeySegment = isKeySegment;
exports.isKeyedObject = isKeyedObject;
exports.isListObjectField = isListObjectField;
exports.isNumberSchemaType = isNumberSchemaType;
exports.isObjectSchemaType = isObjectSchemaType;
exports.isPatchMutation = isPatchMutation;
exports.isPrimitiveSchemaType = isPrimitiveSchemaType;
exports.isReference = isReference;
exports.isReferenceSchemaType = isReferenceSchemaType;
exports.isSanityDocument = isSanityDocument;
exports.isSpan = isSpan;
exports.isSpanSchemaType = isSpanSchemaType;
exports.isStringSchemaType = isStringSchemaType;
exports.isStyleObjectField = isStyleObjectField;
exports.isTitledListValue = isTitledListValue;
exports.isTypedObject = isTypedObject;
exports.isValidationError = isValidationError;
exports.isValidationErrorMarker = isValidationErrorMarker;
exports.isValidationInfo = isValidationInfo;
exports.isValidationInfoMarker = isValidationInfoMarker;
exports.isValidationWarning = isValidationWarning;
exports.isValidationWarningMarker = isValidationWarningMarker;
//# sourceMappingURL=index.cjs.map
