var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { flatten, isObject, uniq } from 'lodash';
import { set, unset, insert } from '../patch/PatchEvent';
export function validateValue(value, portableTextFeatures, keyGenerator) {
    var resolution = null;
    var valid = true;
    var validChildTypes = __spreadArray(__spreadArray([], [portableTextFeatures.types.span.name], false), __read(portableTextFeatures.types.inlineObjects.map(function (t) { return t.name; })), false);
    var validBlockTypes = __spreadArray(__spreadArray([], [portableTextFeatures.types.block.name], false), __read(portableTextFeatures.types.blockObjects.map(function (t) { return t.name; })), false);
    // Undefined is allowed
    if (value === undefined) {
        return { valid: true, resolution: null };
    }
    // Only lengthy arrays are allowed "inside" the editor.
    if (!Array.isArray(value) || value.length === 0) {
        return {
            valid: false,
            resolution: {
                patches: [unset([])],
                description: 'Editor value must be an array of Portable Text blocks, or undefined.',
                action: 'Unset the value',
                item: value,
            },
        };
    }
    if (value.some(function (blk, index) {
        if (!isObject(blk)) {
            resolution = {
                patches: [unset([index])],
                description: "Block must be an object, got ".concat(String(blk)),
                action: "Unset invalid item",
                item: blk,
            };
            return true;
        }
        // Test that every block has a _key
        if (!blk._key) {
            resolution = {
                patches: [set(__assign(__assign({}, blk), { _key: keyGenerator() }), [index])],
                description: "Block at index ".concat(index, " is missing required _key."),
                action: 'Set the block with a random _key value',
                item: blk,
            };
            return true;
        }
        // Test that every block has valid _type
        if (!blk._type || !validBlockTypes.includes(blk._type)) {
            // Special case where block type is set to default 'block', but the block type is named something else according to the schema.
            if (blk._type === 'block') {
                var currentBlockTypeName = portableTextFeatures.types.block.name;
                resolution = {
                    patches: [set(__assign(__assign({}, blk), { _type: currentBlockTypeName }), [{ _key: blk._key }])],
                    description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
                    action: "Use type '".concat(currentBlockTypeName, "'"),
                    item: blk,
                };
                return true;
            }
            resolution = {
                patches: [unset([{ _key: blk._key }])],
                description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
                action: 'Remove the block',
                item: blk,
            };
            return true;
        }
        // Test that every child in text block is valid
        if (blk._type === portableTextFeatures.types.block.name) {
            // Test that it has children
            if (!blk.children) {
                resolution = {
                    patches: [unset([{ _key: blk._key }])],
                    description: "Text block with _key '".concat(blk._key, "' is missing required key 'children'."),
                    action: 'Remove the block',
                    item: blk,
                };
                return true;
            }
            // Test that markDefs exists
            if (!blk.markDefs) {
                resolution = {
                    patches: [set(__assign(__assign({}, blk), { markDefs: [] }), [{ _key: blk._key }])],
                    description: "Block is missing required key 'markDefs'.",
                    action: 'Add empty markDefs array',
                    item: blk,
                };
                return true;
            }
            // // Test that every span has .marks
            // const spansWithUndefinedMarks = blk.children
            //   .filter(cld => cld._type === portableTextFeatures.types.span.name)
            //   .filter(cld => typeof cld.marks === 'undefined')
            // if (spansWithUndefinedMarks.length > 0) {
            //   const first = spansWithUndefinedMarks[0]
            //   resolution = {
            //     patches: [
            //       set({...first, marks: []}, [{_key: blk._key}, 'children', {_key: first._key}])
            //     ],
            //     description: `Span has no .marks array`,
            //     action: 'Add empty marks array',
            //     item: first
            //   }
            //   return true
            // }
            var allUsedMarks = uniq(flatten(blk.children
                .filter(function (cld) { return cld._type === portableTextFeatures.types.span.name; })
                .map(function (cld) { return cld.marks || []; })));
            // // Test that all markDefs are in use
            // if (blk.markDefs && blk.markDefs.length > 0) {
            //   const unusedMarkDefs: string[] = uniq(
            //     blk.markDefs.map(def => def._key).filter(key => !allUsedMarks.includes(key))
            //   )
            //   if (unusedMarkDefs.length > 0) {
            //     resolution = {
            //       patches: unusedMarkDefs.map(key =>
            //         unset([{_key: blk._key}, 'markDefs', {_key: key}])
            //       ),
            //       description: `Block has unused mark definitions: ${unusedMarkDefs.join(', ')}.`,
            //       action: 'Remove unused markDefs',
            //       item: blk
            //     }
            //     return true
            //   }
            // }
            // Test that every annotation mark used has a definition
            var annotationMarks = allUsedMarks.filter(function (mark) { return !portableTextFeatures.decorators.map(function (dec) { return dec.value; }).includes(mark); });
            var orphanedMarks_1 = annotationMarks.filter(function (mark) { return !blk.markDefs.find(function (def) { return def._key === mark; }); });
            if (orphanedMarks_1.length > 0) {
                var children = blk.children.filter(function (cld) {
                    return Array.isArray(cld.marks) &&
                        cld.marks.some(function (mark) { return orphanedMarks_1.includes(mark); });
                });
                if (children) {
                    resolution = {
                        patches: children.map(function (child) {
                            return set(child.marks.filter(function (cmrk) { return !orphanedMarks_1.includes(cmrk); }), [{ _key: blk._key }, 'children', { _key: child._key }, 'marks']);
                        }),
                        description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphanedMarks_1.join(', '), ") not supported by the current content model."),
                        action: 'Remove invalid marks',
                        item: blk,
                    };
                    return true;
                }
            }
            // Test that children is lengthy
            if (blk.children && blk.children.length === 0) {
                var newSpan = {
                    _type: portableTextFeatures.types.span.name,
                    _key: keyGenerator(),
                    text: '',
                };
                resolution = {
                    patches: [insert([newSpan], 'after', [{ _key: blk._key }, 'children', 0])],
                    description: "Children for text block with _key '".concat(blk._key, "' is empty."),
                    action: 'Insert an empty text',
                    item: blk,
                };
                return true;
            }
            // Test every child
            if (blk.children.some(function (child, cIndex) {
                if (!child._key) {
                    var newchild = __assign(__assign({}, child), { _key: keyGenerator() });
                    resolution = {
                        patches: [set(newchild, [{ _key: blk._key }, 'children', cIndex])],
                        description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
                        action: 'Set a new random _key on the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that childs have valid types
                if (!child._type || validChildTypes.includes(child._type) === false) {
                    resolution = {
                        patches: [unset([{ _key: blk._key }, 'children', { _key: child._key }])],
                        description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
                        action: 'Remove the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that spans have .text
                if (child._type === portableTextFeatures.types.span.name && child.text === undefined) {
                    resolution = {
                        patches: [
                            set(__assign(__assign({}, child), { text: '' }), [{ _key: blk._key }, 'children', { _key: child._key }]),
                        ],
                        description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing text property!"),
                        action: "Write an empty .text to the object",
                        item: blk,
                    };
                    return true;
                }
                return false;
            })) {
                valid = false;
            }
        }
        return false;
    })) {
        valid = false;
    }
    return { valid: valid, resolution: resolution };
}
//# sourceMappingURL=validateValue.js.map