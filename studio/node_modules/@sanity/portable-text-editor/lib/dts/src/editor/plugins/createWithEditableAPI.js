var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { Text, Range, Transforms, Editor, Element as SlateElement } from 'slate';
import { ReactEditor } from '@sanity/slate-react';
import { toSlateValue, fromSlateValue } from '../../utils/values';
import { toSlateRange, toPortableTextRange } from '../../utils/ranges';
import { debugWithName } from '../../utils/debug';
import { KEY_TO_VALUE_ELEMENT, SLATE_TO_PORTABLE_TEXT_RANGE } from '../../utils/weakMaps';
var debug = debugWithName('API:editable');
export function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
    return function withEditableAPI(editor) {
        portableTextEditor.setEditable({
            focus: function () {
                // Make a selection if missing
                if (!editor.selection) {
                    var point = { path: [0, 0], offset: 0 };
                    Transforms.select(editor, { focus: point, anchor: point });
                    editor.onChange();
                }
                ReactEditor.focus(editor);
            },
            blur: function () {
                ReactEditor.blur(editor);
            },
            toggleMark: function (mark) {
                editor.pteToggleMark(mark);
            },
            toggleList: function (listStyle) {
                editor.pteToggleListItem(listStyle);
            },
            toggleBlockStyle: function (blockStyle) {
                editor.pteToggleBlockStyle(blockStyle);
            },
            isMarkActive: function (mark) {
                // Try/catch this, as Slate may error because the selection is currently wrong
                // TODO: catch only relevant error from Slate
                try {
                    return editor.pteIsMarkActive(mark);
                }
                catch (err) {
                    console.warn(err);
                    return false;
                }
            },
            marks: function () {
                return (__assign({}, (Editor.marks(editor) || {})).marks || []);
            },
            undo: function () { return editor.undo(); },
            redo: function () { return editor.redo(); },
            select: function (selection) {
                var slateSelection = toSlateRange(selection, editor);
                if (slateSelection) {
                    Transforms.select(editor, slateSelection);
                }
                else {
                    Transforms.deselect(editor);
                }
                editor.onChange();
            },
            focusBlock: function () {
                if (editor.selection) {
                    // Try/catch this, as Slate may error because the selection is currently wrong
                    // TODO: catch only relevant error from Slate
                    try {
                        var _a = __read(Array.from(Editor.nodes(editor, {
                            at: editor.selection.focus,
                            match: function (n) { return Editor.isBlock(editor, n); },
                        }))[0] || [undefined], 1), block = _a[0];
                        if (block) {
                            return fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            focusChild: function () {
                if (editor.selection) {
                    try {
                        var _a = __read(Array.from(Editor.nodes(editor, {
                            mode: 'lowest',
                            at: editor.selection.focus,
                            match: function (n) { return n._type !== undefined; },
                            voids: true,
                        }))[0] || [undefined], 1), node = _a[0];
                        if (node && !Editor.isBlock(editor, node)) {
                            var pseudoBlock = {
                                _key: 'pseudo',
                                _type: portableTextFeatures.types.block.name,
                                children: [node],
                            };
                            return fromSlateValue([pseudoBlock], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            insertChild: function (type, value) {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                var _b = __read(Array.from(Editor.nodes(editor, {
                    at: editor.selection.focus,
                    match: function (n) { return Editor.isBlock(editor, n); },
                }))[0] || [undefined], 1), focusBlock = _b[0];
                if (!focusBlock) {
                    throw new Error('No focus block');
                }
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    throw new Error("Can't insert childs into block objects");
                }
                var block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: portableTextFeatures.types.block.name,
                        children: [
                            __assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {})),
                        ],
                    },
                ], portableTextEditor)[0];
                var child = block.children[0];
                Editor.insertNode(editor, child);
                editor.onChange();
                return (((_a = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)) === null || _a === void 0 ? void 0 : _a.focus.path) || []);
            },
            insertBlock: function (type, value) {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                var block = toSlateValue([
                    __assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {})),
                ], portableTextEditor)[0];
                Editor.insertNode(editor, block);
                editor.onChange();
                return (((_a = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)) === null || _a === void 0 ? void 0 : _a.focus.path) || []);
            },
            hasBlockStyle: function (style) {
                try {
                    return editor.pteHasBlockStyle(style);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            hasListStyle: function (listStyle) {
                try {
                    return editor.pteHasListStyle(listStyle);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            isVoid: function (element) {
                return ![
                    portableTextFeatures.types.block.name,
                    portableTextFeatures.types.span.name,
                ].includes(element._type);
            },
            findByPath: function (path) {
                var slatePath = toSlateRange({ focus: { path: path, offset: 0 }, anchor: { path: path, offset: 0 } }, editor);
                if (slatePath) {
                    var _a = __read(Editor.node(editor, slatePath.focus.path.slice(0, 1)), 2), block = _a[0], blockPath = _a[1];
                    if (block && blockPath && typeof block._key === 'string') {
                        if (path.length === 1 && slatePath.focus.path.length === 1) {
                            return [
                                fromSlateValue([block], portableTextFeatures.types.block.name)[0],
                                [{ _key: block._key }],
                            ];
                        }
                        var ptBlock = fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        var ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) {
                            return [ptChild, [{ _key: block._key }, 'children', { _key: ptChild._key }]];
                        }
                    }
                }
                return [undefined, undefined];
            },
            findDOMNode: function (element) {
                var node;
                try {
                    var _a = __read(Array.from(Editor.nodes(editor, {
                        at: [],
                        match: function (n) { return n._key === element._key; },
                    }) || [])[0] || [undefined], 1), item = _a[0];
                    node = ReactEditor.toDOMNode(editor, item);
                }
                catch (err) {
                    // Nothing
                }
                return node;
            },
            activeAnnotations: function () {
                var e_1, _a;
                if (!editor.selection || editor.selection.focus.path.length < 2) {
                    return [];
                }
                try {
                    var activeAnnotations_1 = [];
                    var spans = Editor.nodes(editor, {
                        at: editor.selection,
                        match: function (node) {
                            return Text.isText(node) &&
                                node.marks !== undefined &&
                                Array.isArray(node.marks) &&
                                node.marks.length > 0;
                        },
                    });
                    var _loop_1 = function (span, path) {
                        var _c = __read(Editor.node(editor, path, { depth: 1 }), 1), block = _c[0];
                        if (editor.isTextBlock(block)) {
                            block.markDefs.forEach(function (def) {
                                if (Text.isText(span) &&
                                    span.marks &&
                                    Array.isArray(span.marks) &&
                                    span.marks.includes(def._key)) {
                                    activeAnnotations_1.push(def);
                                }
                            });
                        }
                    };
                    try {
                        for (var spans_1 = __values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
                            var _b = __read(spans_1_1.value, 2), span = _b[0], path = _b[1];
                            _loop_1(span, path);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (spans_1_1 && !spans_1_1.done && (_a = spans_1.return)) _a.call(spans_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return activeAnnotations_1;
                }
                catch (err) {
                    return [];
                }
            },
            addAnnotation: function (type, value) {
                var selection = editor.selection;
                if (selection) {
                    var _a = __read(Editor.node(editor, selection.focus, { depth: 1 }), 1), block = _a[0];
                    if (SlateElement.isElement(block) &&
                        block._type === portableTextFeatures.types.block.name) {
                        var annotationKey_1 = keyGenerator();
                        if (editor.isTextBlock(block)) {
                            Transforms.setNodes(editor, {
                                markDefs: __spreadArray(__spreadArray([], __read(block.markDefs), false), [__assign({ _type: type.name, _key: annotationKey_1 }, value)], false),
                            }, { at: selection.focus });
                            editor.onChange();
                            if (Range.isCollapsed(selection)) {
                                editor.pteExpandToWord();
                                editor.onChange();
                            }
                            var _b = __read(Editor.node(editor, selection.focus, { depth: 2 }), 1), textNode_1 = _b[0];
                            if (editor.selection) {
                                Editor.withoutNormalizing(editor, function () {
                                    // Split if needed
                                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                                    if (editor.selection && Text.isText(textNode_1)) {
                                        Transforms.setNodes(editor, {
                                            marks: __spreadArray(__spreadArray([], __read((textNode_1.marks || [])), false), [annotationKey_1], false),
                                        }, {
                                            at: editor.selection,
                                            match: function (n) { return n._type === portableTextFeatures.types.span.name; },
                                        });
                                        editor.onChange();
                                    }
                                });
                                Editor.normalize(editor);
                                editor.onChange();
                                var newSelection = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                                // eslint-disable-next-line max-depth
                                if (newSelection && typeof block._key === 'string') {
                                    // Insert an empty string to continue writing non-annotated text
                                    Editor.withoutNormalizing(editor, function () {
                                        if (editor.selection) {
                                            Transforms.insertNodes(editor, [{ _type: 'span', text: '', marks: [], _key: keyGenerator() }], {
                                                at: Range.end(editor.selection),
                                            });
                                            editor.onChange();
                                        }
                                    });
                                    return {
                                        spanPath: newSelection.focus.path,
                                        markDefPath: [{ _key: block._key }, 'markDefs', { _key: annotationKey_1 }],
                                    };
                                }
                            }
                        }
                    }
                }
                return undefined;
            },
            delete: function (selection, options) {
                if (selection) {
                    var range = toSlateRange(selection, editor);
                    if (range) {
                        if (!(options === null || options === void 0 ? void 0 : options.mode) || (options === null || options === void 0 ? void 0 : options.mode) === 'selected') {
                            debug("Deleting content in selection");
                            Transforms.delete(editor, {
                                at: range,
                                hanging: true,
                                voids: true,
                            });
                            editor.onChange();
                            return;
                        }
                        var nodes = Editor.nodes(editor, {
                            at: range,
                            match: function (node) {
                                if ((options === null || options === void 0 ? void 0 : options.mode) === 'blocks') {
                                    debug("Deleting blocks touched by selection");
                                    return (editor.isTextBlock(node) ||
                                        (!editor.isTextBlock(node) && SlateElement.isElement(node)));
                                }
                                debug("Deleting children touched by selection");
                                return (node._type === portableTextFeatures.types.span.name || // Text children
                                    (!editor.isTextBlock(node) && SlateElement.isElement(node)) // inline blocks
                                );
                            },
                        });
                        var nodeAndPaths = __spreadArray([], __read(nodes), false);
                        nodeAndPaths.forEach(function (_a) {
                            var _b = __read(_a, 2), p = _b[1];
                            Transforms.removeNodes(editor, {
                                at: p,
                                voids: true,
                                hanging: true,
                            });
                        });
                        editor.onChange();
                    }
                }
            },
            removeAnnotation: function (type) {
                var selection = editor.selection;
                debug('Removing annotation', type);
                if (selection) {
                    // Select the whole annotation if collapsed
                    if (Range.isCollapsed(selection)) {
                        var _a = __read(Editor.node(editor, selection, { depth: 2 }), 2), node = _a[0], nodePath = _a[1];
                        if (Text.isText(node) && node.marks && typeof node.text === 'string') {
                            Transforms.select(editor, nodePath);
                            selection = editor.selection;
                        }
                    }
                    // Do this without normalization or span references will be unstable!
                    Editor.withoutNormalizing(editor, function () {
                        if (selection && Range.isExpanded(selection)) {
                            selection = editor.selection;
                            if (!selection) {
                                return;
                            }
                            // Split the span first
                            Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                            editor.onChange();
                            // Everything in the selection which has marks
                            var spans = __spreadArray([], __read(Editor.nodes(editor, {
                                at: selection,
                                match: function (node) {
                                    return Text.isText(node) &&
                                        node.marks !== undefined &&
                                        Array.isArray(node.marks) &&
                                        node.marks.length > 0;
                                },
                            })), false);
                            spans.forEach(function (_a) {
                                var _b = __read(_a, 2), span = _b[0], path = _b[1];
                                var _c = __read(Editor.node(editor, path, { depth: 1 }), 1), block = _c[0];
                                if (editor.isTextBlock(block)) {
                                    block.markDefs
                                        .filter(function (def) { return def._type === type.name; })
                                        .forEach(function (def) {
                                        if (Text.isText(span) &&
                                            Array.isArray(span.marks) &&
                                            span.marks.includes(def._key)) {
                                            var newMarks = __spreadArray([], __read((span.marks || []).filter(function (mark) { return mark !== def._key; })), false);
                                            Transforms.setNodes(editor, {
                                                marks: newMarks,
                                            }, { at: path, voids: false, split: false });
                                        }
                                    });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                    editor.onChange();
                }
            },
            getSelection: function () {
                var ptRange = null;
                if (editor.selection) {
                    var existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                    if (existing) {
                        return existing;
                    }
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
                return ptRange;
            },
            getValue: function () {
                return fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
            },
            isCollapsedSelection: function () {
                return !!editor.selection && Range.isCollapsed(editor.selection);
            },
            isExpandedSelection: function () {
                return !!editor.selection && Range.isExpanded(editor.selection);
            },
        });
        return editor;
    };
}
//# sourceMappingURL=createWithEditableAPI.js.map